\chapter{Automation Objects}
\label{automationobjects}

%% Intro
With the function blocks the main technological problem of
distributed automation has been solved. A general framework
for development and deployment of distributed automation
systems has been developed. What is still needed is a way of
encapsulating function blocks together with the data about
their properties and, more importantly, their functionality
in a way that will enable diminishing the time to market
and facilitate effective rapid object oriented development
of automation systems.

\section{Background}
%% Background. Why automation objects? What do we want to do?
Considering the following arguments it is clear why such
encapsulation is needed and how it can help in achieving the
afore mentioned goal.

%%     effective reuse of software
Object oriented system development as presented in the
IEC~61499 standard is ideal for the purpose that it is
designed for but not enough for achieving \emph{effective
  software reuse} in automation systems development.

%%     effective decentralization of software development 
Effective software reuse facilitates \textit{effective
  decentralization of software development}. If anyone could
use the software that somebody else developed without
wasting time on resolving the difficulties that arise from
poorly documented interfaces, or resorting to
reimplementation because of the same problem, than everyone
could concentrate on providing the best implementation for
their part of the automation system software.

%%     easier integration and deployment of software
Leveraging effective software reuse and decentralized
software development \textit{makes integration and
  deployment much easier}. System integrator's task is
hereby reduced to picking the right software objects from
the library and connecting them for the specific
application.

%%     development of libraries
Using the encapsulation of software objects with well
specified information about their usage makes it possible to
\textit{build libraries} of elements that can easily be
shared over the Internet since everything that is needed for
the usage of the elements comes with the elements
themselves. This is unlike the Java system where the objects
are distributed in binary only format and the interface
documentation has to be downloaded or reviewed on-line prior
to usage.

%%     all of these result in rapid development of
%%     automation systems
The arguments presented are enough to support the idea that
the software objects encapsulated with the information about
their usage will increase the speed of the development of
the automation systems.

%After a specification and a formal definition of the
%encapsulation the benefits beyond the ones discussed above
%will be presented followed by the presentation about the
%implementation issues and the support in Supremica that is
%planned for such data objects.



\section{Specification}
To realize all of the above mentioned arguments a new kind
of software objects are needed, preliminary called
\emph{automation objects}. Even though this kind of objects
are still very much a research subject the following is the
specification of the objects so far.

%Automation Object:
%* consists of models, controllers, views and
%  configuration registry
Automation objects consists of models, views, controllers
and configuration registry implemented using IEC-61499
function blocks and their inteerfaces. Models are
interchangable simulation models with varaying level of
abstraction. One model might be used for the simulation on a
high level of abstraction, typicaly behavioural model, and
another for the simulation on a lower level. This is then
used to implement dynamic zooming during the simulation. One
of the models will implement the communication with the
controlled equpiment thus allowing effortless switching
between simulation and acutal control. This will enable
gradual verification and on-line tuning of the big
automation systems by allowing the simulation of the system
components that are being configured or tuned while running
the components that are already configured.

Controllers are function blocks that control the model. The
best examples of controllers are regulators as PI- or
PID-regulator. On the higher level of the automation system
these can be configurable implementations of different
automation algorithms. This allows interchange of different
controlling strategies for easy verification with simulation
and the equipment.

Views are the function blocks allowing user interaction with
the automation object. These implement all the alowable ways
of interaction with the automation object. At the lower
levels of the automation system they will typically provide
different event and data interfaces depending on the user's
needs while at the higher leve they will implement full
graphical user interfaces for the operators.

%* service is a set of views that support some relevant task
%  for the connected controller  
%* is extensible with user defined services
%* supports replacement of services defined within the
%  object by user defined services
%* supports extension of services
%* supports distribution of services and model among
%  different computing resources
%* has a single topology involving model and services
%* has an access protection mechanism



\section{Implementation and Support in Supremica}
% Support in Supremica

%% implementation of automation objects
%%   archive of XML files
%%   models, views, controllers and registry are declared in
%%   some kind of MetaInformation.xml 

%% libraries 
%%   non-hierarchical pool of automation objects
%%   libraries  may be Internet repositories
%%   searching and sorting by multiple attributes/keys
%%   searching and sorting by services

% Example of usage in Supremica. Three scenarios with the
% lab equipment (kulbanan).
% 1. Student does everything.
% 2. Library is provided and the logic is done by the student.
% 3. Library is proviede and the logic is synthesised by the
%    Supremica.
