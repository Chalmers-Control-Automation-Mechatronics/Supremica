\chapter{Automation Objects}
\label{automationobjects}

%% Intro
With the function blocks the main technological problem of
distributed automation has been solved. A general framework
for development and deployment of distributed automation
system has been developed and established. What is still
needed is a way of encapsulating function blocks together
with the data about their properties and, more importantly,
their functionality in a way that will enable diminishing of
the time to market and facilitate effective rapid object
oriented development of automation systems.

\section{Background}
%% Background. Why automation objects? What do we want to do?
Considering the following arguments it is clear why such
encapsulation is needed and how it can help in achieving the
afore mentioned goal.

%%     effective reuse of software
Object oriented system development as presented in the
IEC~61499 standard is ideal for the purpose that is is
designed for but not enough for achieving {\it effective
  software reuse} in automation systems development.

% grouping software objects in functional units (encapsulation)
% abstraction of functionality (views)
% properties of the functional unit (attributes)


%%     effective decentralization of software development
Effective software reuse facilitates \textit{effective
  decentralization of software development}. If anyone could
use the software that somebody else developed without
wasting time on resolving the difficulties that arise from
poorly documented interfaces, or resorting to
reimplementation because of the same problem, than everyone
could concentrate on providing the best implementation for
their part of the automation system software.

%%     easier integration and deployment of software
Leveraging effective software reuse and decentralized
software development \textit{makes integration and
  deployment much easier}. System integrator's task is
hereby reduced to picking the right software objects from
the library and connecting them in correct patterns for the
specific application.

%%     development of libraries
Using the encapsulation of software objects with well
specified information about their usage makes it possible to
\textit{build libraries} of elements that can easily be
shared over the Internet since everything that is needed for
the usage of the elements comes with the elements
themselves. This is unlike the Java system where the objects
are distributed in binary only format and the interface
documentation has to be downloaded or reviewed on-line prior
to usage.

%%     all of these result in rapid development of automation systems
The arguments presented are enough to support the idea that
the software objects encapsulated with the information about
their usage will increase the speed of the development of
the automation systems. 

After a formal definition of the encapsulation the benefits
beyond the ones discussed above will be presented followed
by the presentation about the implementation issues and the
support in Supremica that is planned for such data objects.





\section{Definition}
%% Definition. 
%%     multi view objects
An \textbf{automation object} is defined as \textit{a set of
  software objects} encapsulated with a declaration of
\textit{services}, \textit{attributes} and \textit{views} of
the set.

The \textbf{set} specifies the applications, subapplications
and function blocks, as defined in \cite{iec:614991:2000},
contained within the automation object. Only one set per
automation object is defined and it contains \textit{all} of
the software objects required for the functionality of the
automation object.
% less dependency problems at the cost of storage, more on
% this after the definition

An \textbf{attribute} is a user defined and specified data that
describes some significant property of the automation
object. 

A \textbf{view} is an interface to the object. Every
interface has at least one implementation.


A \textbf{service} 



%% How this definition supports the arguments above

%% Further benefits of the the automation objects that could
%% not be described prior to definition
%%     views facilitate several different implementations of
%%     the same functionality for different hardware and it
%%     is the hardware vendors that should supply these




\section{Implementation and Support in Supremica}
% Support in Supremica

%% implementation of automation objects
%%     archive of XML files
%%     attribute and view declarations in MetaInformation.xml 

%% libraries 
%%     non-hierarchical pool of automation objects
%%     libraries  may be Internet repositories
%%     searching and sorting by multiple attributes
%%     searching and sorting by multiple views




% Example of usage in Supremica. Three scenarios with the
% lab equipment (kulbanan).
% 1. Student does everything.
% 2. Library is provided and the logic is done by the student.
% 3. Library is proviede and the logic is synthesised by the
%    Supremica.



