/*****************************************************************************
** Generated by DES-to-C++-Generator, Revision 2.6b1
** Fri Dec 10 14:06:34 1999
** (C) Siemens AG, ZT SE 4, 1999. All Rights Reserved.
** Authors: Dr. Markus Kaltenbach, Dr. Robi Malik
*****************************************************************************/

#ifdef __GNUG__
#pragma implementation
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "des_debounce.h"


// States for template 'timer':
const int s_timer__off = 0;
const int s_timer__on = 1;

// States for template 'debouncing_ok.1-sensor_and_filter.1':
const int s_debouncing_0ok_11_2sensor_0and_0filter_11__FLIP = 0;
const int s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT = 1;
const int s_debouncing_0ok_11_2sensor_0and_0filter_11__CHG = 2;
const int s_debouncing_0ok_11_2sensor_0and_0filter_11__WAIT = 3;


// Coding for all Events:
const unsigned short ev_new_value = 0;
const unsigned short ev_timeout = 1;
const unsigned short ev_chg_value = 2;
const unsigned short ev_reset = 3;
const unsigned short ev_timer = 4;


/*****************************************************************************
** DesCode_Automaton_debounce: Step Function Table
*****************************************************************************/

DesCode_Automaton_debounce::pStepFunction DesCode_Automaton_debounce::stepFunction [] = {
  stepUncontrollable_new_value,
  stepUncontrollable_timeout
};

#if defined(WITHTRACE) || defined(DES_SIMULATOR)


/*****************************************************************************
** DesCode_Automaton_debounce: Name Tables
*****************************************************************************/

const char* DesCode_Automaton_debounce::nameTable [] = {
  "new_value.1",
  "timeout.1",
  "chg_value.1",
  "reset.1",
  "timer.1"
};

#endif  // WITHTRACE || DES_SIMULATOR


void DesCode_Automaton_debounce::
init()
{
  // Call superclass method:
  DesCode_Automaton::init();
  // Set up initial states:
  s_timer_11 = s_timer__off;
  s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
}


/*****************************************************************************
** DesCode_Automaton_debounce: Stepping
*****************************************************************************/

bool DesCode_Automaton_debounce::
stepControllables()
{
  /* Transition for event chg_value.1 */
  if (s_debouncing_0ok_11_2sensor_0and_0filter_11 == s_debouncing_0ok_11_2sensor_0and_0filter_11__CHG) {
    s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
    Action_chg_value(1);
    return true;
  }
  /* Transition for event reset.1 */
  if (s_timer_11 == s_timer__on &&
      s_debouncing_0ok_11_2sensor_0and_0filter_11 <= s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT) {
    s_timer_11 = s_timer__off;
    Action_reset(1);
    return true;
  }
  /* Transition for event timer.1 */
  if (s_timer_11 == s_timer__off &&
      s_debouncing_0ok_11_2sensor_0and_0filter_11 == s_debouncing_0ok_11_2sensor_0and_0filter_11__FLIP) {
    s_timer_11 = s_timer__on;
    s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__WAIT;
    Action_timer(1);
    return true;
  }
  return false;
}


bool DesCode_Automaton_debounce::
stepUncontrollable(const DesCode_SignalledEvent& event)
{
  return (this->*(stepFunction[event.mEventFamily])) (event.mParameter);
}


bool DesCode_Automaton_debounce::
stepUncontrollable_new_value(unsigned short argv)
{
  /* Transition for event new_value.1 */
  switch (s_debouncing_0ok_11_2sensor_0and_0filter_11) {
  case s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT:
    s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__FLIP;
    break;
  default:
    s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
    break;
  }
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  Action_new_value(1);
#endif  // WITHTRACE || DES_SIMULATOR
  return true;
}


bool DesCode_Automaton_debounce::
stepUncontrollable_timeout(unsigned short argv)
{
  /* Transition for event timeout.1 */
  if (s_timer_11 == s_timer__on) {
    s_timer_11 = s_timer__off;
    switch (s_debouncing_0ok_11_2sensor_0and_0filter_11) {
    case s_debouncing_0ok_11_2sensor_0and_0filter_11__WAIT:
      s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__CHG;
      break;
    }
    Action_timeout(1);
    return true;
  } else {
    return false;
  }
}


bool DesCode_Automaton_debounce::
isMarkedState()
  const
{
  return
    s_timer_11 == s_timer__off &&
    s_debouncing_0ok_11_2sensor_0and_0filter_11 == s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
}


#if defined(WITHTRACE) || defined(DES_SIMULATOR)
void DesCode_Automaton_debounce::
Action_new_value(int argv1)
{
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_new_value);
  debugAction(*event);
  delete event;
}

#endif  // WITHTRACE || DES_SIMULATOR

void DesCode_Automaton_debounce::
Action_timeout(int argv1)
{
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_timeout);
  debugAction(*event);
  delete event;
#endif  // WITHTRACE || DES_SIMULATOR
}


void DesCode_Automaton_debounce::
Action_chg_value(int argv1)
{
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_chg_value);
  debugAction(*event);
  delete event;
#endif  // WITHTRACE || DES_SIMULATOR
}


void DesCode_Automaton_debounce::
Action_reset(int argv1)
{
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_reset);
  debugAction(*event);
  delete event;
#endif  // WITHTRACE || DES_SIMULATOR
}


void DesCode_Automaton_debounce::
Action_timer(int argv1)
{
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_timer);
  debugAction(*event);
  delete event;
#endif  // WITHTRACE || DES_SIMULATOR
}


void DesCode_Automaton_debounce::
Signal_new_value(int argv1)
{
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_new_value);
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  debugSignal(*event);
#endif  // WITHTRACE || DES_SIMULATOR
  signalEvent(event);
}


void DesCode_Automaton_debounce::
Signal_timeout(int argv1)
{
  DesCode_SignalledEvent* event = new DesCode_SignalledEvent(ev_timeout);
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  debugSignal(*event);
#endif  // WITHTRACE || DES_SIMULATOR
  signalEvent(event);
}


/*****************************************************************************
** DesCode_Automaton_debounce: Name generation for all events
*****************************************************************************/

#if defined(WITHTRACE) || defined(DES_SIMULATOR)

char* DesCode_Automaton_debounce::
getEventName(const DesCode_SignalledEvent& event)
  const
{
  char* result;
  int nlen = strlen(nameTable[event.mEventFamily]);
  result = new char [nlen+1];
  strcpy(result, nameTable[event.mEventFamily]);
  return result;
}

#endif  // WITHTRACE || DES_SIMULATOR


