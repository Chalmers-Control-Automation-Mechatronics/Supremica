<HTML>
<HEAD>
<TITLE>VALID Example Debounce: C++ Code Generation</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
</HEAD>

<BODY BGCOLOR="WHITE" LINK="BLUE" VLINK="PURPLE">

<H1>VALID Example: Debounce</H1>

<H2>C++ Code Generation Tutorial</H2>

<P>This page shows how to produce a simple, command-line based application
implementing the <A HREF="task.html">debounce</A> example, using VALID's
<A HREF="../../docs/onlinemanual/OnLineManualCodeGeneration.html">generated
code</A>.</P>

<P>The application to be produced will prompt the user for new sensor
values and print all occurring events. By inputting a sequence of sensor
values (e.g. 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, each on a new
line), it is possible to observe the behaviour of the debounce circuit. The
program is terminated by typing the end-of-file character.</P>

<P ALIGN=CENTER><IMG SRC="debounce_run.gif" WIDTH=506 HEIGHT=331
  ALT="The debounce executable"></P>

<P>The corresponding C++ code files for this example can be found in the
examples directory of the VALID distribution, in directory
<CODE>&lt;VALID&gt;\examples\debounce\cpp-debounce</CODE>.</P>

<H3>Generating Code</H3>

<P>In order to obtain executable C++ code, we first generate the C++ files
with the VALID Toolset. We open the project <CODE>debounce</CODE> and
select <CODE>C++ Code Generation</CODE> from the <CODE>Code</CODE> menu. In
the appearing <A HREF=
"../../docs/onlinemanual/OnLineManualCodeGenerationWindow.html">
dialog</A>, we select the default base class <A HREF=
"../../docs/onlinemanual/OnLineManualCodeGenerationAPI.html#DesCode_Automaton">
<CODE>DesCode_Automaton</CODE></A>, as this is a simple example which works
without threading. (A variation of the same example using the threaded
baseclass <A HREF=
"../../docs/onlinemanual/OnLineManualCodeGenerationAPI.html#DesCode_AutomatonThreaded"><CODE>DesCode_AutomatonThreaded</CODE></A>
is found in directory
<CODE>&lt;VALID&gt;\examples\debounce\cpp-multithreaded</CODE>.)

<P>Then we choose a target directory and optimization settings as desired,
and click <CODE>Generate</CODE> in order to generate the C++ source
files. This step creates four files, which appear in the chosen
target directory:</P>
<UL>
<LI><CODE>des_debounce.h</CODE></LI>
<LI><CODE>des_debounce.cpp</CODE></LI>
<LI><CODE>app_debounce.h</CODE></LI>
<LI><CODE>app_debounce.cpp</CODE></LI>
</UL>
<P>The former two files contain the control logic, and will not be touched
any further. The latter two contain the action code fragments, which
augmented in subsequent steps in order to suit our specific needs.</P>

<P>Furthermore, the example uses the project-independent base class <A
HREF=
"../../docs/onlinemanual/OnLineManualCodeGenerationAPI.html#DesCode_Automaton">
<CODE>DesCode_Automaton</CODE></A>. The code implementing this class is
supplied with the VALID distribution, in the <CODE>include</CODE> directory
(<CODE>&lt;VALID&gt;\include</CODE>). We copy the following two files from
this directory in order to compile them when building the executable:</P>
<UL>
<LI><CODE>DesCode_Automaton.h</CODE></LI>
<LI><CODE>DesCode_Automaton.cpp</CODE></LI>
</UL>

<H3>Adding Data Structures to the Application Class</H3>

<P>The running example uses a timer, which we choose to represent by means
of an integer containing the number of cycles (sampling periods) elapsed
since the timer has been started. If the timer is unused, we will set it to
the value&nbsp;-1. Furthermore, we have to keep track of the input signal
in order to generate the uncontrollable event <CODE>new_value.1</CODE>
whenever the input changes. In this simple example, we will ask the user to
type a character on the keyboard at the beginning of each cycle, and emit
<CODE>new_value.1</CODE> whenever the input differs from the input observed
during the previous cycle.</P>

<P>Thus, in addition to the state information of the automaton, our
application will need two data items. Therefore, we edit the generated
header file <CODE>app_debounce.h</CODE> and add two fields called
<CODE>mLastKey</CODE> and <CODE>mTime</CODE> to the application class. We
also make sure that these fields are initialized with appropriate values in
our class constructor. The modified class will look something like the
following:</P>

<TABLE WIDTH=90% ALIGN=CENTER BORDER=0 BGCOLOR="#e0e0e0" CELLPADDING=10>
<TR><TD><BR><PRE>
class DesCode_Actions_debounce : public DesCode_Automaton_debounce {
public:
  DesCode_Actions_debounce() {mTime = -1; mLastKey = 0;};

  ...

  /* Member variables */
  char mLastKey;
  int mTime;
};
</PRE><TD></TR>
</TABLE>

<H3>Defining Action Code Fragments</H3>

<P>Next, we have to assign our user-specific code fragments to all events,
which should execute special actions. In the example, we want the timer to
be started, whenever a start even occurs, and we want it to be reset in
case of a reset or timeout event. In order to achieve this, we edit the
code fragments in file <CODE>app_debounce.cpp</CODE> and insert assignments
to the <CODE>mTime</CODE> member variables of our class. When event
<CODE>timer.1</CODE> occurs, the variable is set to&nbsp;0, causing the
timer to be incremented by&nbsp;1 per cycle; when event
<CODE>reset.1</CODE> or <CODE>timeout.1</CODE> occurs, the variable is
reset to&nbsp;-1, stopping the timer.</P>

<TABLE WIDTH=90% ALIGN=CENTER BORDER=0 BGCOLOR="#e0e0e0" CELLPADDING=10>
<TR><TD><BR><PRE>
/********************************************************
** Code fragment for event: timer
********************************************************/
void DesCode_Actions_debounce::
Action_timer(int bit)
{
  DesCode_Automaton_debounce::Action_timer(bit);
  mTime = 0;
}


/********************************************************
** Code fragment for event: reset
********************************************************/
void DesCode_Actions_debounce::
Action_reset(int bit)
{
  DesCode_Automaton_debounce::Action_reset(bit);
  mTime = -1;
}


/********************************************************
** Code fragment for event: timeout
********************************************************/
void DesCode_Actions_debounce::
Action_timeout(int bit)
{
  DesCode_Automaton_debounce::Action_timeout(bit);
  mTime = -1;
}
</PRE><TD></TR>
</TABLE>

<P>Furthermore, we want to print a message to the terminal, whenever the
event <CODE>chg_value</CODE> is generated, i.e. whenever a stabilized
change of the input has been detected. We add an appropriate command to the
corresponding code fragment:</P>

<TABLE WIDTH=90% ALIGN=CENTER BORDER=0 BGCOLOR="#e0e0e0" CELLPADDING=10>
<TR><TD><BR><PRE>
/********************************************************
** Code fragment for event: chg_value
********************************************************/
void DesCode_Actions_debounce::
Action_chg_value(int bit)
{
  DesCode_Automaton_debounce::Action_chg_value(bit);
  cout << "*** Value HAS changed ***" << endl;
}
</PRE><TD></TR>
</TABLE>

<P>In this example, all code fragments are passed a template instantiation
parameter, which we have called <CODE>bit</CODE>. This has been introduced
in order to obtain code which can be easily extended to a multi-bit
debounce circuit. By changing the template instantiation range within the
model, it is easy to create more events and automata. In such a case, the
code fragments will be passed the number of the bit to be considered as the
<CODE>bit</CODE> parameter. In the simple example, we only have one
bit-thus the parameter will always be set to&nbsp;1, and therefore is
ignored.</P>

<H3>Writing an Execution Method</H3>

<P>Finally, we have to make sure that the automaton is supplied with
inputs, i.e. we have to make sure that the occurrence of uncontrollable
events is signaled. In a multi-threaded environment, this will probably
happen in another thread, but in this simple example, we will suspend the
execution of the automaton after each step, and ask the user for the next
input, before we let the automaton continue.</P>

<P>Such behavior can be easily implemented as a new method called
<CODE>execute()</CODE>, which we add to the action class. This method reads
the keyboard, signals uncontrollable events, and calls <CODE>step()</CODE>
in an appropriate sequence of order. At the beginning of each cycle, the
method reads a new line from the terminal, and if the first character read
differs from the input observed in the previous cycle, it generates the
uncontrollable event <CODE>new_value.1</CODE> by calling its signaling
function. Similarly, it generates an event <CODE>timeout.1</CODE>, if the
timer has been running for five consecutive cycles. Afterwards, it performs
an automaton step by calling the automatically generated
<CODE>step()</CODE> method provided by the superclass.</P>

<P>This behavior is implemented by the following method, which we add to
the file <CODE>app_debounce.cpp</CODE>. We also have to declare the method
in the header file <CODE>app_debounce.h</CODE>.</P>

<TABLE WIDTH=90% ALIGN=CENTER BORDER=0 BGCOLOR="#e0e0e0" CELLPADDING=10>
<TR><TD><BR><PRE>
const int TIMEOUT = 5;

void DesCode_Actions_debounce::
execute()
{
  // Initialize automaton
  init();
  // Loop forever ...
  for (;;) {
    // Read uncontrollables from keyboard and signal them:
    char buffer[1024];
    cout << "New input: " << flush;
    cin.getline(buffer, 1024);
    if (!cin) {
      cout << "<QUIT>" << endl;
      break;
    }
    char key = buffer[0];
    if (key != mLastKey) {
      Signal_new_value(1);
      mLastKey = key;
    }
    if (mTime >= 0) {
      if (++mTime == TIMEOUT) {
        Signal_timeout(1);
      }
    }
    // Perform automaton step by calling superclass method:
    step();
  }
}
</PRE><TD></TR>
</TABLE>

<H3>Running the Automaton</H3>

<P>In order to run the automaton, we create an object of the application
class and call its <CODE>execute()</CODE> method. The following
simple <CODE>main()</CODE> routine does exactly what is needed:</P>

<TABLE WIDTH=90% ALIGN=CENTER BORDER=0 BGCOLOR="#e0e0e0" CELLPADDING=10>
<TR><TD><BR><PRE>
int main(int argc, char** argv)
{
  DesCode_Actions_debounce application;
  application.setTraceFunction(trace);
  application.execute();
  return 0;
}
</PRE><TD></TR>
</TABLE>

<P>In order to obtain tracing output, we have to supply a tracing function to
the automaton. In this example, it suffices to use a simple method, which
just writes copy its input to the standard output stream. In more complex
environments, especially when using multiple threads, more subtle output
methods may be used.</P>

<TABLE WIDTH=90% ALIGN=CENTER BORDER=0 BGCOLOR="#e0e0e0" CELLPADDING=10>
<TR><TD><BR><PRE>
static void trace(const char* line)
{
  cout << line << flush;
}
</PRE><TD></TR>
</TABLE>

<P>It is a good idea to create a new file called <CODE>main.cpp</CODE>
containing these two function definitions.</P>

<P>Now the source files are completed. In order to obtain the executable,
we compile and link the four C++ files <CODE>DesCode_Automaton.cpp</CODE>,
<CODE>des_debounce.cpp</CODE>, <CODE>app_debounce.cpp</CODE>, and
<CODE>main.cpp</CODE>. In order to activate tracing output, we set the
compiler flag <CODE>WITH_TRACE</CODE> during compilation.</P>


<HR ALIGN=CENTER WIDTH="100%" SIZE="2">
<CENTER>
<A HREF="task.html"><IMG HEIGHT=40 WIDTH=40 ALT="Back" SRC="../left.gif"></A>
<A HREF="index.html"><IMG HEIGHT=40 WIDTH=40 ALT="Up" SRC="../up.gif"></A>
<IMG HEIGHT=40 WIDTH=40 ALT="Forward" SRC="../right.gif">
</CENTER>
<HR ALIGN=CENTER WIDTH="100%" SIZE="2">

<P><FONT SIZE="-1">&copy;&nbsp;1998-2000, VALID Technologies.
<!-- hhmts start -->
Last Modification Date: 2000-06-19
<!-- hhmts end -->
</FONT></P>

</BODY>
</HTML>
