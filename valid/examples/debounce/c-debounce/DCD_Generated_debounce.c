/*****************************************************************************
** Generated by DES-to-C-Generator, Revision 2.5C
** Fri Dec 10 11:33:23 1999
** (C) Siemens AG, ZT SE 4, 1999. All Rights Reserved.
** Authors: Dr. Markus Kaltenbach, Dr. Robi Malik
*****************************************************************************/

#ifdef __GNUG__
#pragma implementation
#endif

#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "DCD_Project_debounce.h"


/* States for template 'timer': */
#define s_timer__off 0
#define s_timer__on 1

/* States for template 'debouncing_ok.1-sensor_and_filter.1': */
#define s_debouncing_0ok_11_2sensor_0and_0filter_11__FLIP 0
#define s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT 1
#define s_debouncing_0ok_11_2sensor_0and_0filter_11__CHG 2
#define s_debouncing_0ok_11_2sensor_0and_0filter_11__WAIT 3


/* Coding for all Events: */
#define ev_new_value 0
#define ev_timeout 1
#define ev_chg_value 2
#define ev_reset 3
#define ev_timer 4


/*****************************************************************************
** DCD_Project_debounce: Step Function Table
*****************************************************************************/

typedef int DCD_Project_debounce_StepFunction
  (DCD_Project_debounce* project, unsigned short argv);

static DCD_Project_debounce_StepFunction* DCD_Project_debounce_stepFunction [] = {
  DCD_Project_debounce_stepUncontrollable_new_value,
  DCD_Project_debounce_stepUncontrollable_timeout
};

#if defined(WITHTRACE) || defined(DES_SIMULATOR)


/*****************************************************************************
** DCD_Project_debounce: Name Tables
*****************************************************************************/

static char* DCD_Project_debounce_nameTable [] = {
  "new_value.1",
  "timeout.1",
  "chg_value.1",
  "reset.1",
  "timer.1"
};

#endif  /* WITHTRACE || DES_SIMULATOR */


/*****************************************************************************
** DCD_Project_debounce: Initialization
*****************************************************************************/

void DCD_States_debounce_init(DCD_States_debounce* states)
{
  states->s_timer_11 = s_timer__off;
  states->s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
}


/*****************************************************************************
** DCD_Project_debounce: Stepping
*****************************************************************************/

int DCD_Project_debounce_step(DCD_Project_debounce* project)
{
  DCD_SignalledEvent* event =
  DCD_Automaton_getNextUncontrollable(&project->mAutomaton);
  if (event) {
#ifdef WITHTRACE
    if (!DCD_Project_debounce_stepUncontrollable(project, event)) {
      char* name = DCD_Project_debounce_getEventName(project, event);
      DCD_Automaton_debugWarning(&project->mAutomaton, name, "is not allowed!");
      free(name);
    }
#else
    DCD_Project_debounce_stepUncontrollable(project, event);
#endif
    free(event);
    return 1;
  }
  return DCD_Project_debounce_stepControllables(project);
}


int DCD_Project_debounce_stepControllables(DCD_Project_debounce* project)
{
  /* Transition for event chg_value.1 */
  if (project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 == s_debouncing_0ok_11_2sensor_0and_0filter_11__CHG) {
    project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
    DCD_Project_debounce_debugAction_chg_value(project, 1);
#endif  /* WITHTRACE || DES_SIMULATOR */
    DCD_Project_debounce_Action_chg_value(project, 1);
    return 1;
  }
  /* Transition for event reset.1 */
  if (project->mStates.s_timer_11 == s_timer__on &&
      project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 <= s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT) {
    project->mStates.s_timer_11 = s_timer__off;
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
    DCD_Project_debounce_debugAction_reset(project, 1);
#endif  /* WITHTRACE || DES_SIMULATOR */
    DCD_Project_debounce_Action_reset(project, 1);
    return 1;
  }
  /* Transition for event timer.1 */
  if (project->mStates.s_timer_11 == s_timer__off &&
      project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 == s_debouncing_0ok_11_2sensor_0and_0filter_11__FLIP) {
    project->mStates.s_timer_11 = s_timer__on;
    project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__WAIT;
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
    DCD_Project_debounce_debugAction_timer(project, 1);
#endif  /* WITHTRACE || DES_SIMULATOR */
    DCD_Project_debounce_Action_timer(project, 1);
    return 1;
  }
  return 0;
}


int DCD_Project_debounce_stepUncontrollable
    (DCD_Project_debounce* project, DCD_SignalledEvent* event)
{
  return (*(DCD_Project_debounce_stepFunction[event->mEventFamily]))
          (project, event->mParameter);
}


int DCD_Project_debounce_stepUncontrollable_new_value
    (DCD_Project_debounce* project, unsigned short argv)
{
  /* Transition for event new_value.1 */
  switch (project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11) {
  case s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT:
    project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__FLIP;
    break;
  default:
    project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
    break;
  }
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  DCD_Project_debounce_debugAction_new_value(project, 1);
#endif  /* WITHTRACE || DES_SIMULATOR */
  return 1;
}


int DCD_Project_debounce_stepUncontrollable_timeout
    (DCD_Project_debounce* project, unsigned short argv)
{
  /* Transition for event timeout.1 */
  if (project->mStates.s_timer_11 == s_timer__on) {
    project->mStates.s_timer_11 = s_timer__off;
    switch (project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11) {
    case s_debouncing_0ok_11_2sensor_0and_0filter_11__WAIT:
      project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 = s_debouncing_0ok_11_2sensor_0and_0filter_11__CHG;
      break;
    }
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
    DCD_Project_debounce_debugAction_timeout(project, 1);
#endif  /* WITHTRACE || DES_SIMULATOR */
    DCD_Project_debounce_Action_timeout(project, 1);
    return 1;
  } else {
    return 0;
  }
}


int DCD_Project_debounce_isMarkedState(DCD_Project_debounce* project)
{
  return
    project->mStates.s_timer_11 == s_timer__off &&
    project->mStates.s_debouncing_0ok_11_2sensor_0and_0filter_11 == s_debouncing_0ok_11_2sensor_0and_0filter_11__INIT;
}


#if defined(WITHTRACE) || defined(DES_SIMULATOR)

void DCD_Project_debounce_debugAction_new_value
    (DCD_Project_debounce* project, int argv1)
{
  char* name;
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_new_value;
  name = DCD_Project_debounce_getEventName(project, event);
  free(event);
  DCD_Automaton_debugAction(&project->mAutomaton, name);
  free(name);
}


void DCD_Project_debounce_debugAction_timeout
    (DCD_Project_debounce* project, int argv1)
{
  char* name;
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_timeout;
  name = DCD_Project_debounce_getEventName(project, event);
  free(event);
  DCD_Automaton_debugAction(&project->mAutomaton, name);
  free(name);
}


void DCD_Project_debounce_debugAction_chg_value
    (DCD_Project_debounce* project, int argv1)
{
  char* name;
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_chg_value;
  name = DCD_Project_debounce_getEventName(project, event);
  free(event);
  DCD_Automaton_debugAction(&project->mAutomaton, name);
  free(name);
}


void DCD_Project_debounce_debugAction_reset
    (DCD_Project_debounce* project, int argv1)
{
  char* name;
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_reset;
  name = DCD_Project_debounce_getEventName(project, event);
  free(event);
  DCD_Automaton_debugAction(&project->mAutomaton, name);
  free(name);
}


void DCD_Project_debounce_debugAction_timer
    (DCD_Project_debounce* project, int argv1)
{
  char* name;
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_timer;
  name = DCD_Project_debounce_getEventName(project, event);
  free(event);
  DCD_Automaton_debugAction(&project->mAutomaton, name);
  free(name);
}

#endif  /* WITHTRACE || DES_SIMULATOR */


void DCD_Project_debounce_Signal_new_value
    (DCD_Project_debounce* project, int argv1)
{
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_new_value;
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  {
    char* name;
    name = DCD_Project_debounce_getEventName(project, event);
    DCD_Automaton_debugSignal(&project->mAutomaton, name);
    free(name);
  }
#endif  /* WITHTRACE || DES_SIMULATOR */
  DCD_Automaton_signalEvent(&project->mAutomaton, event);
}


void DCD_Project_debounce_Signal_timeout
    (DCD_Project_debounce* project, int argv1)
{
  DCD_SignalledEvent* event;
  event = (DCD_SignalledEvent*) malloc(sizeof(DCD_SignalledEvent));
  event->mEventFamily = ev_timeout;
#if defined(WITHTRACE) || defined(DES_SIMULATOR)
  {
    char* name;
    name = DCD_Project_debounce_getEventName(project, event);
    DCD_Automaton_debugSignal(&project->mAutomaton, name);
    free(name);
  }
#endif  /* WITHTRACE || DES_SIMULATOR */
  DCD_Automaton_signalEvent(&project->mAutomaton, event);
}


/*****************************************************************************
** DCD_Project_debounce: Name generation for all events
*****************************************************************************/

#if defined(WITHTRACE) || defined(DES_SIMULATOR)

char* DCD_Project_debounce_getEventName
    (DCD_Project_debounce* project, DCD_SignalledEvent* event)
{
  char* result;
  int nlen = strlen(DCD_Project_debounce_nameTable[event->mEventFamily]);
  result = (char*) malloc(nlen+1 * sizeof(char));
  strcpy(result, DCD_Project_debounce_nameTable[event->mEventFamily]);
  return result;
}

#endif  /* WITHTRACE || DES_SIMULATOR */


/*****************************************************************************
** DCD_Project_debounce: Tracing
*****************************************************************************/

#if defined(WITHTRACE) || defined(DES_SIMULATOR)

void DCD_Project_debounce_setTraceFunction
    (DCD_Project_debounce* project, DCD_TraceFunction* f)
{
  DCD_Automaton_setTraceFunction(&project->mAutomaton, f);
}

#endif  /* WITHTRACE || DES_SIMULATOR */


