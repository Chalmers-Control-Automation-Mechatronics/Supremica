/*
 * This file is automatically generated from Supremica
 * Supremica version: 200404261439
 * This file was generated at: 2004-apr-29 14:14:47
 */
import org.supremica.softplc.RunTime.DigitalIODriver;
/**
 * Class CatAndMouse was automatically generated from
 * Supremica.
 *
 * The class is depending on the interface
 * org.supremica.softplc.RunTime.DigitalIODriver and
 * on the class DigitalIODriverFactory. The latter
 * should be provided by the user. This class should
 * create objects that implements the DigitalIODriver
 * interface. The implementing class is by nature
 * applicaton specific.
 *
 * The following automata are synchronized.
 * The number is the index used in this file
 * to identify the automata.
 *   Automaton 0: "cat"
 *   Automaton 1: "mouse"
 *   Automaton 2: "room1"
 *   Automaton 3: "room2"
 *   Automaton 4: "room3"
 *   Automaton 5: "room4"
 *   Automaton 6: "room5"
 *
 * Event indices and the corresponding event label
 *   Event 0: "c1" controllable
 *   Event 1: "c2" controllable
 *   Event 2: "c3" controllable
 *   Event 3: "c4" controllable
 *   Event 4: "c5" controllable
 *   Event 5: "c6" controllable
 *   Event 6: "c7" uncontrollable
 *   Event 7: "c8" uncontrollable
 *   Event 8: "m1" controllable
 *   Event 9: "m2" controllable
 *   Event 10: "m3" controllable
 *   Event 11: "m4" controllable
 *   Event 12: "m5" controllable
 *   Event 13: "m6" controllable
 *
 * Input signal ports and the corresponding label
 *   No input signals
 *
 * Output signal ports and the corresponding label
 *   No output signals
 *
 * Timer indices and the corresponding label
 *   No timers
 */
public class CatAndMouse {
	/**
	 * Class Timer is a simple countdown timer.
	 * Start the timer like this:
	 * <code>myTimer.start()</code>
	 * It has timed out if:
	 * <code>myTimer.hasTimedOut()</code>
	 * returns true.
	 */
	static class Timer {
		int delay;
		Thread timerThread;
		public Timer(int delay) { // In ms
			this.delay = delay;
		}
		public void start() {
			timerThread = new Thread(new Runnable() {
				public void run() {
					try {
						Thread.sleep(Timer.this.delay);
					} catch (InterruptedException e) {}
				}
			});
			timerThread.start();
		}
		public boolean hasTimedOut() {
			return timerThread == null || !timerThread.isAlive();
		}
	}

	static final int NO_EVENT_IS_SELECTED = -1;
	static final int NR_OF_EVENTS = 14;
	static final int NR_OF_AUTOMATA = 7;
	static final int NR_OF_TIMERS = 0;

	/**
	 * Preferred scan cycle time in milliseconds.
	 * The program executes continously if the real
	 * scan cycle time is larger than this value.
	 */
	static final int PREFERRED_SCAN_CYCLE_TIME = 0;

	/**
	 * The enabled event that comes first in this array is executed.
	 * The uncontrollable events has the highest priority
	 */
	static final int[] EVENT_PRIORITY_QUEUE = {6, 7, 0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13};

	/**
	 * A map from event index to event label. Is not used by default.
	 */
	static final String[] EVENT_LABELS = {"c1",
			"c2",
			"c3",
			"c4",
			"c5",
			"c6",
			"c7",
			"c8",
			"m1",
			"m2",
			"m3",
			"m4",
			"m5",
			"m6"};

	/**
	 * This vector holds the current state.
	 * The indices corresponds to automata.
	 * The value of an element corresponds
	 * to the state of that automaton. It is
	 * initiated to its' initial states.
	 */
	int[] currentState = {2,
			4,
			1,
			1,
			0,
			1,
			2};

	/**
	 * This array holds the last read input signal values.
	 */
	boolean[] inputVariables;

	/**
	 * This vector holds the output signal values to be written.
	 */
	boolean[] outputVariables;

	/**
	 * This object handles IO. The user (you) should
	 * provide a class that implements the interface
	 * org.supremica.softplc.RunTime.DigitalIODriver
	 */
	DigitalIODriver digitalIODriver;

	final Timer[] timers = {};

	/**
	 * Constructor
	 */
	CatAndMouse() {
		/*
		 * DigitalIODriverFactory is a class that
		 * should be implemented by the user (you).
		 * The class should have a public static function
		 * that creates an object which implements the
		 * org.supremica.softplc.RunTime.DigitalIODriver
		 * interface.
		 */
		digitalIODriver = DigitalIODriverFactory.createDigitalIODriver();
		inputVariables = new boolean[digitalIODriver.getNrOfSignalsIn()];
		outputVariables = new boolean[digitalIODriver.getNrOfSignalsOut()];
	}

	/**
	 * Checks if the event is enabled in the
	 * current state of the automata
	 * @param eventIndex
	 * @return <code>true</code> if the event is enabled.
	 *         <code>false</code> otherwise.
	 */
	boolean eventIsEnabledInCurrentState(int eventIndex) {
		switch (eventIndex) {
		case 0: // Event "c1"
			return (currentState[0] == 0)
					&& (currentState[2] == 0)
					&& (currentState[3] == 1);
		case 1: // Event "c2"
			return (currentState[0] == 1)
					&& (currentState[3] == 0)
					&& (currentState[4] == 1);
		case 2: // Event "c3"
			return (currentState[0] == 2)
					&& (currentState[2] == 1)
					&& (currentState[4] == 0);
		case 3: // Event "c4"
			return (currentState[0] == 0)
					&& (currentState[2] == 0)
					&& (currentState[5] == 1);
		case 4: // Event "c5"
			return (currentState[0] == 3)
					&& (currentState[5] == 0)
					&& (currentState[6] == 1);
		case 5: // Event "c6"
			return (currentState[0] == 4)
					&& (currentState[2] == 1)
					&& (currentState[6] == 0);
		case 6: // Event "c7"
			return (currentState[0] == 1)
					&& (currentState[3] == 0)
					&& (currentState[5] == 1);
		case 7: // Event "c8"
			return (currentState[0] == 3)
					&& (currentState[3] == 1)
					&& (currentState[5] == 0);
		case 8: // Event "m1"
			return (currentState[1] == 0)
					&& (currentState[2] == 2)
					&& (currentState[4] == 1);
		case 9: // Event "m2"
			return (currentState[1] == 2)
					&& (currentState[3] == 1)
					&& (currentState[4] == 2);
		case 10: // Event "m3"
			return (currentState[1] == 1)
					&& (currentState[2] == 1)
					&& (currentState[3] == 2);
		case 11: // Event "m4"
			return (currentState[1] == 0)
					&& (currentState[2] == 2)
					&& (currentState[6] == 1);
		case 12: // Event "m5"
			return (currentState[1] == 4)
					&& (currentState[5] == 1)
					&& (currentState[6] == 2);
		case 13: // Event "m6"
			return (currentState[1] == 3)
					&& (currentState[2] == 1)
					&& (currentState[5] == 2);
		default:
			// Should never get here
			return false;
		}
	}

	/**
	 * Checks if the event is enabled by conditions
	 * on input variable values.
	 * @param eventIndex
	 * @return <code>true</code> if the event is enabled.
	 *         <code>false</code> otherwise.
	 */
	boolean eventIsEnabledByInputVariables(int eventIndex) {
		/*
		 * All external conditions are true by default.
		 * Example:
		 * case 8: // Event "product_arrival"
		 *   return inputVariables[5];  // Sensor on port 5
		 */
		switch (eventIndex) {
		default:
			return true;
		}
	}

	/**
	 * Checks if the event is enabled by timers.
	 * @param eventIndex
	 * @return <code>true</code> if the event is enabled.
	 *         <code>false</code> otherwise.
	 */
	boolean eventIsEnabledByTimers(int eventIndex) {
		/*
		 * All timer conditions are true by default.
		 * Example:
		 * case 5: // Event "mytimer_timeout"
		 *   return timers[2].hasTimedOut();  // Timer "mytimer"
		 */
		switch (eventIndex) {
		default:
			return true;
		}
	}

	/**
	 * Updates the states of the automata
	 * @param eventIndex The executed event
	 */
	void updateCurrentState(int eventIndex) {
		switch (eventIndex) {
		case NO_EVENT_IS_SELECTED: // If no event was enabled
			break;
		case 0: // Event "c1"

			// Transitions in "cat"
			if (currentState[0] == 0)
				currentState[0] = 1;

			// Transitions in "room1"
			if (currentState[2] == 0)
				currentState[2] = 1;

			// Transitions in "room2"
			if (currentState[3] == 1)
				currentState[3] = 0;
			break;
		case 1: // Event "c2"

			// Transitions in "cat"
			if (currentState[0] == 1)
				currentState[0] = 2;

			// Transitions in "room2"
			if (currentState[3] == 0)
				currentState[3] = 1;

			// Transitions in "room3"
			if (currentState[4] == 1)
				currentState[4] = 0;
			break;
		case 2: // Event "c3"

			// Transitions in "cat"
			if (currentState[0] == 2)
				currentState[0] = 0;

			// Transitions in "room1"
			if (currentState[2] == 1)
				currentState[2] = 0;

			// Transitions in "room3"
			if (currentState[4] == 0)
				currentState[4] = 1;
			break;
		case 3: // Event "c4"

			// Transitions in "cat"
			if (currentState[0] == 0)
				currentState[0] = 3;

			// Transitions in "room1"
			if (currentState[2] == 0)
				currentState[2] = 1;

			// Transitions in "room4"
			if (currentState[5] == 1)
				currentState[5] = 0;
			break;
		case 4: // Event "c5"

			// Transitions in "cat"
			if (currentState[0] == 3)
				currentState[0] = 4;

			// Transitions in "room4"
			if (currentState[5] == 0)
				currentState[5] = 1;

			// Transitions in "room5"
			if (currentState[6] == 1)
				currentState[6] = 0;
			break;
		case 5: // Event "c6"

			// Transitions in "cat"
			if (currentState[0] == 4)
				currentState[0] = 0;

			// Transitions in "room1"
			if (currentState[2] == 1)
				currentState[2] = 0;

			// Transitions in "room5"
			if (currentState[6] == 0)
				currentState[6] = 1;
			break;
		case 6: // Event "c7"

			// Transitions in "cat"
			if (currentState[0] == 1)
				currentState[0] = 3;

			// Transitions in "room2"
			if (currentState[3] == 0)
				currentState[3] = 1;

			// Transitions in "room4"
			if (currentState[5] == 1)
				currentState[5] = 0;
			break;
		case 7: // Event "c8"

			// Transitions in "cat"
			if (currentState[0] == 3)
				currentState[0] = 1;

			// Transitions in "room2"
			if (currentState[3] == 1)
				currentState[3] = 0;

			// Transitions in "room4"
			if (currentState[5] == 0)
				currentState[5] = 1;
			break;
		case 8: // Event "m1"

			// Transitions in "mouse"
			if (currentState[1] == 0)
				currentState[1] = 2;

			// Transitions in "room1"
			if (currentState[2] == 2)
				currentState[2] = 1;

			// Transitions in "room3"
			if (currentState[4] == 1)
				currentState[4] = 2;
			break;
		case 9: // Event "m2"

			// Transitions in "mouse"
			if (currentState[1] == 2)
				currentState[1] = 1;

			// Transitions in "room2"
			if (currentState[3] == 1)
				currentState[3] = 2;

			// Transitions in "room3"
			if (currentState[4] == 2)
				currentState[4] = 1;
			break;
		case 10: // Event "m3"

			// Transitions in "mouse"
			if (currentState[1] == 1)
				currentState[1] = 0;

			// Transitions in "room1"
			if (currentState[2] == 1)
				currentState[2] = 2;

			// Transitions in "room2"
			if (currentState[3] == 2)
				currentState[3] = 1;
			break;
		case 11: // Event "m4"

			// Transitions in "mouse"
			if (currentState[1] == 0)
				currentState[1] = 4;

			// Transitions in "room1"
			if (currentState[2] == 2)
				currentState[2] = 1;

			// Transitions in "room5"
			if (currentState[6] == 1)
				currentState[6] = 2;
			break;
		case 12: // Event "m5"

			// Transitions in "mouse"
			if (currentState[1] == 4)
				currentState[1] = 3;

			// Transitions in "room4"
			if (currentState[5] == 1)
				currentState[5] = 2;

			// Transitions in "room5"
			if (currentState[6] == 2)
				currentState[6] = 1;
			break;
		case 13: // Event "m6"

			// Transitions in "mouse"
			if (currentState[1] == 3)
				currentState[1] = 0;

			// Transitions in "room1"
			if (currentState[2] == 1)
				currentState[2] = 2;

			// Transitions in "room4"
			if (currentState[5] == 2)
				currentState[5] = 1;
			break;
		default:
			// Should never get here
		}
	}

	/**
	 * Sets output variables according to the executed event
	 * @param eventIndex The executed event
	 */
	void updateOutputVariables(int eventIndex) {
		/*
		 * No output variables are changed by default.
		 * Example:
		 * case 3: // Event "startMachine"
		 *   outputVariables[7] = true;
		 *   break;
		 */
		switch (eventIndex) {
		default: // Do nothing
			break;
		}
	}

	/**
	 * Start timers.
	 * @param eventIndex The executed event
	 */
	void startTimers(int eventIndex) {
		/*
		 * No timers are started by default.
		 * Example:
		 * case 9: // Event "mytimer_start"
		 *   timers[2].start();  // Timer "mytimer"
		 *   break;
		 */
		switch (eventIndex) {
		default: // Do nothing
			break;
		}
	}

	/**
	 * Executes the program.
	 */
	void execute() {
		// The index of the event that is selected to be executed
		int eventToBeExecuted = NO_EVENT_IS_SELECTED;

		long timeOfLastScan = System.currentTimeMillis();
		long timeToSleep;

		// Main scancycle
		while (true) {
			try {
				eventToBeExecuted = NO_EVENT_IS_SELECTED;

				// Read the input signal values into the input variables
				digitalIODriver.getSignalArray(inputVariables);

				/*
				 * Select the first event that is enabled.
				 * Search in the order that is given by the
				 * priority queue. Uncontrollable events
				 * lies first in the queue and are thus
				 * selected first. For an event to be
				 * enabled, it has to be enabled in the
				 * current internal state as well as 
				 * by external input signals.
				 */
				for (int i = 0; i < NR_OF_EVENTS && eventToBeExecuted == NO_EVENT_IS_SELECTED; ++i)
					if (eventIsEnabledInCurrentState(EVENT_PRIORITY_QUEUE[i])
							&& eventIsEnabledByInputVariables(EVENT_PRIORITY_QUEUE[i])
							&& eventIsEnabledByTimers(EVENT_PRIORITY_QUEUE[i]))
						eventToBeExecuted = EVENT_PRIORITY_QUEUE[i];

				// Update the output variables
				updateOutputVariables(eventToBeExecuted);

				// Start the timers that are triggered by this event
				startTimers(eventToBeExecuted);

				// Update state
				updateCurrentState(eventToBeExecuted);

				// Write the output variables
				digitalIODriver.setSignalArray(outputVariables);

				// For debugging
				//if (eventToBeExecuted != NO_EVENT_IS_SELECTED)
				//	System.out.println(EVENT_LABELS[eventToBeExecuted]);
			} catch (Exception e) {
				e.printStackTrace();
			}

			/*
			 * For a constant scan cycle time, set
			 * PREFERRED_SCAN_CYCLE_TIME to a value larger than
			 * the real scan cycle time. 
			 */
			timeToSleep = PREFERRED_SCAN_CYCLE_TIME - (System.currentTimeMillis() - timeOfLastScan); 
			if (timeToSleep > 0) {
				try {
					Thread.sleep(timeToSleep);
				} catch(InterruptedException e){}
			}
			timeOfLastScan = System.currentTimeMillis();
		}
	}

	public static void main(String[] args) {
		CatAndMouse instance = new CatAndMouse();
		instance.execute();
	}
}
