// CUP specification for ST expressions

package org.supremica.functionblocks.model.interpreters.st;

import java_cup.runtime.*;
import java.lang.*;

/* Terminals (tokens returned by the scanner). */
terminal            OR,XOR,AND;
terminal	    EQ,NEQ;
terminal            LESS,LESSEQ,MORE,MOREEQ;
terminal            PLUS,MINUS;
terminal	    TIMES,DIV,MOD;
terminal	    POWER;
terminal	    UMINUS;  	
terminal            NOT; 
terminal            LPAREN, RPAREN;
terminal String	    STRING;
terminal Integer    INT;
terminal Float      FLOAT;
terminal Boolean    BOOL;
terminal String     IDENT;

/* Non terminals */
non terminal Expression		expression;
non terminal OrExpression	or_expression;
non terminal XorExpression	xor_expression;
non terminal AndExpression	and_expression;
non terminal Comparison		comparison;
non terminal AddExpression	add_expression;
non terminal Term		term;
non terminal PowerExpression	power_expression;
non terminal UnaryExpression	unary_expression;
non terminal PrimaryExpression	primary_expression;

/* Precedences */
precedence left  OR;
precedence left  XOR;
precedence left  AND;
precedence left  NOT;
precedence nonassoc EQ,NEQ,LESS,LESSEQ,MORE,MOREEQ;
precedence left  PLUS,  MINUS;
precedence left  TIMES, DIV, MOD;
precedence left  POWER;
precedence left  UMINUS;


/* The grammar */

start with expression;

expression ::= or_expression:a			 		{: RESULT = new Expression(a); :};

or_expression ::= or_expression:a OR or_expression:b 		{: RESULT = new BinaryOrExpression(a,b); :}
                | xor_expression:a 		 		{: RESULT = new UnaryOrExpression(a); :};

xor_expression ::= xor_expression:a XOR xor_expression:b	{: RESULT = new BinaryXorExpression(a,b); :}
                 | and_expression:a 				{: RESULT = new UnaryXorExpression(a); :};

and_expression ::= and_expression:a AND and_expression:b	{: RESULT = new BinaryAndExpression(a,b); :}
                 | comparison:a 				{: RESULT = new UnaryAndExpression(a); :};

comparison ::= add_expression:a EQ     add_expression:b		{: RESULT = new Eq(a,b); :}
	     | add_expression:a NEQ    add_expression:b		{: RESULT = new Neq(a,b); :}
	     | add_expression:a LESS   add_expression:b 	{: RESULT = new Less(a,b); :}
	     | add_expression:a LESSEQ add_expression:b 	{: RESULT = new LessEq(a,b); :}
	     | add_expression:a MORE   add_expression:b 	{: RESULT = new More(a,b); :}
	     | add_expression:a MOREEQ add_expression:b 	{: RESULT = new MoreEq(a,b); :}
	     | add_expression:a					{: RESULT = new UnaryComparison(a); :};

add_expression ::= add_expression:a PLUS  add_expression:b	{: RESULT = new Plus(a,b); :}
 		 | add_expression:a MINUS add_expression:b	{: RESULT = new Minus(a,b); :}
 		 | term:a					{: RESULT = new UnaryAddExpression(a); :};

term ::= term:a TIMES term:b 					{: RESULT = new Times(a,b); :}
       | term:a DIV   term:b 					{: RESULT = new Div(a,b); :}
       | term:a MOD   term:b 					{: RESULT = new Mod(a,b); :}
       | power_expression:a					{: RESULT = new UnaryTerm(a); :};

power_expression ::= power_expression:a POWER power_expression:b {: RESULT = new BinaryPowerExpression(a,b); :}
		   | unary_expression:a				{: RESULT = new  UnaryPowerExpression(a); :};

unary_expression ::= LPAREN expression:a RPAREN			{: RESULT = new UnaryExpressionExpression(a); :}
		   | MINUS unary_expression:a			{: RESULT = new UnaryMinus(a); :} %prec UMINUS
		   | NOT   unary_expression:a			{: RESULT = new UnaryNot(a); :} %prec NOT
		   | primary_expression:a			{: RESULT = new UnaryPrimaryExpression(a); :};

primary_expression ::= IDENT:a					{: RESULT = new PrimaryIdent(a); :}
		     | STRING:a 				{: RESULT = new PrimaryString(a); :}
		     | INT:a					{: RESULT = new PrimaryInt(a); :}
	  	     | FLOAT:a 					{: RESULT = new PrimaryFloat(a); :}
	  	     | BOOL:a					{: RESULT = new PrimaryBool(a); :};
