package org.supremica.automata.algorithms;

import org.supremica.util.BDD.*;

import java.util.*;
import java.io.*;
import javax.swing.JFileChooser;

/**
 * AutomataBDDSynthesizer, for synthesis with BDDs
 *
 */

public class AutomataBDDSynthesizer {
	private org.supremica.automata.Automata theAutomata;
    private BDDAutomata ba = null;
    private Supervisor sup = null;

	public AutomataBDDSynthesizer(org.supremica.automata.Automata theAutomata)
		throws Exception
	{
		this.theAutomata = theAutomata;

		try {
		    Builder bu = new Builder(theAutomata);
		    ba = bu.getBDDAutomata();
		    // sup = new Supervisor(ba, ba.getAutomataVector());
		    sup = SupervisorFactory.createSupervisor(ba, ba.getAutomataVector());
		} catch(Exception pass) {
		    cleanup();
		    throw pass;
		}

	}



	/**
	 * C++ style destructor.
	 * <b>This function MUST be called before creating any new AutomataBDDVerifier obejcts</b>
	 *
	 */
	public void cleanup() {
		if(sup != null) sup.cleanup();
		if(ba != null) ba.cleanup();
	}


	public void execute() {
		/*
		Vector all_bad = sup.getUnsafeTransitionList();

		for (Enumeration es = all_bad.elements(); es.hasMoreElements(); )
		{
			DisablingPoint ds = (DisablingPoint) es.nextElement();

			String eventName = ds.getEvent();

			IncompleteStateList isl = ds.getStateList();
			int width = isl.getWidth();
			String [] automatonNames = isl.getAutomatonNames();




			// ok, this is just a test:
			if(! ds.stateListEmpty() ) {
				System.out.println("Disabling condition for event " + eventName + ":");

				for (Enumeration ss = isl.getList().elements(); ss.hasMoreElements(); )
				{
					String names[] = (String []) ss.nextElement();

					System.out.print("      (");
					for(int i = 0; i <width; i++) {
						if(i > 0) System.out.print(" AND ");
						System.out.print(automatonNames[i] + ".state == " + names[i] + " ");
					}
					System.out.println(")");
				}
				System.out.println();
			}

		}
		*/


		PrintStream ps = null;
		JFileChooser chooser  = new JFileChooser();
		chooser.setDialogTitle("Please, choose a file to save the generated code...");
		int returnVal = chooser.showSaveDialog(null);
    	if(returnVal == JFileChooser.APPROVE_OPTION) {
			try {
				FileOutputStream fos = new FileOutputStream(chooser.getSelectedFile());
				ps = new PrintStream( fos);


				Vector all_bad = sup.getUnsafeTransitionTree();


				ps.println("(* This file is automatically generated from Supremica using *)");
				ps.println("(* the _exprimental_ BDD algorithms. The code is generated for *)");
				ps.println("(* educational purpose only and has not been optimized and does *)");
				ps.println("(* not include the parts controlled by the specification (generate *)");
				ps.println("(* these manually) and will NOT compile/work correctly without *)");
				ps.println("(* further modifications *)");
				ps.println();
				ps.println("PROGRAM AutomaticallyGeneratedAndNotWorkingProgram");
				// ps.println("VAR (* Internal variables *)");
				for (Enumeration es = all_bad.elements(); es.hasMoreElements(); )
				{
					DisablingPoint ds = (DisablingPoint) es.nextElement();

					String eventName = ds.getEvent();

					ps.println();

					IncompleteStateTree ist = ds.getStateTree();
					// ok, this is just a test:
					if(! ds.stateTreeEmpty() ) {

						IncompleteStateTree.StateTreeNode curr = ist.getRoot();


						ps.println();
						ps.println("\t(* Disabling condition for event " + eventName + " *)");
						ps.print("\tDisabledEvent_" + eventName + " := ");
						if(curr.empty())
							ps.print("FALSE");
						else
							extract_tree_rec(curr,ps,true );

						ps.println(";\n");


					}
				}

				ps.println("\nEND_PROGRAM\n");

				fos.close();
			} catch(FileNotFoundException exx) {
				exx.printStackTrace();
			} catch(IOException exx2) {
				exx2.printStackTrace();
			}
		}

	}

	private void extract_tree_rec(IncompleteStateTree.StateTreeNode nod, PrintStream ps, boolean f)
	{
		if(nod.empty()) return;

 		Vector children = nod.getChildren();
 		String name = nod.getAutomaton();


		if(!f) ps.print(" AND ");

		if(children.size() > 1) ps.print(" (");

		boolean first = true;
		for (Enumeration s = children.elements(); s.hasMoreElements(); )
		{
			if(!first)
				ps.print(" OR ");
			else
				first = false;

			IncompleteStateTree.StateTreeNode next = (IncompleteStateTree.StateTreeNode) s.nextElement();
			ps.print(name + ".state = " + next.getState() );
			extract_tree_rec(next, ps, false);
		}
		if(children.size() > 1) ps.print(") ");
	}
}