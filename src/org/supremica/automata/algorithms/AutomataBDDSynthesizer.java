package org.supremica.automata.algorithms;

import org.supremica.util.BDD.*;
import java.util.*;
import java.io.*;
import javax.swing.JFileChooser;

/**
 * AutomataBDDSynthesizer, for synthesis with BDDs.
 *
 * 1. the execute() part was a proof-of-concept thingy, and IT SHOULD NOT BE USED ANYMORE!!
 * 2. use the interface to OnlineBDDSupervisor [i.e. extractOnlineSupervisor() ] for realtime execution instead :)
 *
 */
public class AutomataBDDSynthesizer
{
	private org.supremica.automata.Automata theAutomata;
	private BDDAutomata ba = null;
	private Supervisor sup = null;
	private boolean type_nb, type_c;

	public AutomataBDDSynthesizer(org.supremica.automata.Automata theAutomata, boolean supNB, boolean supC)
		throws Exception
	{
		this.theAutomata = theAutomata;
		this.type_c = supC;
		this.type_nb = supNB;
                
		try
		{
			Builder bu = new Builder(theAutomata);

			ba = bu.getBDDAutomata();

			//sup = new Supervisor(ba, ba.getAutomataVector());
			sup = SupervisorFactory.createSupervisor(ba, ba.getAutomataVector());
		}
		catch (Exception pass)
		{
			cleanup();

			throw pass;
		}
	}

	/**
	 * C++ style destructor.
	 * <b>This function MUST be called before creating any new AutomataBDDVerifier obejcts</b>
	 *
	 */
	public void cleanup()
	{
		if (sup != null)
		{
			sup.cleanup();
		}

		if (ba != null)
		{
			ba.cleanup();
		}
	}
                
        public int UCStates()
        {
            return sup.getUncontrollableStates();
        }
        
        public int coReachStates()
        {
            return sup.getCoReachables();
        }
        
        public int reachStates()
        {
            return sup.getReachables();
        }
        
        public int deadStates()
        {
            return sup.getDeadlocks();
        }
        
        public BDDAutomata getBDDAutomata()
        {
            return ba;
        }
        
	/**
	 * compute the safe states for the given options
	 *
	 */
	public int compute()
	{
            return sup.getSafeStates(type_nb, type_c);
	}

	/**
	 * Create a OnlineBDDSupervisor for the supervisor generated by this object
	 *
	 * NOTE: returns null on failure
	 *
	 * NOTE: cleansups and releases the ba and sup objects [_even_ if it fails!]
	 *
	 */
	public OnlineBDDSupervisor extractOnlineSupervisor()
	{
		OnlineBDDSupervisor ret = null;

		try
		{
			ret = new OnlineBDDSupervisor(ba, compute());
		}
		catch (Exception exx)
		{
			exx.printStackTrace();
		}

		// we dont own these objects anymore
		sup.cleanup();

		sup = null;
		ba = null;

		return ret;
	}

	/**
	 * Create an IEC-xxxx file that refelects the enabling-list of the supervisor
	 *
	 */
	public void generateCode()
	{
		PrintStream ps = null;
		JFileChooser chooser = new JFileChooser();

		chooser.setDialogTitle("Please, choose a file to save the generated code...");

		int returnVal = chooser.showSaveDialog(null);

		if (returnVal == JFileChooser.APPROVE_OPTION)
		{
			try
			{
				FileOutputStream fos = new FileOutputStream(chooser.getSelectedFile());

				ps = new PrintStream(fos);

				int safe = compute();
				Vector all_bad = sup.getUnsafeTransitionTree(safe);

				ba.deref(safe);
				ps.println("(* This file is automatically generated from Supremica using *)");
				ps.println("(* the _exprimental_ BDD algorithms. The code is generated for *)");
				ps.println("(* educational purpose only and has not been optimized and does *)");
				ps.println("(* not include the parts controlled by the specification (generate *)");
				ps.println("(* these manually) and will NOT compile/work correctly without *)");
				ps.println("(* further modifications *)");
				ps.println();
				ps.println("PROGRAM AutomaticallyGeneratedAndNotWorkingProgram");

				// ps.println("VAR (* Internal variables *)");
				for (Enumeration es = all_bad.elements();
						es.hasMoreElements(); )
				{
					DisablingPoint ds = (DisablingPoint) es.nextElement();
					String eventName = ds.getEvent();

					ps.println();

					IncompleteStateTree ist = ds.getStateTree();

					// ok, this is just a test:
					if (!ds.stateTreeEmpty())
					{
						IncompleteStateTree.StateTreeNode curr = ist.getRoot();

						ps.println();
						ps.println("\t(* Disabling condition for event " + eventName + " *)");
						ps.print("\tDisabledEvent_" + eventName + " := ");

						if (curr.empty())
						{
							ps.print("FALSE");
						}
						else
						{
							extract_tree_rec(curr, ps, true);
						}

						ps.println(";\n");
					}
				}

				ps.println("\nEND_PROGRAM\n");
				fos.close();
			}
			catch (FileNotFoundException exx)
			{
				exx.printStackTrace();
			}
			catch (IOException exx2)
			{
				exx2.printStackTrace();
			}
		}
	}

	private void extract_tree_rec(IncompleteStateTree.StateTreeNode nod, PrintStream ps, boolean f)
	{
		if (nod.empty())
		{
			return;
		}

		Vector children = nod.getChildren();
		String name = nod.getAutomaton();

		if (!f)
		{
			ps.print(" AND ");
		}

		if (children.size() > 1)
		{
			ps.print(" (");
		}

		boolean first = true;

		for (Enumeration s = children.elements(); s.hasMoreElements(); )
		{
			if (!first)
			{
				ps.print(" OR ");
			}
			else
			{
				first = false;
			}

			IncompleteStateTree.StateTreeNode next = (IncompleteStateTree.StateTreeNode) s.nextElement();

			ps.print(name + ".state = " + next.getState());
			extract_tree_rec(next, ps, false);
		}

		if (children.size() > 1)
		{
			ps.print(") ");
		}
	}
}
