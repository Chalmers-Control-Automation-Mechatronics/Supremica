
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Haradsgatan 26A
 * 431 42 Molndal
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.algorithms;

import org.supremica.gui.*;
import org.supremica.log.*;
import org.supremica.automata.*;
import java.io.*;
import java.util.*;
import java.text.DateFormat;

public class AutomataToIEC1131
	//implements AutomataSerializer
{
	private static Logger logger = LoggerFactory.createLogger(AutomataToIEC1131.class);
	private Automata theAutomata;
	private SynchronizationOptions syncOptions;
	private AutomataSynchronizerHelper syncHelper;
	private SynchronizationType syncType;
	private Alphabet allEvents;

	public AutomataToIEC1131(Automata theAutomata, SynchronizationOptions syncOptions)
		throws Exception
	{
		this.theAutomata = theAutomata;
		this.syncOptions = syncOptions;
		this.syncType = syncOptions.getSynchronizationType();
	}

	private void initialize()
		throws Exception
	{
		syncHelper = new AutomataSynchronizerHelper(theAutomata, syncOptions);
		allEvents = syncHelper.getUnionAlphabet();
	}


	void printBeginProgram(PrintWriter pw)
	{
		pw.println("(* This file is automatically generated from Supremica *)");
		pw.println("(* Supremica version: " + org.supremica.Version.version() + " *)");
		pw.println("(* This file was generated at: " +  DateFormat.getDateTimeInstance().format(new Date()) + " *)");
		pw.println("(* Synchronization type: " + syncType.toString() + "*)");
		pw.println("(* The following automata are synchronized: *)");
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
		{
			Automaton currAutomaton = (Automaton)autIt.next();
			pw.println("(* Automaton: " + currAutomaton.getName() + " *)");
		}
		pw.println("PROGRAM " + "AutomaticallyGeneratedProgram");
	}

	void printEndProgram(PrintWriter pw)
	{
		pw.println("END_PROGRAM");
	}

	void printVariables(PrintWriter pw)
	{
		pw.println("\tVAR (* Internal variables *)");
		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			while (alphIt.hasNext())
			{
				LabeledEvent currEvent = (LabeledEvent)alphIt.next();
				int currEventIndex = currEvent.getSynchIndex();
				pw.println("\t\te_" + currEventIndex + " : BOOL; (* " + currEvent.getLabel() + (currEvent.isControllable() ? " controllable" : " uncontrollable") + " *)");
			}
		}
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
		{
			Automaton currAutomaton = (Automaton)autIt.next();

			int currAutomatonIndex = currAutomaton.getSynchIndex();
			for (Iterator stateIt = currAutomaton.stateIterator(); stateIt.hasNext(); )
			{
				State currState = (State)stateIt.next();
				int currStateIndex = currState.getSynchIndex();
				pw.println("\t\tq_" + currAutomatonIndex + "_" + currStateIndex + " : BOOL; (* " + currState.getName() + " in " + currAutomaton.getName() + " *)");
			}
		}
		pw.println("\t\tinitialized : BOOL; (* Set the inital state the first scan cycle *)");
		pw.println("\tEND_VAR");
	}


	/**
	 * Set the initial state the first time the code is executed.
	 *
	 * In Structured Text:
	 *
	 * IF (NOT initialized)
	 * THEN
	 *		q_1_0 := TRUE;
	 *		q_2_0 := TRUE;
	 *		initialized := TRUE;
	 * END_IF;
	 *
	 * In Instruction List
	 *
	 * 			LD initialized
	 *			JMPC after_initialization
	 *			LD TRUE
	 *			S q_1_0
	 *			S q_2_0
	 *			S initialized;
	 *
	 * after_initialization:
	 */
	void printInitializationStructureAsST(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t(* Set the initial state *)");
		pw.println("\tIF (NOT initialized)");
		pw.println("\tTHEN");
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
		{
			Automaton currAutomaton = (Automaton)autIt.next();
			int currAutomatonIndex = currAutomaton.getSynchIndex();

			State initialState = currAutomaton.getInitialState();
			if (initialState == null)
			{
				throw new Exception("AutomataTOIEC1131.printInitializationStructure: " + "all automata must have an initial state");
			}
			int currStateIndex = initialState.getSynchIndex();
			pw.println("\t\tq_" + currAutomatonIndex + "_" + currStateIndex + " := TRUE;");
		}
		pw.println("\t\tinitialized := TRUE;");
		pw.println("\tEND_IF;");
	}

	/**
	 * Set the initial state the first time the code is executed.
	 *
	 * In Structured Text:
	 *
	 * if (NOT initialized)
	 * {
	 *		q_1_0 := TRUE;
	 *		q_2_0 := TRUE;
	 *		initialized := TRUE;
	 * }
	 *
	 * In Instruction List
	 *
	 * 			LD initialized
	 *			JMPC after_initialization
	 *			LD TRUE
	 *			S q_1_0
	 *			S q_2_0
	 *			S initialized;
	 *
	 * after_initialization:
	 */
	void printInitializationStructureAsIL(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t(* Set the initial state *)");
		pw.println("\tLD initialized");
		pw.println("\tJMPC after_initialization");
		pw.println("\tLD TRUE");
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
		{
			Automaton currAutomaton = (Automaton)autIt.next();
			int currAutomatonIndex = currAutomaton.getSynchIndex();

			State initialState = currAutomaton.getInitialState();
			if (initialState == null)
			{
				throw new Exception("AutomataTOIEC1131.printInitializationStructure: " + "all automata must have an initial state");
			}
			int currStateIndex = initialState.getSynchIndex();
			pw.println("\tS q_" + currAutomatonIndex + "_" + currStateIndex);
		}
		pw.println("\tS initialized");
		pw.println("after_initialization:");
	}

	/**
	 * Compute which events that are enabled
	 *
	 * The logic will be something like the following
	 *
	 * e_0 = (q_1_0 || q_1_1) && (q_2_3)
	 * e_1 = (q_1_2) && (q_2_1 || q_2_3)
	 *
	 * In Structured Text this will look like:
	 *
	 * e_0 := (q_1_0 OR q_1_1) AND (q_2_3);
	 * e_1 := (q_1_2) AND (q_2_1 OR q_2_3);
	 *
	 * In Instruction List this will look like:
	 *
	 * LD q_1_0
	 * OR q_1_1
	 * AND q_2_3
	 * ST e_0
	 * LD q_1_2
	 * AND( q_2_1
	 * OR q_2_3
	 * )
	 * ST e_1
	 */
	void printComputeEnabledEventsAsST(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t(* Compute the enabled events *)");
		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			while (alphIt.hasNext())
			{
				LabeledEvent currEvent = (LabeledEvent)alphIt.next();
				int currEventIndex = currEvent.getSynchIndex();
				pw.println("\n\t(* Enable condition for event \"" + currEvent.getLabel() + "\" *)");
				boolean previousCondition = false;
				pw.print("\te_" + currEventIndex + " := ");
				for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
				{
					Automaton currAutomaton = (Automaton)autIt.next();

					int currAutomatonIndex = currAutomaton.getSynchIndex();

					if (syncType == SynchronizationType.Prioritized)
					{ // All automata that has this event as prioritized must be able to execute it
						if (currAutomaton.isEventPrioritized(currEvent.getLabel()))
						{ // Find all states that enables this event
						  // Use OR between states in the same automaton.
						  // Use AND between states in different automata.
							if (previousCondition)
							{
								pw.print(" AND ");
							}
							else
							{
								previousCondition = true;
							}

							boolean previousState = false;
							pw.print("(");
							for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel()); stateIt.hasNext();)
							{
								State currState = (State)stateIt.next();
								int currStateIndex = currState.getSynchIndex();
								if (previousState)
								{
									pw.print(" OR ");
								}
								else
								{
									previousState = true;
								}
								pw.print("q_" + currAutomatonIndex + "_" + currStateIndex);

							}
							if (!previousState)
							{
								pw.print(" FALSE ");
							}
							pw.print(")");
						}
					}
					else
					{
						throw new Exception("Unsupported SynchronizationType");
					}
				}
				pw.println(";");
			}
		}
	}

	/**
	 * Compute which events that are enabled
	 *
	 * The logic will be something like the following
	 *
	 * e_0 = (q_1_0 || q_1_1) && (q_2_3)
	 * e_1 = (q_1_2) && (q_2_1 || q_2_3)
	 *
	 * In Structured Text this will look like:
	 *
	 * e_0 := (q_1_0 OR q_1_1) AND (q_2_3);
	 * e_1 := (q_1_2) AND (q_2_1 OR q_2_3);
	 *
	 * In Instruction List this will look like:
	 *
	 * LD q_1_0
	 * OR q_1_1
	 * AND q_2_3
	 * ST e_0
	 * LD q_1_2
	 * AND( q_2_1
	 * OR q_2_3
	 * )
	 * ST e_1
	 */
	void printComputeEnabledEventsAsIL(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t(* Compute the enabled events *)");
		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			while (alphIt.hasNext())
			{
				LabeledEvent currEvent = (LabeledEvent)alphIt.next();
				int currEventIndex = currEvent.getSynchIndex();
				pw.println("\n\t(* Enable condition for event \"" + currEvent.getLabel() + "\" *)");
				boolean previousCondition = false;
				for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
				{
					Automaton currAutomaton = (Automaton)autIt.next();

					int currAutomatonIndex = currAutomaton.getSynchIndex();

					if (syncType == SynchronizationType.Prioritized)
					{ // All automata that has this event as prioritized must be able to execute it
						if (currAutomaton.isEventPrioritized(currEvent.getLabel()))
						{ // Find all states that enables this event
						  // Use OR between states in the same automaton.
						  // Use AND between states in different automata.
							if (previousCondition)
							{
								pw.print("\tAND( ");
							}
							else
							{
								pw.print("\tLD ");
							}

							boolean previousState = false;
							for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel()); stateIt.hasNext();)
							{
								State currState = (State)stateIt.next();
								int currStateIndex = currState.getSynchIndex();
								if (previousState)
								{
									pw.print("\tOR ");
								}
								else
								{
									previousState = true;
								}
								pw.println("q_" + currAutomatonIndex + "_" + currStateIndex);

							}
							if (!previousState)
							{
								pw.print(" FALSE ");
							}
							if (previousCondition)
							{
								pw.println("\t)");
							}
							else
							{
								previousCondition = true;
							}
						}
					}
					else
					{
						throw new Exception("Unsupported SynchronizationType");
					}
				}
				pw.println("\tST e_" + currEventIndex);
			}
		}
	}

	/**
	 * If self loop then do not do anything, else update state
	 *
	 * The logic will be something like the following
	 * if (e_0)
	 * {
	 * 		(* Automaton 1 *)
	 * 		if (q_1_0)
	 * 		{
	 *			q_1_1 = true;
	 *			q_1_0 = false;
	 * 		}
	 * 		else if (q_1_2)
	 * 		{
	 *			q_1_0 = true;
	 *			q_1_2 = false;
	 * 		}
	 *
	 *		(* Automaton 2 *)
	 *
	 * }
	 * if (e_1)
	 * {
	 * 		(* Automaton 1 *)
	 * 		if (q_1_0)
	 * 		{
	 *			q_1_2 = true;
	 *			q_1_0 = false;
	 * 		}
	 *
	 * 		(* Automaton 2 *)
	 * 		if (q_2_0)
	 * 		{
	 *			q_2_2 = true;
	 *			q_2_0 = false;
	 * 		}
	 * }
	 *
	 * In Structured Text this will look like:
	 *
	 *
	 * IF (e_0)
	 * THEN
	 * 		IF (q_1_0)
	 * 		THEN
	 *			q_1_1 := TRUE;
	 *			q_1_0 := FALSE;
	 * 		ELSIF (q_1_2)
	 *		THEN
	 *			q_1_0 := TRUE;
	 *			q_1_2 := FALSE;
	 * 		END_IF;
	 * END_IF;
	 * IF (e_1)
	 * THEN
	 * 		...
	 * END_IF;
	 *
	 * In Instruction List this will look like:
	 *
	 * e_0:			LD e_0
	 *				JMPCN e_1
	 * e_0_q_1_0:	LD q_1_0
	 *				JMPCN q_1_2_e_1_0
	 *				S q_1_1 (* Note that the result register is true here *)
	 *				R q_1_2
	 *				JMP e_1
	 * e_1_q_1_2:	LD q_1_2
	 *				JMPCN end_of_e_0
	 *				S q_1_0
	 *				R q_1_2
	 *				JMP e_1
	 * e_1:			LD e_1
	 * end_of_jumps:
	 */


	void printChangeStateTransitionsAsST(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t(* Change state in the automata *)");
		pw.println("\t(* It is in general not safe to have more than one event set to true at this point *)");
		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			while (alphIt.hasNext())
			{
				LabeledEvent currEvent = (LabeledEvent)alphIt.next();
				int currEventIndex = currEvent.getSynchIndex();
				pw.println("\n\t(* Transition for event \"" + currEvent.getLabel() + "\" *)");
				boolean previousCondition = false;
				pw.println("\tIF (e_" + currEventIndex + ")");
				pw.println("\tTHEN");
				for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
				{
					Automaton currAutomaton = (Automaton)autIt.next();
					int currAutomatonIndex = currAutomaton.getSynchIndex();

					if (currAutomaton.hasEventInAlphabet(currEvent.getLabel()))
					{
						LabeledEvent currAutomatonEvent = currAutomaton.getEventWithLabel(currEvent.getLabel());
						if (currAutomatonEvent == null)
						{
							throw new Exception("AutomataToIEC1131.printChangeTransitionsAsST: " + "Could not find " + currEvent.getLabel() + " in automaton " + currAutomaton.getName());
						}

						pw.println("\n\t\t(* Transitions in " + currAutomaton.getName() + " *)");
						boolean previousState = false;
						for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel()); stateIt.hasNext();)
						{
							State currState = (State)stateIt.next();
							int currStateIndex = currState.getSynchIndex();

							State toState = currState.nextState(currAutomatonEvent);
							if (toState == null)
							{
								throw new Exception("AutomataToIEC1131.printChangeTransitionsAsST: " + "Could not find the next state from state " + currState.getName() + " with label " + currEvent.getLabel() + " in automaton " + currAutomaton.getName());
							}
							int toStateIndex = toState.getSynchIndex();
							if (currState != toState)
							{
								if (!previousState)
								{
									pw.print("\t\tIF");
									previousState = true;
								}
								else
								{
									pw.print("\t\tELSIF");
								}
								pw.println(" (q_" + currAutomatonIndex + "_" + currStateIndex + ")");
								pw.println("\t\tTHEN");
								pw.println("\t\t\tq_" + currAutomatonIndex + "_" + toStateIndex + " := TRUE;");
								pw.println("\t\t\tq_" + currAutomatonIndex + "_" + currStateIndex + " := FALSE;");
							}
							else
							{
								pw.println("\t\t(* q_" + currAutomatonIndex + "_" + currStateIndex + "  has e_" + currEventIndex + " as self loop, no transition *)");
							}
						}
						if (previousState)
						{
							pw.println("\t\tEND_IF;");
						}
					}

				}
				pw.println("\tEND_IF;");
			}
		}
	}

	/**
	 * In Instruction List this will look like:
	 *
	 * 				LD e_0
	 *				JMPCN trans_after_e_1
	 * e_0_q_1_0:	LD q_1_0
	 *				JMPCN trans_after_e_1_q_1_0
	 *				S q_1_1 (* Note that the result register is true here *)
	 *				R q_1_2
	 *				JMP e_1
	 * e_1_q_1_2:	LD q_1_2
	 *				JMPCN end_of_e_0
	 *				S q_1_0
	 *				R q_1_2
	 *				JMP e_1
	 * trans_after_e_1:
	 * 				LD e_1
	 * end_of_jumps:
	 */
	void printChangeStateTransitionsAsIL(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t(* Change state in the automata *)");
		pw.println("\t(* It is in general not safe to have more than one event set to true at this point *)");
		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			while (alphIt.hasNext())
			{
				LabeledEvent currEvent = (LabeledEvent)alphIt.next();
				int currEventIndex = currEvent.getSynchIndex();
				pw.println("\n\t(* Transition for event \"" + currEvent.getLabel() + "\" *)");
				boolean previousCondition = false;
				pw.println("\tLD e_" + currEventIndex);
				pw.println("\tJMPCN trans_after_e_" + currEventIndex);
				for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
				{
					Automaton currAutomaton = (Automaton)autIt.next();
					int currAutomatonIndex = currAutomaton.getSynchIndex();

					if (currAutomaton.hasEventInAlphabet(currEvent.getLabel()))
					{
						LabeledEvent currAutomatonEvent = currAutomaton.getEventWithLabel(currEvent.getLabel());
						if (currAutomatonEvent == null)
						{
							throw new Exception("AutomataToIEC1131.printChangeTransitionsAsST: " + "Could not find " + currEvent.getLabel() + " in automaton " + currAutomaton.getName());
						}

						pw.println("\n\t(* Transitions in " + currAutomaton.getName() + " *)");
						boolean previousState = false;
						for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel()); stateIt.hasNext();)
						{
							State currState = (State)stateIt.next();
							int currStateIndex = currState.getSynchIndex();

							State toState = currState.nextState(currAutomatonEvent);
							if (toState == null)
							{
								throw new Exception("AutomataToIEC1131.printChangeTransitionsAsST: " + "Could not find the next state from state " + currState.getName() + " with label " + currEvent.getLabel() + " in automaton " + currAutomaton.getName());
							}
							int toStateIndex = toState.getSynchIndex();
							if (currState != toState)
							{
								pw.println("\tLD q_" + currAutomatonIndex + "_" + currStateIndex);
								pw.println("\tJMPCN trans_after_e_" + currEventIndex + "_q_"+ currAutomatonIndex + "_" + currStateIndex);
								pw.println("\tS q_" + currAutomatonIndex + "_" + toStateIndex);
								pw.println("\tR q_" + currAutomatonIndex + "_" + currStateIndex);
								pw.println("\tJMP trans_after_e_" + currEventIndex + "_a_" + currAutomatonIndex);
							}
							else
							{
								pw.println("\t(* q_" + currAutomatonIndex + "_" + currStateIndex + "  has e_" + currEventIndex + " as self loop, no transition *)");
							}
							pw.println("trans_after_e_" + currEventIndex + "_q_"+ currAutomatonIndex + "_" + currStateIndex + ":");
						}
						pw.println("trans_after_e_" + currEventIndex + "_a_" + currAutomatonIndex + ":");
					}

				}
				pw.println("trans_after_e_" + currEventIndex + ":");
			}
		}
	}

	public void serializeStructuredText(PrintWriter pw)
		throws Exception
	{
		initialize();
		printBeginProgram(pw);
		printVariables(pw);
		printInitializationStructureAsST(pw);
		printComputeEnabledEventsAsST(pw);
		printChangeStateTransitionsAsST(pw);
		printEndProgram(pw);
	}

	public void serializeInstructionList(PrintWriter pw)
		throws Exception
	{
		initialize();
		initialize();
		printBeginProgram(pw);
		printVariables(pw);
		printInitializationStructureAsIL(pw);
		printComputeEnabledEventsAsIL(pw);
		printChangeStateTransitionsAsIL(pw);
		printEndProgram(pw);
	}
}
