/* * Supremica Software License Agreement * * The Supremica software is not in the public domain * However, it is freely available without fee for education, * research, and non-profit purposes.  By obtaining copies of * this and other files that comprise the Supremica software, * you, the Licensee, agree to abide by the following * conditions and understandings with respect to the * copyrighted software: * * The software is copyrighted in the name of Supremica, * and ownership of the software remains with Supremica. * * Permission to use, copy, and modify this software and its * documentation for education, research, and non-profit * purposes is hereby granted to Licensee, provided that the * copyright notice, the original author's names and unit * identification, and this permission notice appear on all * such copies, and that no charge be made for such copies. * Any entity desiring permission to incorporate this software * into commercial products or to use it for commercial * purposes should contact: * * Knut Akesson (KA), knut@supremica.org * Supremica, * Knarrhogsgatan 10 * SE-431 60 MOLNDAL * SWEDEN * * to discuss license terms. No cost evaluation licenses are * available. * * Licensee may not use the name, logo, or any other symbol * of Supremica nor the names of any of its employees nor * any adaptation thereof in advertising or publicity * pertaining to the software without specific prior written * approval of the Supremica. * * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE. * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY. * * Supremica or KA shall not be liable for any damages * suffered by Licensee from the use of this software. * * Supremica is owned and represented by KA. */package org.supremica.automata.algorithms.minimization;import org.supremica.log.*;import org.supremica.automata.*;import org.supremica.automata.algorithms.*;import org.supremica.gui.*;import org.supremica.util.ActionTimer;import org.supremica.properties.SupremicaProperties;import java.util.*;public class AutomataMinimizer	implements Stoppable{	private static Logger logger = LoggerFactory.createLogger(AutomataMinimizer.class);	// Stoppable stuff	private ExecutionDialog executionDialog;	private Stoppable threadToStop = null;	private boolean stopRequested = false;	/** The automata being minimized (may be a copy of the original). */	private Automata theAutomata;	/** The supplied options. */	private MinimizationOptions options;	/** The strategy to use, in order of priority */	private LinkedList<MinimizationStrategy> strategyList;	/** The heuristic to use, in order of priority */	private LinkedList<MinimizationHeuristic> heuristicList;	////////////////	// Statistics //	////////////////	/** Largest number of states come across. */	private int mostStates = 0;	/** Largest number of transitions come across. */	private int mostTransitions = 0;	/** Number of automata in the beginning. */	private int instanceSize;	/** Event to automata map, for choosing the next task in compositional minimization. */	private EventToAutomataMap eventToAutomataMap;	/**	 * Basic constructor.	 */	public AutomataMinimizer(Automata theAutomata)	{		instanceSize = theAutomata.nbrOfAutomata();		this.theAutomata = theAutomata;	}	/**	 * Sets the executionDialog of this AutomataMinimizer. If executionDialog is null,	 * the dialog is not updated.	 */	public void setExecutionDialog(ExecutionDialog executionDialog)	{		this.executionDialog = executionDialog;	}	/**	 * Returns minimized automaton, minimized with respect to the supplied options.	 */	public Automaton getCompositionalMinimization(MinimizationOptions options)		throws Exception	{		this.options = options;				// Are the options valid?		if (!options.isValid())		{			return null;		}		// Initialize execution dialog		if (executionDialog != null)		{			executionDialog.initProgressBar(0, theAutomata.size()-1);		}		// Make priority list of the strategies (used in getNextMinimizationTask())		strategyList = new LinkedList<MinimizationStrategy>();		strategyList.add(MinimizationStrategy.FewestTransitionsFirst);		strategyList.add(MinimizationStrategy.FewestStatesFirst);		strategyList.add(MinimizationStrategy.FewestEventsFirst);		strategyList.add(MinimizationStrategy.RandomFirst);		// Make sure the chosen strategy is the first one we try!		strategyList.remove(options.getMinimizationStrategy());		strategyList.addFirst(options.getMinimizationStrategy());		// Make priority list of the heuristics (used in getNextMinimizationTask())		heuristicList = new LinkedList<MinimizationHeuristic>();		heuristicList.add(MinimizationHeuristic.MostLocal);		heuristicList.add(MinimizationHeuristic.LeastExtension);		heuristicList.add(MinimizationHeuristic.FewestStates);		heuristicList.add(MinimizationHeuristic.Random);		// Make sure the chosen heuristic is the first one we try!		heuristicList.remove(options.getMinimizationHeuristic());		heuristicList.addFirst(options.getMinimizationHeuristic());		// Initialize statistics count		AutomatonMinimizer.resetTotal();		// For each event, find the automata that has this event in its alphabet		eventToAutomataMap = AlphabetHelpers.buildEventToAutomataMap(theAutomata);		// Sizes in the beginning (may include epsilon?)		int globalAlphabetSize = eventToAutomataMap.size() - options.getTargetAlphabet().size(); 		// Current alphabet size...		int currentAlphabetSize = globalAlphabetSize;		// As long as there are at least two automata, compose and minimize!		while (theAutomata.size() >= 2)		{			// Get next automata to minimize			MinimizationTask task = getNextMinimizationTask();			Automata automata = task.getAutomata();			Alphabet hideThese = task.getEventsToHide();			if (stopRequested)			{				return null;			}			// Perform the minimization, unless of course this is the last step			// and it should be skipped...			Automaton min; 			if (options.getSkipLast() && (theAutomata.size() == automata.size()))			{				// Just synch and hide				min = AutomataSynchronizer.synchronizeAutomata(automata);				min.hide(hideThese);				// Examine for largest sizes				if (min.nbrOfStates() > mostStates)				{					mostStates = min.nbrOfStates();				}				if (min.nbrOfTransitions() > mostTransitions)				{					mostTransitions = min.nbrOfTransitions();				}			}			else			{				// Compose and minimize!				min = monolithicMinimization(automata, hideThese);			}			if (stopRequested)			{				return null;			}			// Adjust the eventToAutomataMap			// Remove the hidden events from the map			for (Iterator<LabeledEvent> it = hideThese.iterator(); it.hasNext(); )			{				eventToAutomataMap.remove(it.next());			}			// Remove the examined automata from the map			for (Iterator<LabeledEvent> it = automata.getUnionAlphabet().iterator(); it.hasNext(); )			{				Automata aut = eventToAutomataMap.get(it.next());				if (aut != null)				{					aut.removeAutomata(automata);				}			}			// And add the new automaton!			for (Iterator<LabeledEvent> it = min.getAlphabet().iterator(); it.hasNext(); )			{				eventToAutomataMap.insert(it.next(), min);			}			// Adjust the automata			theAutomata.removeAutomata(automata);			theAutomata.addAutomaton(min);			// Dispose of originals			automata.clear();			// Debug			logger.debug("---------------------------------------------------------------------");			logger.debug("Progress: " + (instanceSize-theAutomata.size())*100/(instanceSize-1) + "%");			// Update execution dialog			if (executionDialog != null)			{				executionDialog.setProgress(instanceSize-theAutomata.size());				currentAlphabetSize -= hideThese.size();				executionDialog.setSubheader("Events left: " + currentAlphabetSize +											 " (" + globalAlphabetSize + ")");			}		}		// Print statistics		if (SupremicaProperties.verboseMode())		{			// Print total reduction statistics			logger.info(AutomatonMinimizer.getStatistics());			// Print largest automaton size			logger.info("The automaton with the most states had " + mostStates + " states.");			logger.info("The automaton with the most transitions had " + mostTransitions + " transitions.");		}		//logger.info(theAutomata.getName() + " & " + instanceSize + " & & " + mostStates + " & " + mostTransitions + " & TIME & true/false & " + AutomatonMinimizer.getStatisticsLaTeX() + " & ALGO \\\\");		// Return the result of the minimization!		assert(theAutomata.size() == 1);		return theAutomata.getFirstAutomaton();	}	/**	 * Class holding info about what should be done in the next	 * minimization. Which automata should be composed and which	 * events can be hidden.	 */	private class MinimizationTask	{		private Automata automata;		private Alphabet eventsToHide;		public MinimizationTask(Automata automata, Alphabet eventsToHide)		{			this.automata = automata;			this.eventsToHide = eventsToHide;		}		public Automata getAutomata()		{			return automata;		}		public Alphabet getEventsToHide()		{			return eventsToHide;		}	}	/**	 * Returns the next Automata that is predicted to be the best one	 * to do minimization on next and the Alphabet of events that can	 * be hidden.	 */	private MinimizationTask getNextMinimizationTask()		throws Exception	{		Automata taskAutomata = null;		Alphabet hideThese = null;		// Target alphabet		Alphabet targetAlphabet = options.getTargetAlphabet();		// Try the heuristics in order of priority...		for (int strategyIndex = 0; strategyIndex < strategyList.size(); strategyIndex++)		{			////////////////			// FIRST STEP //			////////////////						// Begin with the first strategy!			MinimizationStrategy strategy = strategyList.get(strategyIndex);			// ... and the first heuristic			int heuristicIndex = 0;			MinimizationHeuristic heuristic = heuristicList.get(heuristicIndex);			// Try to find a nice task			if (strategy == MinimizationStrategy.AtLeastOneLocal)			{				// Look through the map and find the best set of automata				int bestValue = (heuristic.maximize() ? Integer.MIN_VALUE : Integer.MAX_VALUE);				for (Iterator<LabeledEvent> evIt = eventToAutomataMap.eventIterator(); evIt.hasNext(); )				{					LabeledEvent event = evIt.next();					// Skip the events in targetAlphabet and epsilon events!					if (targetAlphabet.contains(event) || event.isEpsilon())					{						continue;					}					if (stopRequested)					{						return null;					}															// Get the selection that have this event in their alphabet					Automata selection = eventToAutomataMap.get(event);										// If there is an automaton that by itself has					// local events, choose that one as the task!					// This can only happen in the beginning, of					// course...					if (selection.size() == 1)					{						taskAutomata = selection;						break;					}										/////////////////					// SECOND STEP //					/////////////////									// Evaluate					int thisValue = heuristic.value(selection, eventToAutomataMap, targetAlphabet);					// Maximize or minimize?					if ((heuristic.maximize() && thisValue > bestValue) ||						(heuristic.minimize() && thisValue < bestValue))					{						bestValue = thisValue;						taskAutomata = selection;					}					else if (bestValue == thisValue)					{						// As good as the best one?						// Use lower priority heuristic to make a decision!						boolean decisionMade = false;						for (int i = heuristicIndex+1; i<heuristicList.size() && !decisionMade; i++)						{							MinimizationHeuristic nextHeuristic = heuristicList.get(i);							int nextHeuristicBest = nextHeuristic.value(taskAutomata, eventToAutomataMap, 																	targetAlphabet);							int nextHeuristicThis = nextHeuristic.value(selection, eventToAutomataMap, 																	targetAlphabet);							if ((nextHeuristic.maximize() && nextHeuristicThis > nextHeuristicBest) ||								(nextHeuristic.minimize() && nextHeuristicThis < nextHeuristicBest))							{								taskAutomata = selection;								decisionMade = true;							}						}					}				}								// Couldn't find an appropriate result?				if (taskAutomata == null)				{					// Try next strategy					continue;				}			}			else if (strategy != MinimizationStrategy.Undefined)			{								// Choose the "best" automaton...				Automaton bestAutomaton = null;				int bestValue = (strategy.maximize() ? Integer.MIN_VALUE : Integer.MAX_VALUE);				// Search among all the automata for the "best"...				for (Iterator<Automaton> autIt = theAutomata.iterator(); autIt.hasNext(); )				{					Automaton aut = autIt.next();										// Evaluate using current strategy					int thisValue = strategy.value(aut);					// Maximize or minimize?					if ((strategy.maximize() && thisValue > bestValue) ||						(strategy.minimize() && thisValue < bestValue))					{						bestValue = thisValue;						bestAutomaton = aut;					}					else if (bestValue == thisValue)					{						// They were equal! Use lower priority strategy to make a decision!						boolean decisionMade = false;						for (int i = strategyIndex+1; i<strategyList.size() && !decisionMade; i++)						{							MinimizationStrategy nextStrategy = strategyList.get(i);							if (nextStrategy.isSpecial()) // Don't use special strategies here							{								continue;							}							int nextStrategyBest = nextStrategy.value(bestAutomaton);							int nextStrategyThis = nextStrategy.value(aut);							if ((nextStrategy.maximize() && nextStrategyThis > nextStrategyBest) ||								(nextStrategy.minimize() && nextStrategyThis < nextStrategyBest))							{								bestAutomaton = aut;								decisionMade = true;							}						}					}				}				// Got a result?				assert(bestAutomaton != null);									/////////////////				// SECOND STEP //				/////////////////															// Search among all automata				bestValue = (heuristic.maximize() ? Integer.MIN_VALUE : Integer.MAX_VALUE);				for (int j=0; j<theAutomata.size(); j++)				{					Automaton aut = theAutomata.getAutomatonAt(j);					// Skip self					if (bestAutomaton == aut)					{						continue;					}										// Now we have a candidate					Automata selection = new Automata();					selection.addAutomaton(bestAutomaton);					selection.addAutomaton(aut);										// Evaluate					int thisValue = heuristic.value(selection, eventToAutomataMap, targetAlphabet);					// Maximize or minimize?					if ((heuristic.maximize() && thisValue > bestValue) ||						(heuristic.minimize() && thisValue < bestValue))					{						bestValue = thisValue;						taskAutomata = selection;					}					else if (bestValue == thisValue)					{						// Use lower priority heuristic to make a decision!						boolean decisionMade = false;						for (int i = heuristicIndex+1; i<heuristicList.size() && !decisionMade; i++)						{							MinimizationHeuristic nextHeuristic = heuristicList.get(i);							int nextHeuristicBest = nextHeuristic.value(taskAutomata, eventToAutomataMap, 																	targetAlphabet);							int nextHeuristicThis = nextHeuristic.value(selection, eventToAutomataMap, 																	targetAlphabet);							if ((nextHeuristic.maximize() && nextHeuristicThis > nextHeuristicBest) ||								(nextHeuristic.minimize() && nextHeuristicThis < nextHeuristicBest))							{								taskAutomata = selection;								decisionMade = true;							}						}					}				}								/*				// Find the automaton with the highest "local to total" (number of events)				// ratio with respect to bestAutomaton				Alphabet alphaA = bestAutomaton.getAlphabet();				double bestLocalRatio = 0;				double bestCommonRatio = 0;				int bestSize = Integer.MAX_VALUE;				// Search among all automata				for (int j=0; j<theAutomata.size(); j++)				{					Automaton aut = theAutomata.getAutomatonAt(j);					Alphabet alpha = aut.getAlphabet();					// We have a new candidate!		 			Automata candidate = new Automata();					candidate.addAutomaton(bestAutomaton);					candidate.addAutomaton(aut);										// Skip self					if (bestAutomaton == aut)					{						continue;					}										// If there are no common events, try next automaton					int nbrOfCommonEvents = alphaA.nbrOfCommonEvents(alpha);					if (nbrOfCommonEvents == 0)					{						if ((bestLocalRatio == 0) && (bestCommonRatio == 0) &&							(aut.nbrOfStates() < bestSize))						{					        taskAutomata = candidate;							bestSize = aut.nbrOfStates();							hideThese = null;						}						continue;					}										// Calculate the alphabet of local events					Alphabet localEvents = MinimizationHelper.getLocalEvents(candidate, eventToAutomataMap);					localEvents.minus(targetAlphabet); // Ignore events from targetAlphabet!										// Find ratios					int nbrOfLocalEvents = localEvents.size();					int unionAlphabetSize = alphaA.size() + alpha.size() - nbrOfCommonEvents;					double thisLocalRatio = ((double) nbrOfLocalEvents)/((double) unionAlphabetSize);					double thisCommonRatio = ((double) nbrOfCommonEvents)/((double) unionAlphabetSize);										// Improvement?					if (thisLocalRatio > bestLocalRatio)					{					    taskAutomata = candidate;						bestLocalRatio = thisLocalRatio;						hideThese = localEvents;					}					else if ((bestLocalRatio == 0) && (thisCommonRatio > bestCommonRatio))					{					    taskAutomata = candidate;						bestCommonRatio = thisCommonRatio;						hideThese = null;					}				}								if (stopRequested)				{					return null;				}								// Generate result				if (hideThese == null)				{					hideThese = new Alphabet();				}								// Was the system disjoint?				if (!((bestLocalRatio > 0) || (bestCommonRatio > 0)))				{					logger.warn("The system has disjoint parts. Preferrably, they should " +								"be treated separately if possible.");				}				*/			}			else			{				logger.error("Error in AutomataMinimizer, unknown MinimizationStrategy.");				requestStop();				return null;			}						// Which events should be hidden?			hideThese = MinimizationHelper.getLocalEvents(taskAutomata, eventToAutomataMap);			hideThese.minus(targetAlphabet);			//logger.info(taskAutomata);			//logger.info(hideThese);			// Result found! Return!			return new MinimizationTask(taskAutomata, hideThese);		}				// This can't happen! The random strategy will always result in something!				logger.error("Error in AutomataMinimizer, no minimization task found.");		requestStop();		return null;	}	/** 	 * Composes automata and minimizes the result with hideThese considered as epsilon 	 * events.	 */	private Automaton monolithicMinimization(Automata automata, Alphabet hideThese)		throws Exception	{		// We don't really care about the state names, keep them short!		boolean useShortStateNames = true;		// Synchronize, or if there's just one automaton, just find it		Automaton aut;		if (automata.size() > 1)		{			// Synch			SynchronizationOptions synchOptions = SynchronizationOptions.getDefaultSynchronizationOptions();			synchOptions.setUseShortStateNames(useShortStateNames);			aut = AutomataSynchronizer.synchronizeAutomata(automata, synchOptions);		}		else		{			/*			if (useShortStateNames)			{				EnumerateStates en = new EnumerateStates(automata, "q");				en.execute();			}			*/			aut = automata.getFirstAutomaton();			// This is probably one of the originals, so we might need to make a copy!			if (options.getKeepOriginal())			{				aut = new Automaton(aut);			}		}		// Hide the events!		aut.hide(hideThese);		// Examine for largest sizes		if (aut.nbrOfStates() > mostStates)		{			mostStates = aut.nbrOfStates();		}		if (aut.nbrOfTransitions() > mostTransitions)		{			mostTransitions = aut.nbrOfTransitions();		}		// Is it at all possible to minimize? (It may actually be possible even		// if there are no epsilons)		//if (aut.nbrOfEpsilonTransitions() > 0)		{			AutomatonMinimizer minimizer = new AutomatonMinimizer(aut);			minimizer.useShortStateNames(useShortStateNames);			threadToStop = minimizer;			aut = minimizer.getMinimizedAutomaton(options);			threadToStop = null;			if (stopRequested)			{				return null;			}		}		return aut;	}	/**	 * Method that stops AutomataMinimizer as soon as possible.	 *	 * @see  ExecutionDialog	 */	public void requestStop()	{		stopRequested = true;		logger.debug("AutomataMinimizer requested to stop.");		// Stop current minimization thread!		if (threadToStop != null)		{			threadToStop.requestStop();		}	}}