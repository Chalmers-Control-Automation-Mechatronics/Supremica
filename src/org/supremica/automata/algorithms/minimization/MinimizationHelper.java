/* * Supremica Software License Agreement * * The Supremica software is not in the public domain * However, it is freely available without fee for education, * research, and non-profit purposes.  By obtaining copies of * this and other files that comprise the Supremica software, * you, the Licensee, agree to abide by the following * conditions and understandings with respect to the * copyrighted software: * * The software is copyrighted in the name of Supremica, * and ownership of the software remains with Supremica. * * Permission to use, copy, and modify this software and its * documentation for education, research, and non-profit * purposes is hereby granted to Licensee, provided that the * copyright notice, the original author's names and unit * identification, and this permission notice appear on all * such copies, and that no charge be made for such copies. * Any entity desiring permission to incorporate this software * into commercial products or to use it for commercial * purposes should contact: * * Knut Akesson (KA), knut@supremica.org * Supremica, * Knarrhogsgatan 10 * SE-431 60 MOLNDAL * SWEDEN * * to discuss license terms. No cost evaluation licenses are * available. * * Licensee may not use the name, logo, or any other symbol * of Supremica nor the names of any of its employees nor * any adaptation thereof in advertising or publicity * pertaining to the software without specific prior written * approval of the Supremica. * * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE. * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY. * * Supremica or KA shall not be liable for any damages * suffered by Licensee from the use of this software. * * Supremica is owned and represented by KA. */package org.supremica.automata.algorithms.minimization;import java.util.Iterator;import java.util.LinkedList;import java.util.Map;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.supremica.automata.Alphabet;import org.supremica.automata.Arc;import org.supremica.automata.Automata;import org.supremica.automata.Automaton;import org.supremica.automata.AutomatonType;import org.supremica.automata.LabeledEvent;import org.supremica.automata.State;import org.supremica.properties.Config;/** * This class has methods used by minimization algorithms. * * @author <a href="mailto:flordal@chalmers.se">Hugo Flordal</a> */public class MinimizationHelper{    final static String PLANTIFY_PREFIX = "plant";    private static Logger logger = LogManager.getLogger(MinimizationHelper.class);    /**     * Merges two states, giving the new state the union of incoming and outgoing transitions,     * if at least one state was accepting, the result is accepting, and similarily for     * initial and forbidden states     *     * @param aut The automaton in which the collapsing is done, both     * states must be in this automaton.     * @param useShortNames If true, a new, short, name is generated     * for the new state instead of concatenating the names of the     * originals.     * @return The resulting state (which belongs to aut).     */    public static State mergeStates(final Automaton aut, final State one, final State two, final boolean useShortNames)    {        // Don't merge if they are actually the same state        if (one.equals(two))        {            return one;        }        // Make new state        State newState;        if (useShortNames)        {            newState = aut.createUniqueState();        }        else        {            newState = new State(one.getName() + Config.GENERAL_STATE_LABEL_SEPARATOR.getValue() +                two.getName());        }        aut.addState(newState);        /*        // If aut is a kripke automaton, also take the union of KripkeLabels!        if (aut instanceof KripkeAutomaton)        {            Set<KripkeLabel> labels = one.getKripkeLabels();            labels.addAll(two.getKripkeLabels());            newState.setKripkeLabels(labels);            // Temporary solution... the labels should be stored in a map!            newState.setName(newState.getKripkeLabels().toString());        }         */        // Set markings        if (one.isAccepting() || two.isAccepting()) // Looks odd but is correct!        {            newState.setAccepting(true);        }        if (one.isForbidden() || two.isForbidden())        {            newState.setForbidden(true);        }        if (one.isInitial() || two.isInitial())        {            //newState.setInitial(true);            aut.setInitialState(newState);        }        // Add transitions        final LinkedList<Arc> toBeAdded = new LinkedList<Arc>();//        logger.info(one.nextState("outM1"));////        logger.info("statetwo "+one.getName()+" the active events "+two.getOutgoingArcs()+" the alphabet of the automaton "+aut.getAlphabet());//        final Iterator<Arc> outgoingArcsIt = one.outgoingArcsIterator();        for (final Iterator<Arc> arcIt = one.outgoingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateOne"+one);            final Arc arc = arcIt.next();//            logger.info("stateOneArcOut"+arc);            State toState = arc.getToState();            if (toState.equals(one) || toState.equals(two))            {                toState = newState;            }            toBeAdded.add(new Arc(newState, toState, arc.getEvent()));        }        for (final Iterator<Arc> arcIt = two.outgoingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateTwo"+two);            final Arc arc = arcIt.next();//            logger.info("stateTwoArcOut"+arc);            State toState = arc.getToState();            if (toState.equals(one) || toState.equals(two))            {                toState = newState;            }            toBeAdded.add(new Arc(newState, toState, arc.getEvent()));        }        for (final Iterator<Arc> arcIt = one.incomingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateone"+one);            final Arc arc = arcIt.next();//            logger.info("stateOneArcIn"+arc);            State fromState = arc.getFromState();            if (fromState.equals(one) || fromState.equals(two))            {                fromState = newState;            }            toBeAdded.add(new Arc(fromState, newState, arc.getEvent()));        }        for (final Iterator<Arc> arcIt = two.incomingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateTwo"+two);            final Arc arc = arcIt.next();//            logger.info("stateTwoArcIn"+arc);            State fromState = arc.getFromState();            if (fromState.equals(one) || fromState.equals(two))            {                fromState = newState;            }            toBeAdded.add(new Arc(fromState, newState, arc.getEvent()));        }        // Add the new arcs!        while (toBeAdded.size() != 0)        {            // Add if not already there or epsilon selfloop            final Arc arc = toBeAdded.remove(0);            // TODO Fix bug - tau-loops must be suppressed or conflict            // equivalence minimisation will break.            if (!arc.getEvent().isObservable() && arc.isSelfLoop())            {                continue;            }            if (!arc.getFromState().containsOutgoingArc(arc))            {                aut.addArc(arc);            }        }        // Remove the states//        logger.info("o0ne"+one);//        logger.info("two"+two);        aut.removeState(one);        aut.removeState(two);                /*        // Adjust the index of the new state (see the "H�r blir det fel" discussion in AutomataIndexForm)        if (one.getIndex() < two.getIndex())        {            // Take over the index of state one            newState.setIndex(one.getIndex());        }        else        {            // Take over the index of state two            newState.setIndex(two.getIndex());        }                 */        // Return the new state        return newState;    }    public static State mergeSynthesisStates(final Automaton aut, final State one, final State two, final boolean useShortNames)    {        // Don't merge if they are actually the same state        if (one.equals(two))        {            return one;        }        // Make new state        State newState;        if (useShortNames)        {            newState = aut.createUniqueState();        }        else        {            newState = new State(one.getName() + Config.GENERAL_STATE_LABEL_SEPARATOR.getValue() +                two.getName());        }        aut.addState(newState);        /*        // If aut is a kripke automaton, also take the union of KripkeLabels!        if (aut instanceof KripkeAutomaton)        {            Set<KripkeLabel> labels = one.getKripkeLabels();            labels.addAll(two.getKripkeLabels());            newState.setKripkeLabels(labels);            // Temporary solution... the labels should be stored in a map!            newState.setName(newState.getKripkeLabels().toString());        }         */        // Set markings        if (one.isAccepting() || two.isAccepting()) // Looks odd but is correct!        {            newState.setAccepting(true);        }        if (one.isForbidden() || two.isForbidden())        {            newState.setForbidden(true);        }        if (one.isInitial() || two.isInitial())        {            //newState.setInitial(true);            aut.setInitialState(newState);        }        // Add transitions        final LinkedList<Arc> toBeAdded = new LinkedList<Arc>();//        logger.info(one.nextState("outM1"));////        logger.info("statetwo "+one.getName()+" the active events "+two.getOutgoingArcs()+" the alphabet of the automaton "+aut.getAlphabet());//        final Iterator<Arc> outgoingArcsIt = one.outgoingArcsIterator();        for (final Iterator<Arc> arcIt = one.outgoingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateOne"+one);            final Arc arc = arcIt.next();//            logger.info("stateOneArcOut"+arc);            State toState = arc.getToState();            if (toState.equals(one) || toState.equals(two))            {                toState = newState;            }            toBeAdded.add(new Arc(newState, toState, arc.getEvent()));        }        for (final Iterator<Arc> arcIt = two.outgoingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateTwo"+two);            final Arc arc = arcIt.next();//            logger.info("stateTwoArcOut"+arc);            State toState = arc.getToState();            if (toState.equals(one) || toState.equals(two))            {                toState = newState;            }            toBeAdded.add(new Arc(newState, toState, arc.getEvent()));        }        for (final Iterator<Arc> arcIt = one.incomingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateone"+one);            final Arc arc = arcIt.next();//            logger.info("stateOneArcIn"+arc);            State fromState = arc.getFromState();            if (fromState.equals(one) || fromState.equals(two))            {                fromState = newState;            }            toBeAdded.add(new Arc(fromState, newState, arc.getEvent()));        }        for (final Iterator<Arc> arcIt = two.incomingArcsIterator(); arcIt.hasNext(); )        {//            logger.info("stateTwo"+two);            final Arc arc = arcIt.next();//            logger.info("stateTwoArcIn"+arc);            State fromState = arc.getFromState();            if (fromState.equals(one) || fromState.equals(two))            {                fromState = newState;            }            toBeAdded.add(new Arc(fromState, newState, arc.getEvent()));        }        // Add the new arcs!        while (toBeAdded.size() != 0)        {            // Add if not already there or epsilon selfloop            final Arc arc = toBeAdded.remove(0);            // TODO Fix bug - tau-loops must be suppressed or conflict            // equivalence minimisation will break.//            if (!arc.getEvent().isObservable() && arc.isSelfLoop())//            {//                continue;//            }            if (!arc.getFromState().containsOutgoingArc(arc))            {                aut.addArc(arc);            }        }        // Remove the states//        logger.info("o0ne"+one);//        logger.info("two"+two);        aut.removeState(one);        aut.removeState(two);                /*        // Adjust the index of the new state (see the "H�r blir det fel" discussion in AutomataIndexForm)        if (one.getIndex() < two.getIndex())        {            // Take over the index of state one            newState.setIndex(one.getIndex());        }        else        {            // Take over the index of state two            newState.setIndex(two.getIndex());        }                 */        // Return the new state        return newState;    }    /**     * This method finds the local events in selection wrt the rest of the automata.     */    public static Alphabet getLocalEvents(final Automata selection, final Map<LabeledEvent,Automata> eventToAutomataMap)    {        // The candidates for localness        final Alphabet maybeLocal = selection.getUnionAlphabet();        // Which aren't local?        final Alphabet notLocal = new Alphabet();        loop: for (final Iterator<LabeledEvent> it = maybeLocal.iterator(); it.hasNext(); )        {            final LabeledEvent event = it.next();            final Automata sharers = eventToAutomataMap.get(event);            //System.err.println("Event " + event + " sharareS:" + sharers);            // Epsilon events are not counted as local            // Why can't I do this!!!???!? Incredibly strange...            // maybe because of the way Automaton.hide works?            if (event.isUnobservable())            {                notLocal.addEvent(event);                continue loop;            }            // Skip this selection            if (selection.equalAutomata(sharers))            {                continue loop;            }            // If there are more sharers than there are automata in            // aut... then this event is not local here            if (sharers.size() > selection.size())            {                notLocal.addEvent(event);                continue loop;            }            // If sharers is not a subset of selection, the event is not local!            for (final Iterator<Automaton> autIt = sharers.iterator(); autIt.hasNext(); )            {                // If there is an automaton here that is not in selection,                // this event is not local to selection...                if (!selection.containsAutomaton(autIt.next()))                {                    notLocal.addEvent(event);                    continue loop;                }            }        }        final Alphabet local = maybeLocal.minus(notLocal);        //assert(notLocal.nbrOfEpsilonEvents() == 0);        //assert(local.nbrOfEpsilonEvents() == 0);        return local;    }    /**     * Makes plants out of specifications (and supervisors) in automata.     */	@Deprecated    public static void plantify(final Automaton aut)	// DO NOT USE THIS ONE, it won't do what you want it to (under certain circumstances)    {		logger.debug("plantify(Automaton) - old version, DO NOT USE THIS (unless you are very sure you know what you do");		// Don't come here with anything but spec or sup!		assert(aut.isSpecification() || aut.isSupervisor());		aut.saturateDump(aut.getAlphabet().getUncontrollableAlphabet()); // BUG! nasty, nasty...		aut.setComment(PLANTIFY_PREFIX + "(" + aut.getName() + ")");		aut.setType(AutomatonType.PLANT);    }    // Use this variant, it will guard you, but much better is to...    private static void plantify(final Automaton aut, final Alphabet ucAlpha)    {		// Don't come here with anything but spec or sup!		assert(aut.isSpecification() || aut.isSupervisor());		// And make sure ucAlpha only contains uc-events		assert(ucAlpha.getUncontrollableAlphabet().equals(ucAlpha));		// aut.saturateDump(aut.getAlphabet().getUncontrollableAlphabet()); // BUG! nasty, nasty...		final Alphabet uc_alpha = aut.getAlphabet().getUncontrollableAlphabet();		uc_alpha.intersect(ucAlpha);		if(uc_alpha.size() == 0)		{			logger.info("No common uc-events - nothing to plantify");			return;		}		do_plantify(aut, uc_alpha);    }    // ...use this version.    public static void plantify(final Automata automata)    {		logger.debug("plantify(Automaton) - new version, does not assume spec uc-alpha is subset of plant alpha");		final Alphabet uc_alpha = new Alphabet();	// collects the uncontrollable PLANT events		for(final Automaton aut : automata)		{			if(aut.isPlant())	// should also include supervisor?			{				uc_alpha.union(aut.getAlphabet().getUncontrollableAlphabet());			}		}		if(uc_alpha.size() == 0)		{			logger.info("Number of uncontrollable plant events are zero - nothing to plantify");			return;		}        for (final Automaton aut : automata)        {			if (aut.isSpecification() || aut.isSupervisor())	// should not include supervisor?			{				plantify(aut, uc_alpha);			}        }    }    /**     * Note nasty bug in plantify method... it was fixed by adding the ucAlpha parameter     * Plantify was assumed to be a local thing, looking at a spec you could determine which uc-events to dump     * But that assumes that the spec alphabet is included in (or same as) the plant alphabet, which does not always hold!     * Correct is to only plantify for uc-events in the plant(s) AND the spec!     **/	/**	 * This private (so far) function does the actual plantifying	 * It does not care anything about where the alphabet comes from, it just odes it	 * @param aut automaton to plantify	 * @param uc_alpha set of uc-events on which to add transitions to the dump state	 */	private static void do_plantify(final Automaton aut, final Alphabet uc_alpha)	{		aut.saturateDump(uc_alpha);		aut.setComment(PLANTIFY_PREFIX + "(" + aut.getName() + ")");		aut.setType(AutomatonType.PLANT);	}    /**     * This method finds the events that all automata in the selection share.     */    public static Alphabet getCommonEvents(final Automata selection, final Map<LabeledEvent,Automata> eventToAutomataMap)    {        // The candidates for commonness        final Alphabet maybeCommon = selection.getUnionAlphabet();        // Which aren't common?        final Alphabet notCommon = new Alphabet();        loop: for (final Iterator<LabeledEvent> it = maybeCommon.iterator(); it.hasNext(); )        {            final LabeledEvent event = it.next();            final Automata sharers = eventToAutomataMap.get(event);            // Epsilon events are not counted as common            if (event.isUnobservable())            {                notCommon.addEvent(event);                continue loop;            }            // Skip this selection            if (selection.equalAutomata(sharers))            {                continue loop;            }            // If there are fewer sharers than there are automata in            // aut... then this event is not common here            if (sharers.size() < selection.size())            {                notCommon.addEvent(event);                continue loop;            }            // If selection is not a subset of sharers, the event is not common!            for (final Iterator<Automaton> autIt = selection.iterator(); autIt.hasNext(); )            {                // If there is an automaton here that is not in sharers,                // this event is not common to selection...                if (!sharers.containsAutomaton(autIt.next()))                {                    notCommon.addEvent(event);                    continue loop;                }            }        }        final Alphabet common = maybeCommon.minus(notCommon);        //assert(notCommon.nbrOfEpsilonEvents() == 0);        //assert(common.nbrOfEpsilonEvents() == 0);        return common;    }}