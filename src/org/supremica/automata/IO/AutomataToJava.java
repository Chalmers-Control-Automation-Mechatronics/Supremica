
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Knarrhogsgatan 10
 * SE-431 60 MOLNDAL
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.IO;

import java.io.PrintWriter;
import java.text.DateFormat;
import java.util.Date;
import java.util.Iterator;

import net.sourceforge.waters.config.Version;

import org.supremica.automata.Alphabet;
import org.supremica.automata.AutomataIndexMap;
import org.supremica.automata.Automaton;
import org.supremica.automata.LabeledEvent;
import org.supremica.automata.Project;
import org.supremica.automata.State;
import org.supremica.automata.algorithms.SynchronizationType;
import org.supremica.automata.execution.Action;
import org.supremica.automata.execution.Command;
import org.supremica.automata.execution.Condition;
import org.supremica.automata.execution.Control;
import org.supremica.automata.execution.EventTimer;
import org.supremica.automata.execution.Signal;
import org.supremica.util.SupremicaException;

/**
 * This class generates a java source file from a bunch of automata.
 *
 * @author torda
 */
public class AutomataToJava
{
    public static class GenerationException
        extends SupremicaException
    {
        private static final long serialVersionUID = 1L;

        public GenerationException()
        {
            super();
        }

        public GenerationException(final String message)
        {
            super(message);
        }

        public GenerationException(final String message, final Throwable cause)
        {
            super(message, cause);
        }

        public GenerationException(final Throwable cause)
        {
            super(cause);
        }
    }

    private final Project project;
    private final SynchronizationType syncType = SynchronizationType.PRIORITIZED;
    private Alphabet allEvents;
    private final String classname;
    private AutomataIndexMap indexMap;

    public AutomataToJava(final Project theProject, final String classname)
    {
        this.project = theProject;
        this.classname = classname;
    }

    private void initialize()
    {
        indexMap = new AutomataIndexMap(project);
        allEvents = project.setIndices();
    }

    void printFileHeader(final PrintWriter pw)
    {
        pw.println("/*");
        pw.println(" * This file is automatically generated from Supremica");
        pw.println(" * " + Version.getInstance().toString());
        pw.println(" * This file was generated at: " + DateFormat.getDateTimeInstance().format(new Date()));
        pw.println(" */");
        pw.println("import org.supremica.softplc.RunTime.DigitalIODriver;");
        pw.println("/**");
        pw.println(" * Class " + this.classname + " was automatically generated from");
        pw.println(" * Supremica.");
        pw.println(" *");
        pw.println(" * The class is depending on the interface");
        pw.println(" * org.supremica.softplc.RunTime.DigitalIODriver and");
        pw.println(" * on the class DigitalIODriverFactory. The latter");
        pw.println(" * should be provided by the user. This class should");
        pw.println(" * create objects that implements the DigitalIODriver");
        pw.println(" * interface. The implementing class is by nature");
        pw.println(" * applicaton specific.");
        pw.println(" *");
        pw.println(" * The following automata are synchronized.");
        pw.println(" * The number is the index used in this file");
        pw.println(" * to identify the automata.");

        for (final Iterator<?> autIt = project.iterator(); autIt.hasNext(); )
        {
            final Automaton currAutomaton = (Automaton) autIt.next();

            pw.println(" *   Automaton " + currAutomaton.getSynchIndex() + ": \"" + currAutomaton.getName() + "\"");
        }

        pw.println(" *");
        pw.println(" * Event indices and the corresponding event label");

        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            final LabeledEvent currEvent = (LabeledEvent) alphIt.next();

            pw.println(" *   Event " + currEvent.getIndex() + ": \"" + currEvent.getLabel() + "\" " + (currEvent.isControllable()
            ? "controllable"
                : "uncontrollable"));
        }

        pw.println(" *");
        pw.println(" * Input signal ports and the corresponding label");

        if (project.getInputSignals().size() == 0)
        {
            pw.println(" *   No input signals");
        }

        for (final Iterator<?> it = project.inputSignalsIterator(); it.hasNext(); )
        {
            final Signal currSignal = (Signal) it.next();

            pw.println(" *   Input port " + currSignal.getPort() + ": \"" + currSignal.getLabel() + "\"");
        }

        pw.println(" *");
        pw.println(" * Output signal ports and the corresponding label");

        if (project.getOutputSignals().size() == 0)
        {
            pw.println(" *   No output signals");
        }

        for (final Iterator<?> it = project.outputSignalsIterator(); it.hasNext(); )
        {
            final Signal currSignal = (Signal) it.next();

            pw.println(" *   Output port " + currSignal.getPort() + ": \"" + currSignal.getLabel() + "\"");
        }

        pw.println(" *");
        pw.println(" * Timer indices and the corresponding label");

        if (project.getTimers().size() == 0)
        {
            pw.println(" *   No timers");
        }

        for (final Iterator<?> it = project.timerIterator(); it.hasNext(); )
        {
            final EventTimer currTimer = (EventTimer) it.next();

            pw.println(" *   Timer " + currTimer.getSynchIndex() + ": \"" + currTimer.getName() + "\"");
        }

        pw.println(" */");
    }

    void printClassHeader(final PrintWriter pw)
    {
        pw.println("public class " + this.classname + " {");
    }

    void printTimerSubclass(final PrintWriter pw)
    {
        pw.println("\t/**");
        pw.println("\t * Class Timer is a simple countdown timer.");
        pw.println("\t * Start the timer like this:");
        pw.println("\t * <code>myTimer.start()</code>");
        pw.println("\t * It has timed out if:");
        pw.println("\t * <code>myTimer.hasTimedOut()</code>");
        pw.println("\t * returns true.");
        pw.println("\t */");
        pw.println("\tstatic class Timer {");
        pw.println("\t\tint delay;");
        pw.println("\t\tThread timerThread;");
        pw.println("\t\tpublic Timer(int delay) { // In ms");
        pw.println("\t\t\tthis.delay = delay;");
        pw.println("\t\t}");
        pw.println("\t\tpublic void start() {");
        pw.println("\t\t\ttimerThread = new Thread(new Runnable() {");
        pw.println("\t\t\t\tpublic void run() {");
        pw.println("\t\t\t\t\ttry {");
        pw.println("\t\t\t\t\t\tThread.sleep(Timer.this.delay);");
        pw.println("\t\t\t\t\t} catch (InterruptedException e) {}");
        pw.println("\t\t\t\t}");
        pw.println("\t\t\t});");
        pw.println("\t\t\ttimerThread.start();");
        pw.println("\t\t}");
        pw.println("\t\tpublic boolean hasTimedOut() {");
        pw.println("\t\t\treturn timerThread == null || !timerThread.isAlive();");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    void printConstructor(final PrintWriter pw)

    //throws Exception
    {
        pw.println("\n\t/**");
        pw.println("\t * Constructor");
        pw.println("\t */");
        pw.println("\t" + classname + "() {");
        pw.println("\t\t/*");
        pw.println("\t\t * DigitalIODriverFactory is a class that");
        pw.println("\t\t * should be implemented by the user (you).");
        pw.println("\t\t * The class should have a public static function");
        pw.println("\t\t * that creates an object which implements the");
        pw.println("\t\t * org.supremica.softplc.RunTime.DigitalIODriver");
        pw.println("\t\t * interface.");
        pw.println("\t\t */");
        pw.println("\t\tdigitalIODriver = DigitalIODriverFactory.createDigitalIODriver();");
        pw.println("\t\tinputVariables = new boolean[digitalIODriver.getNrOfSignalsIn()];");
        pw.println("\t\toutputVariables = new boolean[digitalIODriver.getNrOfSignalsOut()];");
        pw.println("\t}");
    }

    public void serialize(final PrintWriter pw)
    throws GenerationException
    {
        initialize();
        printFileHeader(pw);
        printClassHeader(pw);
        printTimerSubclass(pw);
        printFields(pw);
        printConstructor(pw);
        printEventIsEnabledInCurrentState(pw);
        printEventIsEnabledByInputVariables(pw);
        printEventIsEnabledByTimers(pw);
        printUpdateCurrentState(pw);
        printUpdateOutputVariables(pw);
        printStartTimers(pw);
        printExecuteFunction(pw);
        printMainFunction(pw);
        printClassFooter(pw);
        pw.flush();
    }

    private void printClassFooter(final PrintWriter pw)
    {
        pw.println("}");
    }

    private void printMainFunction(final PrintWriter pw)
    {
        pw.println();
        pw.println("\tpublic static void main(String[] args) {");
        pw.println("\t\t" + classname + " instance = new " + classname + "();");
        pw.println("\t\tinstance.execute();");
        pw.println("\t}");
    }

    private void printExecuteFunction(final PrintWriter pw)
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Executes the program.");
        pw.println("\t */");
        pw.println("\tvoid execute() {");
        pw.println("\t\t// The index of the event that is selected to be executed");
        pw.println("\t\tint eventToBeExecuted = NO_EVENT_IS_SELECTED;");
        pw.println();
        pw.println("\t\tlong timeOfLastScan = System.currentTimeMillis();");
        pw.println("\t\tlong timeToSleep;");
        pw.println();
        pw.println("\t\t// Main scancycle");
        pw.println("\t\twhile (true) {");
        pw.println("\t\t\ttry {");
        pw.println("\t\t\t\teventToBeExecuted = NO_EVENT_IS_SELECTED;");
        pw.println();
        pw.println("\t\t\t\t// Read the input signal values into the input variables");
        pw.println("\t\t\t\tdigitalIODriver.getSignalArray(inputVariables);");
        pw.println();
        pw.println("\t\t\t\t/*");
        pw.println("\t\t\t\t * Select the first event that is enabled.");
        pw.println("\t\t\t\t * Search in the order that is given by the");
        pw.println("\t\t\t\t * priority queue. Uncontrollable events");
        pw.println("\t\t\t\t * lies first in the queue and are thus");
        pw.println("\t\t\t\t * selected first. For an event to be");
        pw.println("\t\t\t\t * enabled, it has to be enabled in the");
        pw.println("\t\t\t\t * current internal state as well as ");
        pw.println("\t\t\t\t * by external input signals.");
        pw.println("\t\t\t\t */");
        pw.println("\t\t\t\tfor (int i = 0; i < NR_OF_EVENTS && eventToBeExecuted == NO_EVENT_IS_SELECTED; ++i)");
        pw.println("\t\t\t\t\tif (eventIsEnabledInCurrentState(EVENT_PRIORITY_QUEUE[i])");
        pw.println("\t\t\t\t\t\t\t&& eventIsEnabledByInputVariables(EVENT_PRIORITY_QUEUE[i])");
        pw.println("\t\t\t\t\t\t\t&& eventIsEnabledByTimers(EVENT_PRIORITY_QUEUE[i]))");
        pw.println("\t\t\t\t\t\teventToBeExecuted = EVENT_PRIORITY_QUEUE[i];");
        pw.println();
        pw.println("\t\t\t\t// Update the output variables");
        pw.println("\t\t\t\tupdateOutputVariables(eventToBeExecuted);");
        pw.println();
        pw.println("\t\t\t\t// Start the timers that are triggered by this event");
        pw.println("\t\t\t\tstartTimers(eventToBeExecuted);");
        pw.println();
        pw.println("\t\t\t\t// Update state");
        pw.println("\t\t\t\tupdateCurrentState(eventToBeExecuted);");
        pw.println();
        pw.println("\t\t\t\t// Write the output variables");
        pw.println("\t\t\t\tdigitalIODriver.setSignalArray(outputVariables);");
        pw.println();
        pw.println("\t\t\t\t// For debugging");
        pw.println("\t\t\t\t//if (eventToBeExecuted != NO_EVENT_IS_SELECTED)");
        pw.println("\t\t\t\t//\tSystem.out.println(EVENT_LABELS[eventToBeExecuted]);");
        pw.println("\t\t\t} catch (Exception e) {");
        pw.println("\t\t\t\te.printStackTrace();");
        pw.println("\t\t\t}");
        pw.println();
        pw.println("\t\t\t/*");
        pw.println("\t\t\t * For a constant scan cycle time, set");
        pw.println("\t\t\t * PREFERRED_SCAN_CYCLE_TIME to a value larger than");
        pw.println("\t\t\t * the real scan cycle time. ");
        pw.println("\t\t\t */");
        pw.println("\t\t\ttimeToSleep = PREFERRED_SCAN_CYCLE_TIME - (System.currentTimeMillis() - timeOfLastScan); ");
        pw.println("\t\t\tif (timeToSleep > 0) {");
        pw.println("\t\t\t\ttry {");
        pw.println("\t\t\t\t\tThread.sleep(timeToSleep);");
        pw.println("\t\t\t\t} catch(InterruptedException e){}");
        pw.println("\t\t\t}");
        pw.println("\t\t\ttimeOfLastScan = System.currentTimeMillis();");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    private void printUpdateOutputVariables(final PrintWriter pw)
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Sets output variables according to the executed event");
        pw.println("\t * @param eventIndex The executed event");
        pw.println("\t */");
        pw.println("\tvoid updateOutputVariables(int eventIndex) {");
        pw.println("\t\t/*");
        pw.println("\t\t * No output variables are changed by default.");
        pw.println("\t\t * Example:");
        pw.println("\t\t * case 3: // Event \"startMachine\"");
        pw.println("\t\t *   outputVariables[7] = true;");
        pw.println("\t\t *   break;");
        pw.println("\t\t */");
        pw.println("\t\tswitch (eventIndex) {");

        LabeledEvent event;
        Action action;
        Command command;
        Signal signal;

        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            event = (LabeledEvent) alphIt.next();
            action = project.getActions().getAction(event);

            if (action != null)
            {
                pw.println("\t\tcase " + event.getIndex() + ": // Event \"" + event.getLabel() + "\"");

                for (final Iterator<?> commandIt = action.commandIterator();
                commandIt.hasNext(); )
                {
                    command = (Command) commandIt.next();
                    signal = project.getOutputSignals().getSignal(command.getLabel());

                    pw.println("\t\t\toutputVariables[" + signal.getPort() + "] = " + command.getValue() + "; // Output \"" + signal.getLabel() + "\"");
                }

                pw.println("\t\t\tbreak;");
            }
        }

        pw.println("\t\tdefault: // Do nothing");
        pw.println("\t\t\tbreak;");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    private void printUpdateCurrentState(final PrintWriter pw)
    throws GenerationException
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Updates the states of the automata");
        pw.println("\t * @param eventIndex The executed event");
        pw.println("\t */");
        pw.println("\tvoid updateCurrentState(int eventIndex) {");
        pw.println("\t\tswitch (eventIndex) {");
        pw.println("\t\tcase NO_EVENT_IS_SELECTED: // If no event was enabled");
        pw.println("\t\t\tbreak;");

        LabeledEvent event;
        Automaton automaton;
        Alphabet alphabet;
        State currState;
        State toState;

        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            event = (LabeledEvent) alphIt.next();
            pw.println("\t\tcase " + event.getIndex() + ": // Event \"" + event.getLabel() + "\"");
            for (final Iterator<?> autIt = project.iterator(); autIt.hasNext(); )
            {
                automaton = (Automaton) autIt.next();
                alphabet = automaton.getAlphabet();

                if (alphabet.contains(event))
                {
                    final LabeledEvent automatonEvent = automaton.getAlphabet().getEvent(event.getLabel());

                    if (automatonEvent == null)
                    {
                        throw new GenerationException("Could not find " + event.getLabel() + " in automaton " + automaton.getName());
                    }

                    pw.println("\n\t\t\t// Transitions in \"" + automaton.getName() + "\"");

                    boolean previousState = false;

                    for (final Iterator<?> stateIt = automaton.statesThatEnableEventIterator(event.getLabel());
                    stateIt.hasNext(); )
                    {
                        currState = (State) stateIt.next();
                        toState = currState.nextState(automatonEvent);
                        if (toState == null)
                        {
                            throw new GenerationException("Could not find the next state from state " + currState.getName() + " with label " + event.getLabel() + " in automaton " + automaton.getName());
                        }
                        if (currState != toState)
                        {
                            if (!previousState)
                            {
                                pw.print("\t\t\tif");

                                previousState = true;
                            }
                            else
                            {
                                pw.print("\t\t\telse if");
                            }

                            pw.println(" (currentState[" + automaton.getIndex() + "] == " + currState.getSynchIndex() + ")");
                            pw.println("\t\t\t\tcurrentState[" + automaton.getIndex() + "] = " + toState.getSynchIndex() + ";");
                        }
                        else
                        {
                            pw.println("\t\t\t// currentState[" + automaton.getIndex() + "] == " + currState.getSynchIndex() + " has event " + event.getIndex() + " as self loop, no transition");
                        }
                    }
                }
            }

            pw.println("\t\t\tbreak;");
        }

        pw.println("\t\tdefault:");
        pw.println("\t\t\t// Should never get here");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    private void printStartTimers(final PrintWriter pw)
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Start timers.");
        pw.println("\t * @param eventIndex The executed event");
        pw.println("\t */");
        pw.println("\tvoid startTimers(int eventIndex) {");
        pw.println("\t\t/*");
        pw.println("\t\t * No timers are started by default.");
        pw.println("\t\t * Example:");
        pw.println("\t\t * case 9: // Event \"mytimer_start\"");
        pw.println("\t\t *   timers[2].start();  // Timer \"mytimer\"");
        pw.println("\t\t *   break;");
        pw.println("\t\t */");
        pw.println("\t\tswitch (eventIndex) {");
        LabeledEvent event;
        EventTimer timer;
        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            event = (LabeledEvent) alphIt.next();

            final Iterator<?> timerIt = project.getTimers().iteratorWithStartEvent(event);
            final boolean startsTimer = timerIt.hasNext();

            if (startsTimer)
            {
                pw.println("\t\tcase " + event.getIndex() + ": // Event \"" + event.getLabel() + "\"");
            }

            while (timerIt.hasNext())
            {
                timer = (EventTimer) timerIt.next();

                pw.println("\t\t\ttimers[" + timer.getSynchIndex() + "].start(); // Timer \"" + timer.getName() + "\"");
            }

            if (startsTimer)
            {
                pw.println("\t\t\tbreak;");
            }
        }

        pw.println("\t\tdefault: // Do nothing");
        pw.println("\t\t\tbreak;");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    private void printEventIsEnabledByInputVariables(final PrintWriter pw)
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Checks if the event is enabled by conditions");
        pw.println("\t * on input variable values.");
        pw.println("\t * @param eventIndex");
        pw.println("\t * @return <code>true</code> if the event is enabled.");
        pw.println("\t *         <code>false</code> otherwise.");
        pw.println("\t */");
        pw.println("\tboolean eventIsEnabledByInputVariables(int eventIndex) {");
        pw.println("\t\t/*");
        pw.println("\t\t * All external conditions are true by default.");
        pw.println("\t\t * Example:");
        pw.println("\t\t * case 8: // Event \"product_arrival\"");
        pw.println("\t\t *   return inputVariables[5];  // Sensor on port 5");
        pw.println("\t\t */");
        pw.println("\t\tswitch (eventIndex) {");

        LabeledEvent event;
        Control control;
        Condition condition;
        Signal signal;
        boolean firstCondition = true;

        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            event = (LabeledEvent) alphIt.next();
            control = project.getControls().getControl(event);

            if (control != null)
            {
                pw.println("\t\tcase " + event.getIndex() + ": // Event \"" + event.getLabel() + "\"");
                pw.print("\t\t\treturn ");

                firstCondition = true;

                for (final Iterator<?> conditionIt = control.conditionIterator();
                conditionIt.hasNext(); )
                {
                    condition = (Condition) conditionIt.next();
                    signal = project.getInputSignals().getSignal(condition.getLabel());

                    if (signal != null)
                    {
                        if (!firstCondition)
                        {
                            pw.print(" && ");
                        }

                        if (condition.doInvert())
                        {
                            pw.print("!");
                        }

                        pw.print("inputVariables[" + signal.getPort() + "]");

                        firstCondition = false;
                    }
                }

                pw.println(";");
            }
        }

        pw.println("\t\tdefault:");
        pw.println("\t\t\treturn true;");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    private void printEventIsEnabledByTimers(final PrintWriter pw)
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Checks if the event is enabled by timers.");
        pw.println("\t * @param eventIndex");
        pw.println("\t * @return <code>true</code> if the event is enabled.");
        pw.println("\t *         <code>false</code> otherwise.");
        pw.println("\t */");
        pw.println("\tboolean eventIsEnabledByTimers(int eventIndex) {");
        pw.println("\t\t/*");
        pw.println("\t\t * All timer conditions are true by default.");
        pw.println("\t\t * Example:");
        pw.println("\t\t * case 5: // Event \"mytimer_timeout\"");
        pw.println("\t\t *   return timers[2].hasTimedOut();  // Timer \"mytimer\"");
        pw.println("\t\t */");
        pw.println("\t\tswitch (eventIndex) {");
        LabeledEvent event;
        EventTimer timer;
        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            event = (LabeledEvent) alphIt.next();
            timer = project.getTimers().getTimerWithTimeoutEvent(event);

            if (timer != null)
            {
                pw.println("\t\tcase " + event.getIndex() + ": // Event \"" + event.getLabel() + "\"");
                pw.println("\t\t\treturn timers[" + timer.getSynchIndex() + "].hasTimedOut(); // Timer \"" + timer.getName() + "\"");
            }
        }

        pw.println("\t\tdefault:");
        pw.println("\t\t\treturn true;");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    private void printEventIsEnabledInCurrentState(final PrintWriter pw)
    {
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Checks if the event is enabled in the");
        pw.println("\t * current state of the automata");
        pw.println("\t * @param eventIndex");
        pw.println("\t * @return <code>true</code> if the event is enabled.");
        pw.println("\t *         <code>false</code> otherwise.");
        pw.println("\t */");
        pw.println("\tboolean eventIsEnabledInCurrentState(int eventIndex) {");
        pw.println("\t\tswitch (eventIndex) {");

        LabeledEvent event;
        Automaton automaton;
        Alphabet alphabet;
        State state;

        for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
        {
            event = (LabeledEvent) alphIt.next();

            pw.println("\t\tcase " + event.getIndex() + ": // Event \"" + event.getLabel() + "\"");
            pw.print("\t\t\treturn ");

            boolean previousCondition = false;

            for (final Iterator<?> autIt = project.iterator(); autIt.hasNext(); )
            {
                automaton = (Automaton) autIt.next();
                alphabet = automaton.getAlphabet();

                if (syncType == SynchronizationType.PRIORITIZED)
                {    // All automata that has this event as prioritized must be able to execute it
                    if (alphabet.containsEqualEvent(event) && alphabet.isPrioritized(event))
                    {    // Find all states that enables this event

                        // Use OR between states in the same automaton.
                        // Use AND between states in different automata.
                        if (previousCondition)
                        {
                            pw.print("\n\t\t\t\t\t&& ");
                        }
                        else
                        {
                            previousCondition = true;
                        }

                        boolean previousState = false;

                        pw.print("(");

                        for (final Iterator<?> stateIt = automaton.statesThatEnableEventIterator(event.getLabel());
                        stateIt.hasNext(); )
                        {
                            state = (State) stateIt.next();

                            if (previousState)
                            {
                                pw.print(" || ");
                            }
                            else
                            {
                                previousState = true;
                            }

                            pw.print("currentState[" + automaton.getIndex() + "] == " + state.getSynchIndex());
                        }

                        if (!previousState)
                        {
                            pw.print("false /* Automaton " + automaton.getIndex() + " */");
                        }

                        pw.print(")");
                    }
                }
                else
                {
                    assert false;
                    System.err.println("Error in AutomataToJava.java");

                    return;
                }
            }

            pw.println(";");
        }

        pw.println("\t\tdefault:");
        pw.println("\t\t\t// Should never get here");
        pw.println("\t\t\treturn false;");
        pw.println("\t\t}");
        pw.println("\t}");
    }

    /**
     * Prints out fields.
     */
    private void printFields(final PrintWriter pw)
    {
        pw.println();
        pw.println("\tstatic final int NO_EVENT_IS_SELECTED = -1;");
        pw.println("\tstatic final int NR_OF_EVENTS = " + allEvents.nbrOfEvents() + ";");
        pw.println("\tstatic final int NR_OF_AUTOMATA = " + project.nbrOfAutomata() + ";");
        pw.println("\tstatic final int NR_OF_TIMERS = " + project.getTimers().size() + ";");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * Preferred scan cycle time in milliseconds.");
        pw.println("\t * The program executes continously if the real");
        pw.println("\t * scan cycle time is larger than this value.");
        pw.println("\t */");
        pw.println("\tstatic final int PREFERRED_SCAN_CYCLE_TIME = 0;");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * The enabled event that comes first in this array is executed.");
        pw.println("\t * The uncontrollable events has the highest priority");
        pw.println("\t */");
        pw.print("\tstatic final int[] EVENT_PRIORITY_QUEUE = {");

        boolean firstEventPrinted = false;

        for (final Iterator<?> alphIt = allEvents.uncontrollableEventIterator();
        alphIt.hasNext(); )
        {
            if (firstEventPrinted)
            {
                pw.print(", ");
            }

            pw.print(((LabeledEvent) alphIt.next()).getIndex());

            firstEventPrinted = true;
        }

        for (final Iterator<?> alphIt = allEvents.controllableEventIterator();
        alphIt.hasNext(); )
        {
            if (firstEventPrinted)
            {
                pw.print(", ");
            }

            pw.print(((LabeledEvent) alphIt.next()).getIndex());

            firstEventPrinted = true;
        }

        pw.println("};");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * A map from event index to event label. Is not used by default.");
        pw.println("\t */");
        pw.print("\tstatic final String[] EVENT_LABELS = {");

        firstEventPrinted = false;

        for (int i = 0; i < allEvents.nbrOfEvents(); ++i)
        {
            if (firstEventPrinted)
            {
                pw.print(",\n\t\t\t");
            }

            //pw.print("\"" + allEvents.getEventWithIndex(i).getLabel() + "\"");
            pw.print("\"" + indexMap.getEventAt(i).getLabel() + "\"");

            firstEventPrinted = true;
        }

        pw.println("};");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * This vector holds the current state.");
        pw.println("\t * The indices corresponds to automata.");
        pw.println("\t * The value of an element corresponds");
        pw.println("\t * to the state of that automaton. It is");
        pw.println("\t * initiated to its' initial states.");
        pw.println("\t */");
        pw.print("\tint[] currentState = {");

        boolean initialStateForFirstAutomatonPrinted = false;

        for (final Iterator<?> it = project.iterator(); it.hasNext(); )
        {
            if (initialStateForFirstAutomatonPrinted)
            {
                pw.print(",\n\t\t\t");
            }

            pw.print(((Automaton) it.next()).getInitialState().getSynchIndex());

            initialStateForFirstAutomatonPrinted = true;
        }

        pw.println("};");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * This array holds the last read input signal values.");
        pw.println("\t */");
        pw.println("\tboolean[] inputVariables;");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * This vector holds the output signal values to be written.");
        pw.println("\t */");
        pw.println("\tboolean[] outputVariables;");
        pw.println();
        pw.println("\t/**");
        pw.println("\t * This object handles IO. The user (you) should");
        pw.println("\t * provide a class that implements the interface");
        pw.println("\t * org.supremica.softplc.RunTime.DigitalIODriver");
        pw.println("\t */");
        pw.println("\tDigitalIODriver digitalIODriver;");
        pw.println();
        pw.print("\tfinal Timer[] timers = {");

        boolean firstTimerPrinted = false;

        for (final Iterator<?> it = project.timerIterator(); it.hasNext(); )
        {
            final EventTimer timer = (EventTimer) it.next();

            if (firstTimerPrinted)
            {
                pw.print(",\n\t\t\t");
            }

            pw.print("new Timer(" + timer.getDelay() + ")");

            firstTimerPrinted = true;
        }

        pw.println("};");
    }
}
