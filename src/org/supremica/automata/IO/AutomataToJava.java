
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Haradsgatan 26A
 * 431 42 Molndal
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.IO;

import java.io.*;
import java.util.*;
import java.text.DateFormat;
import org.supremica.log.*;
import org.supremica.automata.*;
import org.supremica.automata.algorithms.SynchronizationType;
import org.supremica.automata.algorithms.AutomataSynchronizerHelper;
import org.supremica.automata.execution.*;
import org.supremica.util.SupremicaException;

/**
 * @author torda
 *
 * This class generates a java source file from a bunch of automata.
 */
public class AutomataToJava
{
	public class GenerationException
		extends SupremicaException
	{
		private static final long serialVersionUID = 1L;

		public GenerationException()
		{
			super();
		}

		public GenerationException(String message)
		{
			super(message);
		}

		public GenerationException(String message, Throwable cause)
		{
			super(message, cause);
		}

		public GenerationException(Throwable cause)
		{
			super(cause);
		}
	}

	private static Logger logger = LoggerFactory.createLogger(AutomataToJava.class);
	private Project theProject;
	private AutomataSynchronizerHelper syncHelper;
	private SynchronizationType syncType = SynchronizationType.Prioritized;
	private Alphabet allEvents;
	private String classname;

	public AutomataToJava(Project theProject, String classname)
	{
		this.theProject = theProject;
		this.classname = classname;
	}

	private void initialize()
	{
		allEvents = theProject.setIndicies();
	}

	void printFileHeader(PrintWriter pw)
	{
		pw.println("/*");
		pw.println(" * This file is automatically generated from Supremica");
		pw.println(" * Supremica version: " + org.supremica.Version.version());
		pw.println(" * This file was generated at: " + DateFormat.getDateTimeInstance().format(new Date()));
		pw.println(" */");
		pw.println("import org.supremica.softplc.RunTime.DigitalIODriver;");
		pw.println("/**");
		pw.println(" * Class " + this.classname + " was automatically generated from");
		pw.println(" * Supremica.");
		pw.println(" *");
		pw.println(" * The class is depending on the interface");
		pw.println(" * org.supremica.softplc.RunTime.DigitalIODriver and");
		pw.println(" * on the class DigitalIODriverFactory. The latter");
		pw.println(" * should be provided by the user. This class should");
		pw.println(" * create objects that implements the DigitalIODriver");
		pw.println(" * interface. The implementing class is by nature");
		pw.println(" * applicaton specific.");
		pw.println(" *");
		pw.println(" * The following automata are synchronized.");
		pw.println(" * The number is the index used in this file");
		pw.println(" * to identify the automata.");

		for (Iterator autIt = theProject.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();

			pw.println(" *   Automaton " + currAutomaton.getSynchIndex() + ": \"" + currAutomaton.getName() + "\"");
		}

		pw.println(" *");
		pw.println(" * Event indices and the corresponding event label");

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();

			pw.println(" *   Event " + currEvent.getSynchIndex() + ": \"" + currEvent.getLabel() + "\" " + (currEvent.isControllable()
																											? "controllable"
																											: "uncontrollable"));
		}

		pw.println(" *");
		pw.println(" * Input signal ports and the corresponding label");

		if (theProject.getInputSignals().size() == 0)
		{
			pw.println(" *   No input signals");
		}

		for (Iterator it = theProject.inputSignalsIterator(); it.hasNext(); )
		{
			Signal currSignal = (Signal) it.next();

			pw.println(" *   Input port " + currSignal.getPort() + ": \"" + currSignal.getLabel() + "\"");
		}

		pw.println(" *");
		pw.println(" * Output signal ports and the corresponding label");

		if (theProject.getOutputSignals().size() == 0)
		{
			pw.println(" *   No output signals");
		}

		for (Iterator it = theProject.outputSignalsIterator(); it.hasNext(); )
		{
			Signal currSignal = (Signal) it.next();

			pw.println(" *   Output port " + currSignal.getPort() + ": \"" + currSignal.getLabel() + "\"");
		}

		pw.println(" *");
		pw.println(" * Timer indices and the corresponding label");

		if (theProject.getTimers().size() == 0)
		{
			pw.println(" *   No timers");
		}

		for (Iterator it = theProject.timerIterator(); it.hasNext(); )
		{
			EventTimer currTimer = (EventTimer) it.next();

			pw.println(" *   Timer " + currTimer.getSynchIndex() + ": \"" + currTimer.getName() + "\"");
		}

		pw.println(" */");
	}

	void printClassHeader(PrintWriter pw)
	{
		pw.println("public class " + this.classname + " {");
	}

	void printTimerSubclass(PrintWriter pw)
	{
		pw.println("\t/**");
		pw.println("\t * Class Timer is a simple countdown timer.");
		pw.println("\t * Start the timer like this:");
		pw.println("\t * <code>myTimer.start()</code>");
		pw.println("\t * It has timed out if:");
		pw.println("\t * <code>myTimer.hasTimedOut()</code>");
		pw.println("\t * returns true.");
		pw.println("\t */");
		pw.println("\tstatic class Timer {");
		pw.println("\t\tint delay;");
		pw.println("\t\tThread timerThread;");
		pw.println("\t\tpublic Timer(int delay) { // In ms");
		pw.println("\t\t\tthis.delay = delay;");
		pw.println("\t\t}");
		pw.println("\t\tpublic void start() {");
		pw.println("\t\t\ttimerThread = new Thread(new Runnable() {");
		pw.println("\t\t\t\tpublic void run() {");
		pw.println("\t\t\t\t\ttry {");
		pw.println("\t\t\t\t\t\tThread.sleep(Timer.this.delay);");
		pw.println("\t\t\t\t\t} catch (InterruptedException e) {}");
		pw.println("\t\t\t\t}");
		pw.println("\t\t\t});");
		pw.println("\t\t\ttimerThread.start();");
		pw.println("\t\t}");
		pw.println("\t\tpublic boolean hasTimedOut() {");
		pw.println("\t\t\treturn timerThread == null || !timerThread.isAlive();");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	void printConstructor(PrintWriter pw)

	//throws Exception
	{
		pw.println("\n\t/**");
		pw.println("\t * Constructor");
		pw.println("\t */");
		pw.println("\t" + classname + "() {");
		pw.println("\t\t/*");
		pw.println("\t\t * DigitalIODriverFactory is a class that");
		pw.println("\t\t * should be implemented by the user (you).");
		pw.println("\t\t * The class should have a public static function");
		pw.println("\t\t * that creates an object which implements the");
		pw.println("\t\t * org.supremica.softplc.RunTime.DigitalIODriver");
		pw.println("\t\t * interface.");
		pw.println("\t\t */");
		pw.println("\t\tdigitalIODriver = DigitalIODriverFactory.createDigitalIODriver();");
		pw.println("\t\tinputVariables = new boolean[digitalIODriver.getNrOfSignalsIn()];");
		pw.println("\t\toutputVariables = new boolean[digitalIODriver.getNrOfSignalsOut()];");
		pw.println("\t}");
	}

	public void serialize(PrintWriter pw)
		throws GenerationException
	{
		initialize();
		printFileHeader(pw);
		printClassHeader(pw);
		printTimerSubclass(pw);
		printFields(pw);
		printConstructor(pw);
		printEventIsEnabledInCurrentState(pw);
		printEventIsEnabledByInputVariables(pw);
		printEventIsEnabledByTimers(pw);
		printUpdateCurrentState(pw);
		printUpdateOutputVariables(pw);
		printStartTimers(pw);
		printExecuteFunction(pw);
		printMainFunction(pw);
		printClassFooter(pw);
		pw.flush();
	}

	/**
	 * @param pw
	 */
	private void printClassFooter(PrintWriter pw)
	{
		pw.println("}");
	}

	private void printMainFunction(PrintWriter pw)
	{
		pw.println();
		pw.println("\tpublic static void main(String[] args) {");
		pw.println("\t\t" + classname + " instance = new " + classname + "();");
		pw.println("\t\tinstance.execute();");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printExecuteFunction(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Executes the program.");
		pw.println("\t */");
		pw.println("\tvoid execute() {");
		pw.println("\t\t// The index of the event that is selected to be executed");
		pw.println("\t\tint eventToBeExecuted = NO_EVENT_IS_SELECTED;");
		pw.println();
		pw.println("\t\tlong timeOfLastScan = System.currentTimeMillis();");
		pw.println("\t\tlong timeToSleep;");
		pw.println();
		pw.println("\t\t// Main scancycle");
		pw.println("\t\twhile (true) {");
		pw.println("\t\t\ttry {");
		pw.println("\t\t\t\teventToBeExecuted = NO_EVENT_IS_SELECTED;");
		pw.println();
		pw.println("\t\t\t\t// Read the input signal values into the input variables");
		pw.println("\t\t\t\tdigitalIODriver.getSignalArray(inputVariables);");
		pw.println();
		pw.println("\t\t\t\t/*");
		pw.println("\t\t\t\t * Select the first event that is enabled.");
		pw.println("\t\t\t\t * Search in the order that is given by the");
		pw.println("\t\t\t\t * priority queue. Uncontrollable events");
		pw.println("\t\t\t\t * lies first in the queue and are thus");
		pw.println("\t\t\t\t * selected first. For an event to be");
		pw.println("\t\t\t\t * enabled, it has to be enabled in the");
		pw.println("\t\t\t\t * current internal state as well as ");
		pw.println("\t\t\t\t * by external input signals.");
		pw.println("\t\t\t\t */");
		pw.println("\t\t\t\tfor (int i = 0; i < NR_OF_EVENTS && eventToBeExecuted == NO_EVENT_IS_SELECTED; ++i)");
		pw.println("\t\t\t\t\tif (eventIsEnabledInCurrentState(EVENT_PRIORITY_QUEUE[i])");
		pw.println("\t\t\t\t\t\t\t&& eventIsEnabledByInputVariables(EVENT_PRIORITY_QUEUE[i])");
		pw.println("\t\t\t\t\t\t\t&& eventIsEnabledByTimers(EVENT_PRIORITY_QUEUE[i]))");
		pw.println("\t\t\t\t\t\teventToBeExecuted = EVENT_PRIORITY_QUEUE[i];");
		pw.println();
		pw.println("\t\t\t\t// Update the output variables");
		pw.println("\t\t\t\tupdateOutputVariables(eventToBeExecuted);");
		pw.println();
		pw.println("\t\t\t\t// Start the timers that are triggered by this event");
		pw.println("\t\t\t\tstartTimers(eventToBeExecuted);");
		pw.println();
		pw.println("\t\t\t\t// Update state");
		pw.println("\t\t\t\tupdateCurrentState(eventToBeExecuted);");
		pw.println();
		pw.println("\t\t\t\t// Write the output variables");
		pw.println("\t\t\t\tdigitalIODriver.setSignalArray(outputVariables);");
		pw.println();
		pw.println("\t\t\t\t// For debugging");
		pw.println("\t\t\t\t//if (eventToBeExecuted != NO_EVENT_IS_SELECTED)");
		pw.println("\t\t\t\t//\tSystem.out.println(EVENT_LABELS[eventToBeExecuted]);");
		pw.println("\t\t\t} catch (Exception e) {");
		pw.println("\t\t\t\te.printStackTrace();");
		pw.println("\t\t\t}");
		pw.println();
		pw.println("\t\t\t/*");
		pw.println("\t\t\t * For a constant scan cycle time, set");
		pw.println("\t\t\t * PREFERRED_SCAN_CYCLE_TIME to a value larger than");
		pw.println("\t\t\t * the real scan cycle time. ");
		pw.println("\t\t\t */");
		pw.println("\t\t\ttimeToSleep = PREFERRED_SCAN_CYCLE_TIME - (System.currentTimeMillis() - timeOfLastScan); ");
		pw.println("\t\t\tif (timeToSleep > 0) {");
		pw.println("\t\t\t\ttry {");
		pw.println("\t\t\t\t\tThread.sleep(timeToSleep);");
		pw.println("\t\t\t\t} catch(InterruptedException e){}");
		pw.println("\t\t\t}");
		pw.println("\t\t\ttimeOfLastScan = System.currentTimeMillis();");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printUpdateOutputVariables(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Sets output variables according to the executed event");
		pw.println("\t * @param eventIndex The executed event");
		pw.println("\t */");
		pw.println("\tvoid updateOutputVariables(int eventIndex) {");
		pw.println("\t\t/*");
		pw.println("\t\t * No output variables are changed by default.");
		pw.println("\t\t * Example:");
		pw.println("\t\t * case 3: // Event \"startMachine\"");
		pw.println("\t\t *   outputVariables[7] = true;");
		pw.println("\t\t *   break;");
		pw.println("\t\t */");
		pw.println("\t\tswitch (eventIndex) {");

		LabeledEvent event;
		Action action;
		Command command;
		Signal signal;

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			event = (LabeledEvent) alphIt.next();
			action = theProject.getActions().getAction(event);

			if (action != null)
			{
				pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");

				for (Iterator commandIt = action.commandIterator();
						commandIt.hasNext(); )
				{
					command = (Command) commandIt.next();
					signal = theProject.getOutputSignals().getSignal(command.getLabel());

					pw.println("\t\t\toutputVariables[" + signal.getPort() + "] = " + command.getValue() + "; // Output \"" + signal.getLabel() + "\"");
				}

				pw.println("\t\t\tbreak;");
			}
		}

		pw.println("\t\tdefault: // Do nothing");
		pw.println("\t\t\tbreak;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printUpdateCurrentState(PrintWriter pw)
		throws GenerationException
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Updates the states of the automata");
		pw.println("\t * @param eventIndex The executed event");
		pw.println("\t */");
		pw.println("\tvoid updateCurrentState(int eventIndex) {");
		pw.println("\t\tswitch (eventIndex) {");
		pw.println("\t\tcase NO_EVENT_IS_SELECTED: // If no event was enabled");
		pw.println("\t\t\tbreak;");

		LabeledEvent event;
		Automaton automaton;
		Alphabet alphabet;
		State currState;
		State toState;

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			event = (LabeledEvent) alphIt.next();

			pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");

			boolean previousCondition = false;

			for (Iterator autIt = theProject.iterator(); autIt.hasNext(); )
			{
				automaton = (Automaton) autIt.next();
				alphabet = automaton.getAlphabet();

				if (alphabet.contains(event))
				{
					LabeledEvent automatonEvent = automaton.getEvent(event.getLabel());

					if (automatonEvent == null)
					{
						throw new GenerationException("Could not find " + event.getLabel() + " in automaton " + automaton.getName());
					}

					pw.println("\n\t\t\t// Transitions in \"" + automaton.getName() + "\"");

					boolean previousState = false;

					for (Iterator stateIt = automaton.statesThatEnableEventIterator(event.getLabel());
							stateIt.hasNext(); )
					{
						currState = (State) stateIt.next();
						toState = currState.nextState(automatonEvent);

						int currStateIndex = currState.getSynchIndex();

						if (toState == null)
						{
							throw new GenerationException("Could not find the next state from state " + currState.getName() + " with label " + event.getLabel() + " in automaton " + automaton.getName());
						}

						int toStateIndex = toState.getSynchIndex();

						if (currState != toState)
						{
							if (!previousState)
							{
								pw.print("\t\t\tif");

								previousState = true;
							}
							else
							{
								pw.print("\t\t\telse if");
							}

							pw.println(" (currentState[" + automaton.getIndex() + "] == " + currState.getSynchIndex() + ")");
							pw.println("\t\t\t\tcurrentState[" + automaton.getIndex() + "] = " + toState.getSynchIndex() + ";");
						}
						else
						{
							pw.println("\t\t\t// currentState[" + automaton.getIndex() + "] == " + currState.getSynchIndex() + " has event " + event.getSynchIndex() + " as self loop, no transition");
						}
					}
				}
			}

			pw.println("\t\t\tbreak;");
		}

		pw.println("\t\tdefault:");
		pw.println("\t\t\t// Should never get here");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printStartTimers(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Start timers.");
		pw.println("\t * @param eventIndex The executed event");
		pw.println("\t */");
		pw.println("\tvoid startTimers(int eventIndex) {");
		pw.println("\t\t/*");
		pw.println("\t\t * No timers are started by default.");
		pw.println("\t\t * Example:");
		pw.println("\t\t * case 9: // Event \"mytimer_start\"");
		pw.println("\t\t *   timers[2].start();  // Timer \"mytimer\"");
		pw.println("\t\t *   break;");
		pw.println("\t\t */");
		pw.println("\t\tswitch (eventIndex) {");

		LabeledEvent event;
		EventTimer timer;
		boolean firstTimer = true;

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			event = (LabeledEvent) alphIt.next();

			Iterator timerIt = theProject.getTimers().iteratorWithStartEvent(event);
			boolean startsTimer = timerIt.hasNext();

			if (startsTimer)
			{
				pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
			}

			while (timerIt.hasNext())
			{
				timer = (EventTimer) timerIt.next();

				pw.println("\t\t\ttimers[" + timer.getSynchIndex() + "].start(); // Timer \"" + timer.getName() + "\"");
			}

			if (startsTimer)
			{
				pw.println("\t\t\tbreak;");
			}
		}

		pw.println("\t\tdefault: // Do nothing");
		pw.println("\t\t\tbreak;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printEventIsEnabledByInputVariables(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Checks if the event is enabled by conditions");
		pw.println("\t * on input variable values.");
		pw.println("\t * @param eventIndex");
		pw.println("\t * @return <code>true</code> if the event is enabled.");
		pw.println("\t *         <code>false</code> otherwise.");
		pw.println("\t */");
		pw.println("\tboolean eventIsEnabledByInputVariables(int eventIndex) {");
		pw.println("\t\t/*");
		pw.println("\t\t * All external conditions are true by default.");
		pw.println("\t\t * Example:");
		pw.println("\t\t * case 8: // Event \"product_arrival\"");
		pw.println("\t\t *   return inputVariables[5];  // Sensor on port 5");
		pw.println("\t\t */");
		pw.println("\t\tswitch (eventIndex) {");

		LabeledEvent event;
		Control control;
		Condition condition;
		Signal signal;
		boolean firstCondition = true;

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			event = (LabeledEvent) alphIt.next();
			control = theProject.getControls().getControl(event);

			if (control != null)
			{
				pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
				pw.print("\t\t\treturn ");

				firstCondition = true;

				for (Iterator conditionIt = control.conditionIterator();
						conditionIt.hasNext(); )
				{
					condition = (Condition) conditionIt.next();
					signal = theProject.getInputSignals().getSignal(condition.getLabel());

					if (signal != null)
					{
						if (!firstCondition)
						{
							pw.print(" && ");
						}

						if (condition.doInvert())
						{
							pw.print("!");
						}

						pw.print("inputVariables[" + signal.getPort() + "]");

						firstCondition = false;
					}
				}

				pw.println(";");
			}
		}

		pw.println("\t\tdefault:");
		pw.println("\t\t\treturn true;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printEventIsEnabledByTimers(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Checks if the event is enabled by timers.");
		pw.println("\t * @param eventIndex");
		pw.println("\t * @return <code>true</code> if the event is enabled.");
		pw.println("\t *         <code>false</code> otherwise.");
		pw.println("\t */");
		pw.println("\tboolean eventIsEnabledByTimers(int eventIndex) {");
		pw.println("\t\t/*");
		pw.println("\t\t * All timer conditions are true by default.");
		pw.println("\t\t * Example:");
		pw.println("\t\t * case 5: // Event \"mytimer_timeout\"");
		pw.println("\t\t *   return timers[2].hasTimedOut();  // Timer \"mytimer\"");
		pw.println("\t\t */");
		pw.println("\t\tswitch (eventIndex) {");

		LabeledEvent event;
		EventTimer timer;
		boolean firstTimer = true;

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			event = (LabeledEvent) alphIt.next();
			timer = theProject.getTimers().getTimerWithTimeoutEvent(event);

			if (timer != null)
			{
				pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
				pw.println("\t\t\treturn timers[" + timer.getSynchIndex() + "].hasTimedOut(); // Timer \"" + timer.getName() + "\"");
			}
		}

		pw.println("\t\tdefault:");
		pw.println("\t\t\treturn true;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printEventIsEnabledInCurrentState(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Checks if the event is enabled in the");
		pw.println("\t * current state of the automata");
		pw.println("\t * @param eventIndex");
		pw.println("\t * @return <code>true</code> if the event is enabled.");
		pw.println("\t *         <code>false</code> otherwise.");
		pw.println("\t */");
		pw.println("\tboolean eventIsEnabledInCurrentState(int eventIndex) {");
		pw.println("\t\tswitch (eventIndex) {");

		LabeledEvent event;
		Automaton automaton;
		Alphabet alphabet;
		State state;

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			event = (LabeledEvent) alphIt.next();

			pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
			pw.print("\t\t\treturn ");

			boolean previousCondition = false;

			for (Iterator autIt = theProject.iterator(); autIt.hasNext(); )
			{
				automaton = (Automaton) autIt.next();
				alphabet = automaton.getAlphabet();

				if (syncType == SynchronizationType.Prioritized)
				{    // All automata that has this event as prioritized must be able to execute it
					if (alphabet.containsEqualEvent(event) && alphabet.isPrioritized(event))
					{    // Find all states that enables this event

						// Use OR between states in the same automaton.
						// Use AND between states in different automata.
						if (previousCondition)
						{
							pw.print("\n\t\t\t\t\t&& ");
						}
						else
						{
							previousCondition = true;
						}

						boolean previousState = false;

						pw.print("(");

						for (Iterator stateIt = automaton.statesThatEnableEventIterator(event.getLabel());
								stateIt.hasNext(); )
						{
							state = (State) stateIt.next();

							if (previousState)
							{
								pw.print(" || ");
							}
							else
							{
								previousState = true;
							}

							pw.print("currentState[" + automaton.getIndex() + "] == " + state.getSynchIndex());
						}

						if (!previousState)
						{
							pw.print("false /* Automaton " + automaton.getIndex() + " */");
						}

						pw.print(")");
					}
				}
				else
				{
					assert false;
					System.err.println("Error in AutomataToJava.java");

					return;
				}
			}

			pw.println(";");
		}

		pw.println("\t\tdefault:");
		pw.println("\t\t\t// Should never get here");
		pw.println("\t\t\treturn false;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * Prints out fields
	 * @param pw
	 */
	private void printFields(PrintWriter pw)
	{
		pw.println();
		pw.println("\tstatic final int NO_EVENT_IS_SELECTED = -1;");
		pw.println("\tstatic final int NR_OF_EVENTS = " + allEvents.nbrOfEvents() + ";");
		pw.println("\tstatic final int NR_OF_AUTOMATA = " + theProject.nbrOfAutomata() + ";");
		pw.println("\tstatic final int NR_OF_TIMERS = " + theProject.getTimers().size() + ";");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Preferred scan cycle time in milliseconds.");
		pw.println("\t * The program executes continously if the real");
		pw.println("\t * scan cycle time is larger than this value.");
		pw.println("\t */");
		pw.println("\tstatic final int PREFERRED_SCAN_CYCLE_TIME = 0;");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * The enabled event that comes first in this array is executed.");
		pw.println("\t * The uncontrollable events has the highest priority");
		pw.println("\t */");
		pw.print("\tstatic final int[] EVENT_PRIORITY_QUEUE = {");

		boolean firstEventPrinted = false;

		for (Iterator alphIt = allEvents.uncontrollableEventIterator();
				alphIt.hasNext(); )
		{
			if (firstEventPrinted)
			{
				pw.print(", ");
			}

			pw.print(((LabeledEvent) alphIt.next()).getSynchIndex());

			firstEventPrinted = true;
		}

		for (Iterator alphIt = allEvents.controllableEventIterator();
				alphIt.hasNext(); )
		{
			if (firstEventPrinted)
			{
				pw.print(", ");
			}

			pw.print(((LabeledEvent) alphIt.next()).getSynchIndex());

			firstEventPrinted = true;
		}

		pw.println("};");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * A map from event index to event label. Is not used by default.");
		pw.println("\t */");
		pw.print("\tstatic final String[] EVENT_LABELS = {");

		firstEventPrinted = false;

		for (int i = 0; i < allEvents.nbrOfEvents(); ++i)
		{
			if (firstEventPrinted)
			{
				pw.print(",\n\t\t\t");
			}

			pw.print("\"" + allEvents.getEventWithIndex(i).getLabel() + "\"");

			firstEventPrinted = true;
		}

		pw.println("};");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * This vector holds the current state.");
		pw.println("\t * The indices corresponds to automata.");
		pw.println("\t * The value of an element corresponds");
		pw.println("\t * to the state of that automaton. It is");
		pw.println("\t * initiated to its' initial states.");
		pw.println("\t */");
		pw.print("\tint[] currentState = {");

		boolean initialStateForFirstAutomatonPrinted = false;

		for (Iterator it = theProject.iterator(); it.hasNext(); )
		{
			if (initialStateForFirstAutomatonPrinted)
			{
				pw.print(",\n\t\t\t");
			}

			pw.print(((Automaton) it.next()).getInitialState().getSynchIndex());

			initialStateForFirstAutomatonPrinted = true;
		}

		pw.println("};");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * This array holds the last read input signal values.");
		pw.println("\t */");
		pw.println("\tboolean[] inputVariables;");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * This vector holds the output signal values to be written.");
		pw.println("\t */");
		pw.println("\tboolean[] outputVariables;");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * This object handles IO. The user (you) should");
		pw.println("\t * provide a class that implements the interface");
		pw.println("\t * org.supremica.softplc.RunTime.DigitalIODriver");
		pw.println("\t */");
		pw.println("\tDigitalIODriver digitalIODriver;");
		pw.println();
		pw.print("\tfinal Timer[] timers = {");

		boolean firstTimerPrinted = false;

		for (Iterator it = theProject.timerIterator(); it.hasNext(); )
		{
			EventTimer timer = (EventTimer) it.next();

			if (firstTimerPrinted)
			{
				pw.print(",\n\t\t\t");
			}

			pw.print("new Timer(" + timer.getDelay() + ")");

			firstTimerPrinted = true;
		}

		pw.println("};");
	}
}
