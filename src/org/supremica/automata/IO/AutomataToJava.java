
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Haradsgatan 26A
 * 431 42 Molndal
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.IO;

import java.io.*;
import java.util.*;
import java.text.DateFormat;

import org.supremica.log.*;
import org.supremica.automata.*;
import org.supremica.automata.algorithms.SynchronizationType;
import org.supremica.automata.algorithms.AutomataSynchronizerHelper;

/**
 * @author torda
 *
 * This class generates a java source file from a bunch of automata.
 */
public class AutomataToJava
{
	public class GenerationException extends Exception
	{
		public GenerationException() {
			super();
		}
		public GenerationException(String message) {
			super(message);
		}
		public GenerationException(String message, Throwable cause) {
			super(message, cause);
		}
		public GenerationException(Throwable cause) {
			super(cause);
		}
	}
	private static Logger logger = LoggerFactory.createLogger(AutomataToJava.class);
	private Automata theAutomata;
	private AutomataSynchronizerHelper syncHelper;
	private SynchronizationType syncType = SynchronizationType.Prioritized;
	private Alphabet allEvents;
	private String classname;

	public AutomataToJava(Automata theAutomata, String classname)
	{
		this.theAutomata = theAutomata;
		this.classname = classname;
	}

	private void initialize()
	{
		allEvents = theAutomata.setIndicies();
	}

	void printFileHeader(PrintWriter pw)
	{
		pw.println("/**");
		pw.println(" * This file is automatically generated from Supremica");
		pw.println(" * Supremica version: " + org.supremica.Version.version());
		pw.println(" * This file was generated at: " +  DateFormat.getDateTimeInstance().format(new Date()));
		pw.println(" *");
		pw.println(" * The following automata are synchronized.");
		pw.println(" * The number is the index used in this file");
		pw.println(" * to identify the automata.");
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
		{
			Automaton currAutomaton = (Automaton)autIt.next();
			pw.println(" *   Automaton " + currAutomaton.getSynchIndex() + ": \"" + currAutomaton.getName() + "\"");
		}
		pw.println(" *");
		pw.println(" * Event indices and the corresponding event label");
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			LabeledEvent currEvent = (LabeledEvent)alphIt.next();
			pw.println(" *   Event " + currEvent.getSynchIndex() + ": \"" + currEvent.getLabel() + "\" " + (currEvent.isControllable() ? "controllable" : "uncontrollable"));
		}
		pw.println(" */");
	}

	void printClassHeader(PrintWriter pw)
	{
		pw.println("public class " + this.classname);
		pw.println("{");
	}

	void printInitializationFunction(PrintWriter pw)
		//throws Exception
	{
		pw.println("\n\t/**");
		pw.println("\t * Intitialization function");
		pw.println("\t */");
		pw.println("\tstatic void initialize()");
		pw.println("\t{");
		pw.println("\t\t// Add initialization code here");
		pw.println("\t}");
	}

	public void serialize(PrintWriter pw)
		throws GenerationException
	{
		initialize();

		printFileHeader(pw);
		printClassHeader(pw);
		printConstants(pw);
		printInitializationFunction(pw);
		printInternallyEnabledFunction(pw);
		printExternallyEnabledFunction(pw);
		printExecuteEventInternallyFunction(pw);
		printExecuteEventExternallyFunction(pw);
		printMainFunction(pw);
		printClassFooter(pw);
		pw.flush();
	}

	/**
	 * @param pw
	 */
	private void printClassFooter(PrintWriter pw)
	{
		pw.println("}");
	}

	/**
	 * @param pw
	 */
	private void printMainFunction(PrintWriter pw)
	{
		pw.println();
		pw.println("\tpublic static void main(String[] args)");
		pw.println("\t{");
		pw.println("\t\t// The index of the event that is selected to be executed");
		pw.println("\t\tint eventToBeExecuted = NO_EVENT_IS_SELECTED;");
		pw.println("\t\t");
		pw.println("\t\t// Set current state to the initial state");
		pw.println("\t\tfor (int i = 0; i < currentState.length; ++i)");
		pw.println("\t\t\tcurrentState[i] = 0;");
		pw.println();
		pw.println("\t\t// Initialize the supervisor");
		pw.println("\t\tinitialize();");
		pw.println("\t\t");
		pw.println("\t\tlong timeOfLastScan = System.currentTimeMillis();");
		pw.println("\t\tlong timeToSleep;");
		pw.println("\t\t");
		pw.println("\t\t// Main scancycle");
		pw.println("\t\twhile (true)");
		pw.println("\t\t{");
		pw.println("\t\t\teventToBeExecuted = NO_EVENT_IS_SELECTED;");
		pw.println();
		pw.println("\t\t\t/*");
		pw.println("\t\t\t * Select the first event that is enabled.");
		pw.println("\t\t\t * Search in the order that is given by the");
		pw.println("\t\t\t * priority queue. Uncontrollable events");
		pw.println("\t\t\t * lies first in the queue and are thus");
		pw.println("\t\t\t * selected first. For an event to be");
		pw.println("\t\t\t * enabled, it has to be enabled in the");
		pw.println("\t\t\t * current internal state as well as ");
		pw.println("\t\t\t * by external input signals.");
		pw.println("\t\t\t */");
		pw.println("\t\t\tfor (int i = 0; i < NR_OF_EVENTS && eventToBeExecuted == NO_EVENT_IS_SELECTED; ++i)");
		pw.println("\t\t\t\tif (eventIsInternallyEnabled(EVENT_PRIORITY_QUEUE[i]) && eventIsExternallyEnabled(EVENT_PRIORITY_QUEUE[i]))");
		pw.println("\t\t\t\t\teventToBeExecuted = EVENT_PRIORITY_QUEUE[i];");
		pw.println();
		pw.println("\t\t\t// Set outputs");
		pw.println("\t\t\texecuteEventExternally(eventToBeExecuted);");
		pw.println("\t\t\t");
		pw.println("\t\t\t// Update state");
		pw.println("\t\t\texecuteEventInternally(eventToBeExecuted);");
		pw.println("\t\t\t");
		pw.println("\t\t\t// For debugging");
		pw.println("\t\t\t//System.out.println(EVENT_LABELS[eventToBeExecuted]);");
		pw.println("\t\t\t");
		pw.println("\t\t\t/*");
		pw.println("\t\t\t * For a constant scan cycle time, set");
		pw.println("\t\t\t * PREFERRED_SCAN_CYCLE_TIME to a value larger than");
		pw.println("\t\t\t * the real scan cycle time. ");
		pw.println("\t\t\t */");
		pw.println("\t\t\ttimeToSleep = PREFERRED_SCAN_CYCLE_TIME - (System.currentTimeMillis() - timeOfLastScan); ");
		pw.println("\t\t\tif (timeToSleep > 0)");
		pw.println("\t\t\t{");
		pw.println("\t\t\t\ttry");
		pw.println("\t\t\t\t{");
		pw.println("\t\t\t\t\tThread.sleep(timeToSleep);");
		pw.println("\t\t\t\t}");
		pw.println("\t\t\t\tcatch(InterruptedException e){}");
		pw.println("\t\t\t}");
		pw.println("\t\t\ttimeOfLastScan = System.currentTimeMillis();");
		pw.println("\t\t}");
		pw.println("\t}");
	}


	/**
	 * @param pw
	 */
	private void printExecuteEventExternallyFunction(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Sets output signals according to the executed event");
		pw.println("\t * @param eventIndex The executed event");
		pw.println("\t */");
		pw.println("\tstatic void executeEventExternally(int eventIndex)");
		pw.println("\t{");
		pw.println("\t\t// Add actions here, the default does not change anything. Example:");
		pw.println("\t\t// SetGlobalOutput(OUT_A, OUT_ON); // enable output A;");
		pw.println("\t\tswitch (eventIndex)");
		pw.println("\t\t{");
		pw.println("\t\tcase NO_EVENT_IS_SELECTED: // If no event was enabled");
		pw.println("\t\t\tbreak;");
		LabeledEvent event;
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			event = (LabeledEvent)alphIt.next();
			pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
			pw.println("\t\t\tbreak;");
		}
		pw.println("\t\tdefault:");
		pw.println("\t\t\t// Should never get here");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printExecuteEventInternallyFunction(PrintWriter pw)
		throws GenerationException
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Updates the states of the automata");
		pw.println("\t * @param eventIndex The executed event");
		pw.println("\t */");
		pw.println("\tstatic void executeEventInternally(int eventIndex)");
		pw.println("\t{");
		pw.println("\t\tswitch (eventIndex)");
		pw.println("\t\t{");
		pw.println("\t\tcase NO_EVENT_IS_SELECTED: // If no event was enabled");
		pw.println("\t\t\tbreak;");
		LabeledEvent event;
		Automaton automaton;
		Alphabet alphabet;
		State currState;
		State toState;
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			event = (LabeledEvent)alphIt.next();
			pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
			boolean previousCondition = false;
			for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
			{
				automaton = (Automaton)autIt.next();
				alphabet = automaton.getAlphabet();
				if (alphabet.contains(event))
				{
					LabeledEvent automatonEvent = automaton.getEvent(event.getLabel());
					if (automatonEvent == null)
						throw new GenerationException("Could not find " + event.getLabel() + " in automaton " + automaton.getName());
					pw.println("\n\t\t\t// Transitions in \"" + automaton.getName() + "\"");
					boolean previousState = false;
					for (Iterator stateIt = automaton.statesThatEnableEventIterator(event.getLabel()); stateIt.hasNext();)
					{
						currState = (State)stateIt.next();
						toState = currState.nextState(automatonEvent);

						int currStateIndex = currState.getSynchIndex();

						if (toState == null)
							throw new GenerationException("Could not find the next state from state " + currState.getName() + " with label " + event.getLabel() + " in automaton " + automaton.getName());
						int toStateIndex = toState.getSynchIndex();
						if (currState != toState)
						{
							if (!previousState)
							{
								pw.print("\t\t\tif");
								previousState = true;
							}
							else
								pw.print("\t\t\telse if");
							pw.println(" (currentState[" + automaton.getIndex() + "] == " + currState.getSynchIndex() + ")");
							pw.println("\t\t\t\tcurrentState[" + automaton.getIndex() + "] = " + toState.getSynchIndex() + ";");
						}
						else
							pw.println("\t\t\t// currentState[" + automaton.getIndex() + "] == " + currState.getSynchIndex() + " has event " + event.getSynchIndex() + " as self loop, no transition");
					}
				}
			}
			pw.println("\t\t\tbreak;");

		}
		pw.println("\t\tdefault:");
		pw.println("\t\t\t// Should never get here");
		pw.println("\t\t}");
		pw.println("\t}");
	}


	/**
	 * @param pw
	 */
	private void printExternallyEnabledFunction(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Checks if the event is enabled by external");
		pw.println("\t * conditions such as input signal values.");
		pw.println("\t * @param eventIndex");
		pw.println("\t * @return <code>true</code> if the event is enabled.");
		pw.println("\t *         <code>false</code> otherwise.");
		pw.println("\t */");
		pw.println("\tstatic boolean eventIsExternallyEnabled(int eventIndex)");
		pw.println("\t{");
		pw.println("\t\t// An external condition can for example be: SensorValue(0) == 2");
		pw.println("\t\t// All external conditions are true by default.");
		pw.println("\t\tswitch (eventIndex)");
		pw.println("\t\t{");
		LabeledEvent event;
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			event = (LabeledEvent)alphIt.next();
			pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
			pw.println("\t\t\treturn true;");
		}
		pw.println("\t\tdefault:");
		pw.println("\t\t\t// Should never get here");
		pw.println("\t\t\treturn false;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * @param pw
	 */
	private void printInternallyEnabledFunction(PrintWriter pw)
	{
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Checks if the event is enabled in the");
		pw.println("\t * current state of the automata");
		pw.println("\t * @param eventIndex");
		pw.println("\t * @return <code>true</code> if the event is enabled. ");
	    pw.println("\t *         <code>false</code> otherwise.");
		pw.println("\t */");
		pw.println("\tstatic boolean eventIsInternallyEnabled(int eventIndex)");
		pw.println("\t{");
		pw.println("\t\tswitch (eventIndex)");
		pw.println("\t\t{");
		LabeledEvent event;
		Automaton automaton;
		Alphabet alphabet;
		State state;
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext();)
		{
			event = (LabeledEvent)alphIt.next();
			pw.println("\t\tcase " + event.getSynchIndex() + ": // Event \"" + event.getLabel() + "\"");
			pw.print("\t\t\treturn ");

			boolean previousCondition = false;
			for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
			{
				automaton = (Automaton)autIt.next();
				alphabet = automaton.getAlphabet();

				if (syncType == SynchronizationType.Prioritized)
				{ // All automata that has this event as prioritized must be able to execute it
					if (alphabet.containsEqualEvent(event) && alphabet.isPrioritized(event))
					{ // Find all states that enables this event
					  // Use OR between states in the same automaton.
					  // Use AND between states in different automata.
						if (previousCondition)
							pw.print("\n\t\t\t\t\t&& ");
						else
							previousCondition = true;
						boolean previousState = false;
						pw.print("(");
						for (Iterator stateIt = automaton.statesThatEnableEventIterator(event.getLabel()); stateIt.hasNext();)
						{
							state = (State)stateIt.next();
							if (previousState)
								pw.print(" || ");
							else
								previousState = true;
							pw.print("currentState[" + automaton.getIndex() + "] == " + state.getSynchIndex());
						}
						if (!previousState)
							pw.print("false /* Automaton " + automaton.getIndex() + " */");
						pw.print(")");
					}
				}
				else
					assert false;
			}
			pw.println(";");
		}
		pw.println("\t\tdefault:");
		pw.println("\t\t\t// Should never get here");
		pw.println("\t\t\treturn false;");
		pw.println("\t\t}");
		pw.println("\t}");
	}

	/**
	 * Prints out constants
	 * @param pw
	 */
	private void printConstants(PrintWriter pw)
	{
		pw.println("\tstatic final int NO_EVENT_IS_SELECTED = -1;");
		pw.println("\tstatic final int NR_OF_EVENTS = " + allEvents.nbrOfEvents() + ";");
		pw.println("\tstatic final int NR_OF_AUTOMATA = " + theAutomata.nbrOfAutomata() + ";");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * Preferred scan cycle time in milliseconds.");
		pw.println("\t * The program executes continously if the real");
		pw.println("\t * scan cycle time is larger than this value.");
		pw.println("\t */");
		pw.println("\tstatic final int PREFERRED_SCAN_CYCLE_TIME = 0;");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * The enabled event that comes first in this array is executed.");
		pw.println("\t * The uncontrollable events has the highest priority");
		pw.println("\t */");
		pw.print("\tstatic final int[] EVENT_PRIORITY_QUEUE = new int[]{");
		boolean firstEventPrinted = false;
		for (Iterator alphIt = allEvents.uncontrollableEventIterator(); alphIt.hasNext();)
		{
			if (firstEventPrinted)
				pw.print(", ");
			pw.print(((LabeledEvent)alphIt.next()).getSynchIndex());
			firstEventPrinted = true;
		}
		for (Iterator alphIt = allEvents.controllableEventIterator(); alphIt.hasNext();)
		{
			if (firstEventPrinted)
				pw.print(", ");
			pw.print(((LabeledEvent)alphIt.next()).getSynchIndex());
			firstEventPrinted = true;
		}
		pw.println("};");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * A map from event index to event label. Is not used by default.");
		pw.println("\t */");
		pw.print("\tstatic final String[] EVENT_LABELS = new String[]{");
		firstEventPrinted = false;
		for (int i = 0; i < allEvents.nbrOfEvents(); ++i)
		{
			if (firstEventPrinted)
				pw.print(",\n\t\t\t");
			pw.print("\"" + allEvents.getEventWithIndex(i).getLabel() + "\"");
			firstEventPrinted = true;
		}
		pw.println("};");
		pw.println();
		pw.println("\t/**");
		pw.println("\t * This vector holds the current state.");
		pw.println("\t * The indices corresponds to automata.");
		pw.println("\t * The value of an element corresponds");
		pw.println("\t * to the state of that automaton.");
		pw.println("\t */");
		pw.println("\tstatic int[] currentState = new int[NR_OF_AUTOMATA];");
	}

}
