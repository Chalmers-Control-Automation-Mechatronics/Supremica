
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Knarrhogsgatan 10
 * SE-431 60 MOLNDAL
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.IO;

import java.io.PrintWriter;
import java.text.DateFormat;
import java.util.Date;
import java.util.Iterator;

import net.sourceforge.waters.config.Version;

import org.supremica.automata.Alphabet;
import org.supremica.automata.Arc;
import org.supremica.automata.Automata;
import org.supremica.automata.Automaton;
import org.supremica.automata.AutomatonType;
import org.supremica.automata.LabeledEvent;
import org.supremica.automata.State;


public class AutomataToSMV
	implements AutomataSerializer
{
	private final Automata theAutomata;
	private Alphabet allEvents;

	public AutomataToSMV(final Automata theAutomata)
//		throws Exception
	{
		this.theAutomata = theAutomata;
	}

	private void initialize()
	{
		allEvents = theAutomata.setIndices();
	}

	void printBeginProgram(final PrintWriter pw)
	{
		pw.println("-- This file is automatically generated from Supremica");
		pw.println("-- " + Version.getInstance().toString());
		pw.println("-- This file was generated at: " + DateFormat.getDateTimeInstance().format(new Date()));
		pw.println("-- The following automata are synchronized:");

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();

			pw.println("--    Automaton: " + currAutomaton.getName());
		}

		pw.println();
	}

	void printStateModule(final PrintWriter pw)
	{
		pw.println("MODULE state");
		pw.println("VAR");

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();
			final State initialState = currAutomaton.getInitialState();

			if (initialState == null)
			{
				throw new IllegalStateException("AutomataToSMV.printStateVariables: all automata must have an initial state");
			}

			final int currAutomatonIndex = currAutomaton.getSynchIndex();

			pw.print("\tq_" + currAutomatonIndex + " : {");

			for (final Iterator<State> stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				final State currState = stateIt.next();
				final int currStateIndex = currState.getSynchIndex();

				pw.print("q_" + currAutomatonIndex + "_" + currStateIndex);

				if (stateIt.hasNext())
				{
					pw.print(", ");
				}
			}

			pw.println("};" + " -- " + currAutomaton.getName());
		}

		pw.print("\tevent : {");

		for (final Iterator<?> alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			final LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			final int currEventIndex = currEvent.getIndex();

			pw.print("e_" + currEventIndex);

			if (alphIt.hasNext())
			{
				pw.print(", ");
			}
		}

		pw.println("};");
		pw.println();
	}

	void printAutomatonModule(final PrintWriter pw, final Automaton currAutomaton)
	{
		final int currAutomatonIndex = currAutomaton.getSynchIndex();

		pw.println("MODULE Automaton_" + currAutomatonIndex + "(s)");
		pw.println("ASSIGN");
		pw.println("\tnext(s.q_" + currAutomaton.getSynchIndex() + ") :=");
		pw.println("\t\tcase");

		for (final Iterator<State> stateIt = currAutomaton.stateIterator();
				stateIt.hasNext(); )
		{
			final State currState = stateIt.next();

			for (final Iterator<Arc> evIt = currState.outgoingArcsIterator(); evIt.hasNext(); )
			{
				final LabeledEvent currEvent = evIt.next().getEvent();

				pw.print("\t\t\t(s.event = e_" + currEvent.getIndex() + ") & ");
				pw.print("(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currState.getSynchIndex() + ") & ");
				pw.print("TRUE");    // Broadcast synchronization

				//pw.print(getEnableCondition(currEvent)); // Prioritized synchronization
				pw.print(" : ");

				final State nextState = currState.nextState(currEvent);

				pw.println("q_" + currAutomatonIndex + "_" + nextState.getSynchIndex() + ";");
			}
		}

		pw.println("\t\t\t1 : s.q_" + currAutomaton.getSynchIndex() + "; -- default");
		pw.println("\t\tesac;");
		pw.println();
	}

	void printAutomataModules(final PrintWriter pw)
	{
		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();

			printAutomatonModule(pw, currAutomaton);
		}
	}

	void printInitialStates(final PrintWriter pw)
	{
		pw.println("INIT");

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();
			final State initialState = currAutomaton.getInitialState();

			if (initialState == null)
			{
				throw new IllegalStateException("AutomataToSMV.printStateModule: all automata must have an initial state");
			}

			final int currAutomatonIndex = currAutomaton.getSynchIndex();
			final int initialStateIndex = initialState.getSynchIndex();

			pw.print("\tq_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + initialStateIndex + " ");

			if (autIt.hasNext())
			{
				pw.print("& ");
			}

			pw.println(" -- " + initialState.getName() + " in " + currAutomaton.getName());
		}

		pw.println();
	}

	void printMainModule(final PrintWriter pw)
	{
		pw.println("MODULE main");
		pw.println("VAR");
		pw.println("\ts: state;");

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();

			pw.println("\tAut_" + currAutomaton.getSynchIndex() + " : Automaton_" + currAutomaton.getSynchIndex() + "(s);");
		}

		pw.println();
		printSpecifications(pw);
	}

	String getEnableCondition(final LabeledEvent currEvent)
	{
		return getEnableCondition(currEvent, false, false);
	}

	String getEnableCondition(final LabeledEvent currEvent, final boolean filter, final boolean selectPlant)
	{
		final StringBuilder buff = new StringBuilder("(");
		boolean previousCondition = false;

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();

			// For example when checking for controllability
			// we want to be able to only build conditions based on plants or supervisors.
			// Note, that we do not make a difference between supervisor or plant.
			if (filter)
			{
				if (selectPlant &&!(currAutomaton.getType() == AutomatonType.PLANT))
				{
					continue;
				}

				if (!selectPlant &&!((currAutomaton.getType() == AutomatonType.SUPERVISOR) || (currAutomaton.getType() == AutomatonType.SPECIFICATION)))
				{
					continue;
				}
			}

			final Alphabet currAlphabet = currAutomaton.getAlphabet();
			final int currAutomatonIndex = currAutomaton.getSynchIndex();

			if (currAlphabet.containsEqualEvent(currEvent) && currAlphabet.isPrioritized(currEvent))
			{    // Find all states that enables this event

				// Use OR between states in the same automaton.
				// Use AND between states in different automata.
				if (previousCondition)
				{
					buff.append(" & ");
				}
				else
				{
					previousCondition = true;
				}

				boolean previousState = false;

				buff.append("(");

				for (final Iterator<?> stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel());
						stateIt.hasNext(); )
				{
					final State currState = (State) stateIt.next();
					final int currStateIndex = currState.getSynchIndex();

					if (previousState)
					{
						buff.append(" | ");
					}
					else
					{
						previousState = true;
					}

					buff.append("(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + ")");
				}

				if (!previousState)
				{
					buff.append(" FALSE ");
				}

				buff.append(")");
			}
		}

		buff.append(")");

		return buff.toString();
	}

	void printSpecifications(final PrintWriter pw)
	{
		printControllabilitySpecification(pw);
		printNonblockingSpecification(pw);
		printLivenessSpecification(pw);
		printAvoidanceOfForbiddenStates(pw);
	}

	// TODO: Fix this to work for prioritized events too
	void printControllabilitySpecification(final PrintWriter pw)
	{
		pw.println("-- Controllability verification");
		pw.print("SPEC AG (");

		boolean previousUncontrollableEvent = false;

		//Automata plantAutomata = theAutomata.getPlantAutomata();
		final Automata specSupAutomata = theAutomata.getSpecificationAndSupervisorAutomata();

		// Iterate over all uncontrollable events and find conditions for controllability
		for (final Iterator<LabeledEvent> evIt = allEvents.iterator(); evIt.hasNext(); )
		{
			final LabeledEvent currEvent = evIt.next();

			if (!currEvent.isControllable())
			{

				// A condition is only necessary if this event is included
				// in the supervisor/specification and is also prioritized
				// by at least one supervisor/spec
				if (specSupAutomata.isPrioritizedInAtleastOneAutomaton(currEvent))
				{
					if (previousUncontrollableEvent)
					{
						pw.print(" & ");
					}
					else
					{
						previousUncontrollableEvent = true;
					}

					pw.print("(");

					final String enableConditionPlant = getEnableCondition(currEvent, true, true);

					if (enableConditionPlant.equals(""))
					{

						// In this case the event can never be enabled in the plant
						// and thus it might not induce a controllability problem
						pw.print("TRUE)");

						continue;
					}

					pw.print(enableConditionPlant);

					// First find conditions for when this event is enabled in the plant
					//for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
					//{
					//      pw.print("(");
					//      Automaton currAutomaton = (Automaton)autIt.next();
					//
					//      pw.print(")");
					//}
					// When an event is enabled in the plant it must also be
					// enabled in the supervisor/specification
					pw.print(" -> ");

					String enableConditionSpecSup = getEnableCondition(currEvent, true, false);

					if (enableConditionSpecSup.equals(""))
					{
						enableConditionSpecSup = "FALSE";
					}

					pw.print(enableConditionSpecSup);

					//for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
					//{
					//      pw.print("(");
					//      Automaton currAutomaton = (Automaton)autIt.next();
					//
					//      pw.print(")");
					//}
					pw.print(")");
				}
			}
		}

		if (!previousUncontrollableEvent)
		{
			pw.print("TRUE");
		}

		pw.println(")");
		pw.println();
	}

	void printNonblockingSpecification(final PrintWriter pw)
	{
		pw.println("-- Nonblocking verification");
		pw.print("SPEC AG EF (");

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			pw.print("(");

			final Automaton currAutomaton = (Automaton) autIt.next();
			final int currAutomatonIndex = currAutomaton.getSynchIndex();
			boolean hasAcceptingState = false;
			boolean hasPreviousTerm = false;

			for (final Iterator<State> stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				final State currState = stateIt.next();

				if (currState.isAccepting() &&!currState.isForbidden())
				{
					hasAcceptingState = true;

					if (hasPreviousTerm)
					{
						pw.print(" | ");
					}

					hasPreviousTerm = true;

					pw.print("s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currState.getSynchIndex());
				}
			}

			if (!hasAcceptingState)
			{
				pw.print("FALSE");
			}

			pw.print(")");

			if (autIt.hasNext())
			{
				pw.print(" & ");
			}
		}

		pw.println(")");
		pw.println();
	}

	void printLivenessSpecification(final PrintWriter pw)
	{
		pw.println("-- Liveness verification");
		pw.print("SPEC AG (");

		boolean hasPreviousTerm = false;

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();
			final int currAutomatonIndex = currAutomaton.getSynchIndex();

			for (final Iterator<State> stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				final State currState = stateIt.next();
				final int currStateIndex = currState.getSynchIndex();

				if (hasPreviousTerm)
				{
					pw.print(" & ");
				}
				else
				{
					hasPreviousTerm = true;
				}

				pw.print("(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + " -> EF !(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + "))");
			}
		}

		pw.println(")");
		pw.println();
	}

	void printAvoidanceOfForbiddenStates(final PrintWriter pw)
	{
		pw.println("-- Avoidance of forbidden states verification");
		pw.print("SPEC AG (");

		boolean hasPreviousTerm = false;

		for (final Iterator<?> autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			final Automaton currAutomaton = (Automaton) autIt.next();
			final int currAutomatonIndex = currAutomaton.getSynchIndex();

			for (final Iterator<State> stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				final State currState = stateIt.next();
				final int currStateIndex = currState.getSynchIndex();

				if (currState.isForbidden())
				{
					if (hasPreviousTerm)
					{
						pw.print(" & ");
					}
					else
					{
						hasPreviousTerm = true;
					}

					pw.print("!(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + ")");
				}
			}
		}

		if (!hasPreviousTerm)
		{
			pw.print("TRUE");
		}

		pw.println(")");
		pw.println();
	}

	// MF This is the old way of doing it
	public void serializeSMV(final PrintWriter pw)
		throws Exception
	{
		// System.out.println("AutomataToSMV.serialize" + this.theAutomata.toString() + "\n)");
		initialize();
		printBeginProgram(pw);
		printStateModule(pw);
		printInitialStates(pw);
		printAutomataModules(pw);
		printMainModule(pw);
	}
	
	@Override
	public void serialize(PrintWriter pr)
		throws Exception
	{
		serializeSMV(pr);
	}

	@Override
	public void serialize(String fileName)
		throws Exception
	{
		final PrintWriter pw = new PrintWriter(fileName);
		serialize(pw);
		pw.close();
	}
}
