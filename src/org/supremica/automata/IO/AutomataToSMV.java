
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Haradsgatan 26A
 * 431 42 Molndal
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.IO;

import java.io.*;
import java.util.*;
import java.text.DateFormat;
import org.supremica.log.*;
import org.supremica.automata.*;
import org.supremica.automata.algorithms.SynchronizationType;
import org.supremica.automata.algorithms.AutomataSynchronizerHelper;

public class AutomataToSMV
{
	private static Logger logger = LoggerFactory.createLogger(AutomataToSMV.class);
	private Automata theAutomata;
	private AutomataSynchronizerHelper syncHelper;
	private SynchronizationType syncType = SynchronizationType.Prioritized;
	private Alphabet allEvents;

	public AutomataToSMV(Automata theAutomata)
		throws Exception
	{
		this.theAutomata = theAutomata;
	}

	private void initialize()
	{
		allEvents = theAutomata.setIndicies();
	}

	void printBeginProgram(PrintWriter pw)
	{
		pw.println("-- This file is automatically generated from Supremica");
		pw.println("-- Supremica version: " + org.supremica.Version.version());
		pw.println("-- This file was generated at: " + DateFormat.getDateTimeInstance().format(new Date()));
		pw.println("-- The following automata are synchronized:");

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();

			pw.println("--    Automaton: " + currAutomaton.getName());
		}

		pw.println();
	}

	void printStateModule(PrintWriter pw)
	{
		pw.println("MODULE state");
		pw.println("VAR");

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();
			State initialState = currAutomaton.getInitialState();

			if (initialState == null)
			{
				throw new IllegalStateException("AutomataToSMV.printStateVariables: all automata must have an initial state");
			}

			int currAutomatonIndex = currAutomaton.getSynchIndex();

			pw.print("\tq_" + currAutomatonIndex + " : {");

			for (StateIterator stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				State currState = stateIt.nextState();
				int currStateIndex = currState.getSynchIndex();

				pw.print("q_" + currAutomatonIndex + "_" + currStateIndex);

				if (stateIt.hasNext())
				{
					pw.print(", ");
				}
			}

			pw.println("};" + " -- " + currAutomaton.getName());
		}

		pw.print("\tevent : {");

		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.print("e_" + currEventIndex);

			if (alphIt.hasNext())
			{
				pw.print(", ");
			}
		}

		pw.println("};");
		pw.println();
	}

	void printAutomatonModule(PrintWriter pw, Automaton currAutomaton)
	{
		int currAutomatonIndex = currAutomaton.getSynchIndex();

		pw.println("MODULE Automaton_" + currAutomatonIndex + "(s)");
		pw.println("ASSIGN");
		pw.println("\tnext(s.q_" + currAutomaton.getSynchIndex() + ") :=");
		pw.println("\t\tcase");

		for (StateIterator stateIt = currAutomaton.stateIterator();
				stateIt.hasNext(); )
		{
			State currState = stateIt.nextState();

			for (EventIterator evIt = currAutomaton.outgoingEventsIterator(currState);
					evIt.hasNext(); )
			{
				LabeledEvent currEvent = (LabeledEvent) evIt.next();

				pw.print("\t\t\t(s.event = e_" + currEvent.getSynchIndex() + ") & ");
				pw.print("(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currState.getSynchIndex() + ") & ");
				pw.print("TRUE");    // Broadcast synchronization

				//pw.print(getEnableCondition(currEvent)); // Prioritized synchronization
				pw.print(" : ");

				State nextState = currState.nextState(currEvent);

				pw.println("q_" + currAutomatonIndex + "_" + nextState.getSynchIndex() + ";");
			}
		}

		pw.println("\t\t\t1 : s.q_" + currAutomaton.getSynchIndex() + "; -- default");
		pw.println("\t\tesac;");
		pw.println();
	}

	void printAutomataModules(PrintWriter pw)
	{
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();

			printAutomatonModule(pw, currAutomaton);
		}
	}

	void printInitialStates(PrintWriter pw)
	{
		pw.println("INIT");

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();
			State initialState = currAutomaton.getInitialState();

			if (initialState == null)
			{
				throw new IllegalStateException("AutomataToSMV.printStateModule: all automata must have an initial state");
			}

			int currAutomatonIndex = currAutomaton.getSynchIndex();
			int initialStateIndex = initialState.getSynchIndex();

			pw.print("\tq_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + initialStateIndex + " ");

			if (autIt.hasNext())
			{
				pw.print("& ");
			}

			pw.println(" -- " + initialState.getName() + " in " + currAutomaton.getName());
		}

		pw.println();
	}

	void printMainModule(PrintWriter pw)
	{
		pw.println("MODULE main");
		pw.println("VAR");
		pw.println("\ts: state;");

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();

			pw.println("\tAut_" + currAutomaton.getSynchIndex() + " : Automaton_" + currAutomaton.getSynchIndex() + "(s);");
		}

		pw.println();
		printSpecifications(pw);
	}

	String getEnableCondition(LabeledEvent currEvent)
	{
		return getEnableCondition(currEvent, false, false);
	}

	String getEnableCondition(LabeledEvent currEvent, boolean filter, boolean selectPlant)
	{
		StringBuffer buff = new StringBuffer("(");
		int currEventIndex = currEvent.getSynchIndex();
		boolean previousCondition = false;

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();

			// For example when checking for controllability
			// we want to be able to only build conditions based on plants or supervisors.
			// Note, that we do not make a difference between supervisor or plant.
			if (filter)
			{
				if (selectPlant &&!(currAutomaton.getType() == AutomatonType.Plant))
				{
					continue;
				}

				if (!selectPlant &&!((currAutomaton.getType() == AutomatonType.Supervisor) || (currAutomaton.getType() == AutomatonType.Specification)))
				{
					continue;
				}
			}

			Alphabet currAlphabet = currAutomaton.getAlphabet();
			int currAutomatonIndex = currAutomaton.getSynchIndex();

			if (currAlphabet.containsEqualEvent(currEvent) && currAlphabet.isPrioritized(currEvent))
			{    // Find all states that enables this event

				// Use OR between states in the same automaton.
				// Use AND between states in different automata.
				if (previousCondition)
				{
					buff.append(" & ");
				}
				else
				{
					previousCondition = true;
				}

				boolean previousState = false;

				buff.append("(");

				for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel());
						stateIt.hasNext(); )
				{
					State currState = (State) stateIt.next();
					int currStateIndex = currState.getSynchIndex();

					if (previousState)
					{
						buff.append(" | ");
					}
					else
					{
						previousState = true;
					}

					buff.append("(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + ")");
				}

				if (!previousState)
				{
					buff.append(" FALSE ");
				}

				buff.append(")");
			}
		}

		buff.append(")");

		return buff.toString();
	}

	void printSpecifications(PrintWriter pw)
	{
		printControllabilitySpecification(pw);
		printNonblockingSpecification(pw);
		printLivenessSpecification(pw);
		printAvoidanceOfForbiddenStates(pw);
	}

	// TODO: Fix this to work for prioritized events too
	void printControllabilitySpecification(PrintWriter pw)
	{
		pw.println("-- Controllability verification");
		pw.print("SPEC AG (");

		boolean previousUncontrollableEvent = false;

		//Automata plantAutomata = theAutomata.getPlantAutomata();
		Automata specSupAutomata = theAutomata.getSpecificationSupervisorAutomata();

		// Iterate over all uncontrollable events and find conditions for controllability
		for (EventIterator evIt = allEvents.iterator(); evIt.hasNext(); )
		{
			LabeledEvent currEvent = evIt.nextEvent();

			if (!currEvent.isControllable())
			{

				// A condition is only necessary if this event is included
				// in the supervisor/specification and is also prioritized
				// by at least one supervisor/spec
				if (specSupAutomata.isPrioritizedInAtleastOneAutomaton(currEvent))
				{
					if (previousUncontrollableEvent)
					{
						pw.print(" & ");
					}
					else
					{
						previousUncontrollableEvent = true;
					}

					pw.print("(");

					String enableConditionPlant = getEnableCondition(currEvent, true, true);

					if (enableConditionPlant.equals(""))
					{

						// In this case the event can never be enabled in the plant
						// and thus it might not induce a controllability problem
						pw.print("TRUE)");

						continue;
					}

					pw.print(enableConditionPlant);

					// First find conditions for when this event is enabled in the plant
					//for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
					//{
					//      pw.print("(");
					//      Automaton currAutomaton = (Automaton)autIt.next();
					//
					//      pw.print(")");
					//}
					// When an event is enabled in the plant it must also be
					// enabled in the supervisor/specification
					pw.print(" -> ");

					String enableConditionSpecSup = getEnableCondition(currEvent, true, false);

					if (enableConditionSpecSup.equals(""))
					{
						enableConditionSpecSup = "FALSE";
					}

					pw.print(enableConditionSpecSup);

					//for (Iterator autIt = theAutomata.iterator(); autIt.hasNext();)
					//{
					//      pw.print("(");
					//      Automaton currAutomaton = (Automaton)autIt.next();
					//
					//      pw.print(")");
					//}
					pw.print(")");
				}
			}
		}

		if (!previousUncontrollableEvent)
		{
			pw.print("TRUE");
		}

		pw.println(")");
		pw.println();
	}

	void printNonblockingSpecification(PrintWriter pw)
	{
		pw.println("-- Nonblocking verification");
		pw.print("SPEC AG EF (");

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			pw.print("(");

			Automaton currAutomaton = (Automaton) autIt.next();
			int currAutomatonIndex = currAutomaton.getSynchIndex();
			boolean hasAcceptingState = false;
			boolean hasPreviousTerm = false;

			for (StateIterator stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				State currState = stateIt.nextState();

				if (currState.isAccepting() &&!currState.isForbidden())
				{
					hasAcceptingState = true;

					if (hasPreviousTerm)
					{
						pw.print(" | ");
					}

					hasPreviousTerm = true;

					pw.print("s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currState.getSynchIndex());
				}
			}

			if (!hasAcceptingState)
			{
				pw.print("FALSE");
			}

			pw.print(")");

			if (autIt.hasNext())
			{
				pw.print(" & ");
			}
		}

		pw.println(")");
		pw.println();
	}

	void printLivenessSpecification(PrintWriter pw)
	{
		pw.println("-- Liveness verification");
		pw.print("SPEC AG (");

		boolean hasPreviousTerm = false;

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();
			int currAutomatonIndex = currAutomaton.getSynchIndex();

			for (StateIterator stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				State currState = stateIt.nextState();
				int currStateIndex = currState.getSynchIndex();

				if (hasPreviousTerm)
				{
					pw.print(" & ");
				}
				else
				{
					hasPreviousTerm = true;
				}

				pw.print("(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + " -> EF !(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + "))");
			}
		}

		pw.println(")");
		pw.println();
	}

	void printAvoidanceOfForbiddenStates(PrintWriter pw)
	{
		pw.println("-- Avoidance of forbidden states verification");
		pw.print("SPEC AG (");

		boolean hasPreviousTerm = false;

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();
			int currAutomatonIndex = currAutomaton.getSynchIndex();

			for (StateIterator stateIt = currAutomaton.stateIterator();
					stateIt.hasNext(); )
			{
				State currState = stateIt.nextState();
				int currStateIndex = currState.getSynchIndex();

				if (currState.isForbidden())
				{
					if (hasPreviousTerm)
					{
						pw.print(" & ");
					}
					else
					{
						hasPreviousTerm = true;
					}

					pw.print("!(s.q_" + currAutomatonIndex + " = q_" + currAutomatonIndex + "_" + currStateIndex + ")");
				}
			}
		}

		if (!hasPreviousTerm)
		{
			pw.print("TRUE");
		}

		pw.println(")");
		pw.println();
	}

	public void serializeSMV(PrintWriter pw)
		throws Exception
	{
		initialize();
		printBeginProgram(pw);
		printStateModule(pw);
		printInitialStates(pw);
		printAutomataModules(pw);
		printMainModule(pw);
	}
}
