
/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Haradsgatan 26A
 * 431 42 Molndal
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */
package org.supremica.automata.IO;

import org.supremica.util.SupremicaException;
import java.io.*;
import java.util.*;
import java.text.DateFormat;
import org.supremica.log.*;
import org.supremica.automata.*;
import org.supremica.automata.algorithms.SynchronizationType;
import org.supremica.automata.algorithms.AutomataSynchronizerHelper;

public class AutomataToC
{
	private static Logger logger = LoggerFactory.createLogger(AutomataToC.class);
	private Automata theAutomata;
	private AutomataSynchronizerHelper syncHelper;
	private SynchronizationType syncType = SynchronizationType.Prioritized;
	private Alphabet allEvents;

	public AutomataToC(Automata theAutomata)
		throws Exception
	{
		this.theAutomata = theAutomata;
	}

	private void initialize()
	{
		allEvents = theAutomata.setIndicies();
	}

	void printBeginProgram(PrintWriter pw)
	{
		pw.println("/*");
		pw.println("// This file is automatically generated from Supremica");
		pw.println("// Supremica version: " + org.supremica.Version.version());
		pw.println("// This file was generated at: " + DateFormat.getDateTimeInstance().format(new Date()));
		pw.println("// The following automata are synchronized:");

		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();

			pw.println("//    Automaton: " + currAutomaton.getName());
		}

		pw.println("*/");
		pw.println("\nint main(void)");
		pw.println("{");
	}

	void printEndProgram(PrintWriter pw)
	{
		pw.println("}");
	}

	void printEventVariables(PrintWriter pw)
	{

		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			printBooleanVariableDeclaration(pw, "e_" + currEventIndex, currEvent.getLabel() + (currEvent.isControllable()
																							   ? " controllable"
																							   : " uncontrollable"), "0");
		}

		printBooleanVariableDeclaration(pw, "enabledEvent", "True if a event is enabled, false otherwise", "0");
	}

	void printStateVariables(PrintWriter pw)
		throws Exception
	{
		for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
		{
			Automaton currAutomaton = (Automaton) autIt.next();
			State initialState = currAutomaton.getInitialState();

			if (initialState == null)
			{
				throw new SupremicaException("AutomataToC.printStateVariables: all automata must have an initial state");
			}

			int currAutomatonIndex = currAutomaton.getSynchIndex();
			int currStateIndex = initialState.getSynchIndex();

			printBooleanVariableDeclaration(pw, "q_" + currAutomatonIndex, initialState.getName() + " in " + currAutomaton.getName(), Integer.toString(currStateIndex));
		}
	}

	private void printBooleanVariableDeclaration(PrintWriter pw, String variableName, String comment, String initvalue)
	{
		pw.print("\tint " + variableName);

		if (initvalue != null)
		{
			pw.print(" = " + initvalue);
		}

		pw.print(";");

		if (comment != null)
		{
			pw.print(" // " + comment);
		}

		pw.println();
	}

	void printBeginScanCycle(PrintWriter pw)
	{
		pw.println("\n\tinitialize(); // Initialize the supervisor");
		pw.println("\n\t// Main scancycle");
		pw.println("\twhile (1)");
		pw.println("\t{");
	}

	void printEndScanCycle(PrintWriter pw)
	{
		pw.println("\t}");
	}

	/**
	 * Compute which events that are enabled
	 *
	 * The logic will be something like the following
	 *
	 * e_0 = (q_1_0 || q_1_1) && (q_2_3)
	 * e_1 = (q_1_2) && (q_2_1 || q_2_3)
	 *
	 * In Structured Text this will look like:
	 *
	 * e_0 := (q_1_0 OR q_1_1) AND (q_2_3);
	 * e_1 := (q_1_2) AND (q_2_1 OR q_2_3);
	 *
	 * In Instruction List this will look like:
	 *
	 * LD q_1_0
	 * OR q_1_1
	 * AND q_2_3
	 * ST e_0
	 * LD q_1_2
	 * AND( q_2_1
	 * OR q_2_3
	 * )
	 * ST e_1
	 */
	void printComputeEnabledEvents(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t\tenabledEvent = 0;");
		pw.println("\n\t\t// Compute the enabled events");

		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n\t\t// Enable condition for event \"" + currEvent.getLabel() + "\"");

			boolean previousCondition = false;

			pw.print("\t\te_" + currEventIndex + " = ");

			for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
			{
				Automaton currAutomaton = (Automaton) autIt.next();
				Alphabet currAlphabet = currAutomaton.getAlphabet();
				int currAutomatonIndex = currAutomaton.getSynchIndex();

				if (syncType == SynchronizationType.Prioritized)
				{    // All automata that has this event as prioritized must be able to execute it
					if (currAlphabet.containsEqualEvent(currEvent) && currAlphabet.isPrioritized(currEvent))
					{    // Find all states that enables this event

						// Use OR between states in the same automaton.
						// Use AND between states in different automata.
						if (previousCondition)
						{
							pw.print(" && ");
						}
						else
						{
							previousCondition = true;
						}

						boolean previousState = false;

						pw.print("(");

						for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel());
								stateIt.hasNext(); )
						{
							State currState = (State) stateIt.next();
							int currStateIndex = currState.getSynchIndex();

							if (previousState)
							{
								pw.print(" || ");
							}
							else
							{
								previousState = true;
							}

							pw.print("(q_" + currAutomatonIndex + " == " + currStateIndex + ")");
						}

						if (!previousState)
						{
							pw.print(" 0 ");
						}

						pw.print(")");
					}
				}
				else
				{
					throw new SupremicaException("Unsupported SynchronizationType");
				}
			}

			pw.println(";");
		}
	}

	void printComputeExternalEnabledEvents(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t\t// Compute the external enabled events");

		// Iterate over all events and compute which events that are externally enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n\t\t// Enable condition for event \"" + currEvent.getLabel() + "\"");
			pw.println("\t\tenabled_" + currEvent.getLabel() + "(e_" + currEventIndex + ");");
		}
	}

	void printInitializationFunction(PrintWriter pw)
		throws Exception
	{
		pw.println("\n// Intitialization function");
		pw.println("void initialize()");
		pw.println("{");
		pw.println("\t// Add initialization code here");
		pw.println("}");
	}

	void printComputeExternalEnabledEventsFunctions(PrintWriter pw)
		throws Exception
	{
		pw.println("\n// Functions for the external enabled events");
		pw.println("// Note that all labels must valid identifiers in C");

		// Iterate over all events and compute which events that are externally enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n// External enable condition for event \"" + currEvent.getLabel() + "\"");
			pw.println("void enabled_" + currEvent.getLabel() + "(int& e)");
			pw.println("{");
			pw.println("\t// Add a condition here, the default does not change anything. Example:");
			pw.println("\t// e = e && (SensorValue(0) == 2);");
			pw.println("}");
		}
	}

	void printDoEnabledEventsFunctions(PrintWriter pw)
		throws Exception
	{
		pw.println("\n// Functions for the external enabled events");
		pw.println("// Note that all labels must valid identifiers in C");

		// Iterate over all events and compute which events that are externally enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n// Action for event \"" + currEvent.getLabel() + "\"");
			pw.println("void do_" + currEvent.getLabel() + "()");
			pw.println("{");
			pw.println("\t// Add an action here, the default does not change anything. Example:");
			pw.println("\t// SetGlobalOutput(OUT_A, OUT_ON); // enable output A;");
			pw.println("}");
		}
	}

	void printComputeSingleEnabledEvent(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t\t// Make sure only one event is enabled");
		pw.println("\t\t// Priority is given to uncontrollable events");

		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.uncontrollableEventIterator();
				alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n\t\t// Enable condition for event \"" + currEvent.getLabel() + "\"");
			pw.println("\t\te_" + currEventIndex + " = " + "e_" + currEventIndex + " && !enabledEvent;");
			pw.println("\t\tenabledEvent = " + "enabledEvent || " + "e_" + currEventIndex + ";");
		}

		for (Iterator alphIt = allEvents.controllableEventIterator();
				alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n\t\t// Enable condition for event \"" + currEvent.getLabel() + "\"");
			pw.println("\t\te_" + currEventIndex + " = " + "e_" + currEventIndex + " && !enabledEvent;");
			pw.println("\t\tenabledEvent = " + "enabledEvent || " + "e_" + currEventIndex + ";");
		}
	}

	/**
	 * If self loop then do not do anything, else update state
	 *
	 * The logic will be something like the following
	 * if (e_0)
	 * {
	 *              (* Automaton 1 *)
	 *              if (q_1_0)
	 *              {
	 *                      q_1_1 = true;
	 *                      q_1_0 = false;
	 *              }
	 *              else if (q_1_2)
	 *              {
	 *                      q_1_0 = true;
	 *                      q_1_2 = false;
	 *              }
	 *
	 *              (* Automaton 2 *)
	 *
	 * }
	 * if (e_1)
	 * {
	 *              (* Automaton 1 *)
	 *              if (q_1_0)
	 *              {
	 *                      q_1_2 = true;
	 *                      q_1_0 = false;
	 *              }
	 *
	 *              (* Automaton 2 *)
	 *              if (q_2_0)
	 *              {
	 *                      q_2_2 = true;
	 *                      q_2_0 = false;
	 *              }
	 * }
	 *
	 * In Structured Text this will look like:
	 *
	 *
	 * IF (e_0)
	 * THEN
	 *              IF (q_1_0)
	 *              THEN
	 *                      q_1_1 := TRUE;
	 *                      q_1_0 := FALSE;
	 *              ELSIF (q_1_2)
	 *              THEN
	 *                      q_1_0 := TRUE;
	 *                      q_1_2 := FALSE;
	 *              END_IF;
	 * END_IF;
	 * IF (e_1)
	 * THEN
	 *              ...
	 * END_IF;
	 *
	 * In Instruction List this will look like:
	 *
	 * e_0:                 LD e_0
	 *                              JMPCN e_1
	 * e_0_q_1_0:   LD q_1_0
	 *                              JMPCN q_1_2_e_1_0
	 *                              S q_1_1 (* Note that the result register is true here *)
	 *                              R q_1_2
	 *                              JMP e_1
	 * e_1_q_1_2:   LD q_1_2
	 *                              JMPCN end_of_e_0
	 *                              S q_1_0
	 *                              R q_1_2
	 *                              JMP e_1
	 * e_1:                 LD e_1
	 * end_of_jumps:
	 */
	void printChangeStateTransitions(PrintWriter pw)
		throws Exception
	{
		pw.println("\n\t\t// Change state in the automata");
		pw.println("\t\t// It is in general not safe to have more than one event set to true at this point");

		// Iterate over all events and compute which events that are enabled
		for (Iterator alphIt = allEvents.iterator(); alphIt.hasNext(); )
		{
			LabeledEvent currEvent = (LabeledEvent) alphIt.next();
			int currEventIndex = currEvent.getSynchIndex();

			pw.println("\n\t\t// Transition for event \"" + currEvent.getLabel() + "\"");

			boolean previousCondition = false;

			pw.println("\t\tif (e_" + currEventIndex + ")");
			pw.println("\t\t{");
			pw.println("\t\t\tdo_" + currEvent.getLabel() + "();");

			for (Iterator autIt = theAutomata.iterator(); autIt.hasNext(); )
			{
				Automaton currAutomaton = (Automaton) autIt.next();
				Alphabet currAlphabet = currAutomaton.getAlphabet();
				int currAutomatonIndex = currAutomaton.getSynchIndex();

				if (currAlphabet.contains(currEvent.getLabel()))
				{
					LabeledEvent currAutomatonEvent = currAutomaton.getAlphabet().getEvent(currEvent.getLabel());

					if (currAutomatonEvent == null)
					{
						throw new SupremicaException("AutomataToIEC1131.printChangeTransitionsAsST: " + "Could not find " + currEvent.getLabel() + " in automaton " + currAutomaton.getName());
					}

					pw.println("\n\t\t\t// Transitions in " + currAutomaton.getName());

					boolean previousState = false;

					for (Iterator stateIt = currAutomaton.statesThatEnableEventIterator(currEvent.getLabel());
							stateIt.hasNext(); )
					{
						State currState = (State) stateIt.next();
						int currStateIndex = currState.getSynchIndex();
						State toState = currState.nextState(currAutomatonEvent);

						if (toState == null)
						{
							throw new SupremicaException("AutomataToIEC1131.printChangeTransitionsAsST: " + "Could not find the next state from state " + currState.getName() + " with label " + currEvent.getLabel() + " in automaton " + currAutomaton.getName());
						}

						int toStateIndex = toState.getSynchIndex();

						if (currState != toState)
						{
							if (!previousState)
							{
								pw.print("\t\t\tif");

								previousState = true;
							}
							else
							{
								pw.println("\t\t\t}");
								pw.print("\t\t\telse if");
							}

							pw.println(" (q_" + currAutomatonIndex + " == " + currStateIndex + ")");
							pw.println("\t\t\t{");

							//pw.println("\t\t\t\tq_" + currAutomatonIndex + "_" + toStateIndex + " = true;");
							//pw.println("\t\t\t\tq_" + currAutomatonIndex + "_" + currStateIndex + " = false;");
							pw.println("\t\t\t\tq_" + currAutomatonIndex + " = " + toStateIndex + ";");
						}
						else
						{
							pw.println("\t\t\t// q_" + currAutomatonIndex + "_" + currStateIndex + "  has e_" + currEventIndex + " as self loop, no transition");
						}
					}

					if (previousState)
					{
						pw.println("\t\t\t}");
					}
				}
			}

			pw.println("\t\t}");
		}
	}

	public void serialize(PrintWriter pw)
		throws Exception
	{
		initialize();
		printInitializationFunction(pw);
		printComputeExternalEnabledEventsFunctions(pw);
		printDoEnabledEventsFunctions(pw);
		printBeginProgram(pw);
		printEventVariables(pw);
		printStateVariables(pw);
		printBeginScanCycle(pw);
		printComputeEnabledEvents(pw);
		printComputeExternalEnabledEvents(pw);
		printComputeSingleEnabledEvent(pw);
		printChangeStateTransitions(pw);
		printEndScanCycle(pw);
		printEndProgram(pw);
	}
}
