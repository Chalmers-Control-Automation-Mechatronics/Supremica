/*
 * Supremica Software License Agreement
 *
 * The Supremica software is not in the public domain
 * However, it is freely available without fee for education,
 * research, and non-profit purposes.  By obtaining copies of
 * this and other files that comprise the Supremica software,
 * you, the Licensee, agree to abide by the following
 * conditions and understandings with respect to the
 * copyrighted software:
 *
 * The software is copyrighted in the name of Supremica,
 * and ownership of the software remains with Supremica.
 *
 * Permission to use, copy, and modify this software and its
 * documentation for education, research, and non-profit
 * purposes is hereby granted to Licensee, provided that the
 * copyright notice, the original author's names and unit
 * identification, and this permission notice appear on all
 * such copies, and that no charge be made for such copies.
 * Any entity desiring permission to incorporate this software
 * into commercial products or to use it for commercial
 * purposes should contact:
 *
 * Knut Akesson (KA), knut@supremica.org
 * Supremica,
 * Haradsgatan 26A
 * 431 42 Molndal
 * SWEDEN
 *
 * to discuss license terms. No cost evaluation licenses are
 * available.
 *
 * Licensee may not use the name, logo, or any other symbol
 * of Supremica nor the names of any of its employees nor
 * any adaptation thereof in advertising or publicity
 * pertaining to the software without specific prior written
 * approval of the Supremica.
 *
 * SUPREMICA AND KA MAKES NO REPRESENTATIONS ABOUT THE
 * SUITABILITY OF THE SOFTWARE FOR ANY PURPOSE.
 * IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 *
 * Supremica or KA shall not be liable for any damages
 * suffered by Licensee from the use of this software.
 *
 * Supremica is owned and represented by KA.
 */

package org.supremica.external.robotCoordination.robotstudioApp;

import org.supremica.external.comInterfaces.robotstudio_3_1.RobotStudio.*;
import org.supremica.log.*;

/**
 * A listener that listens throughout a simulation and generates spans.
 */
public class SpanGenerator
    extends SimulationListener
{
    private static Logger logger = LoggerFactory.createLogger(SpanGenerator.class);

    private IToolFrame tool0;
    private String pathName;

    /**
     * RS class that does transform calculations.
     */
    private RsUnitsUtility ruu = new RsUnitsUtility();

    /** The size of the box surrounding the tooltip. */
    private static final double BOXSIZE = 0.12;             // [m]
    /** The length of the cylinder surrounding the upper arm. */
    private static final double CYLINDERLENGTH = 1.1;       // [m]
    /** The radius of the cylinder surrounding the upper arm. */
    private static final double CYLINDERRADIUS = 0.06;      // [m]

    /** The margin that should be added to all sides of all ojbects. */
    private static final double MARGIN = 0.05;              // [m]

    /** The length of a step. */
    private static final double STEPSIZE = BOXSIZE * 3 / 4; // [m]

    private Transform oldTransform;
    private Part temp;
    private RSRobot theRobot;

    /**
     * The collection of span approximations for the current path
     */
    private IEntities spanEntities;

    public SpanGenerator(RSRobot theRobot, String pathName)
	throws Exception
    {
	this.theRobot = theRobot;
	this.pathName = pathName;

	/*
	  if (ruu == null)
	  {
	  ruu = new RsUnitsUtility();
	  }
	*/

	temp = RSRobotCell.addPart("Temp");
	spanEntities = temp.getEntities();

	// Create first cover
	tool0 = theRobot.getRobotStudioMechanism().getToolFrames().item(RSRobotCell.var("tool0"));
	oldTransform = transformCopy(tool0.getTransform());

	//createSpanEntity(oldTransform);
    }

    ////////////////////////////////////////////////
    // Events generated by RobotStudio.Simulation //
    ////////////////////////////////////////////////

    /**
     * Called on each time instant.
     */
    public void tick(double time)
    {
	// In each tick, examine if it is time to generate a new spanEntity
	try
	    {
		ITransform newTransform = tool0.getTransform();
		double dx = oldTransform.getX() - newTransform.getX();
		double dy = oldTransform.getY() - newTransform.getY();
		double dz = oldTransform.getZ() - newTransform.getZ();

		// If tool0 has moved far enough, create a new span approximation!
		if (Math.sqrt(dx * dx + dy * dy + dz * dz) > STEPSIZE)
		    {
			createSpanEntity(newTransform);

			oldTransform = transformCopy(newTransform);
		    }
	    }
	catch (Exception ex)
	    {
		logger.error("Error in RobotStudioLink.SpanGenerator.tick " + ex);
	    }
    }

    /**
     * Called when the simulation stops
     */
    public void stop()
    {
	// Generate the union of the spanEntities
	try
	    {
		// Create a final cover
		// createSpanEntity(tool0.getTransform());
		// IEntities spanEntities = spans.getEntities();
		IEntity unionEntity;

		// Only if there are at least two spanEntities
		if (spanEntities.getCount() >= 2)
		    {
			unionEntity = spanEntities.item(RSRobotCell.var(2));
			IPart oldPart = null;
			boolean shutup = false;

			for (int i = spanEntities.getCount(); i > 1; i--)
			    {
				IPart part = unionEntity.getParent();

				//logger.info("Joining " + unionEntity.getName() + " and " + spanEntities.item(RSRobotCell.var(1)).getName());
				try
				    {
					unionEntity = unionEntity.join(spanEntities.item(RSRobotCell.var(1)), false);
				    }
				catch (Exception ex)
				    {
					if (!shutup)
					    {
						logger.warn("Disjoint entities in span?");
						shutup = true;
					    }

					// logger.info("Problem when joining entities. Disjoint? " + ex);
					continue;
				    }

				//spans.addEntity(unionEntity);
				if (oldPart != null)
				    {
					oldPart.delete();
				    }

				oldPart = unionEntity.getParent();
			    }
		    }
		else
		    {
			// Only one spanEntity
			unionEntity = spanEntities.item(RSRobotCell.var(1));
		    }

		//spans.delete();
		unionEntity.setName(pathName + RSRobotCell.SPAN_SUFFIX);
		unionEntity.setColor(RSRobotCell.RS_BLUE);
		unionEntity.setRelativeTransparency((float) 0.9);

		IPart parent = unionEntity.getParent();

		//spans.setTransform(parent.getTransform());
		//unionEntity.setTransform(spans.getTransform());
		unionEntity.setTransform(ruu.uCSToWCS(unionEntity.getTransform()));
		theRobot.addEntityToSpans(unionEntity);
		parent.delete();

		// If there are elements left in temp, make them red!
		temp.setColor(RSRobotCell.RS_RED);
		temp.setRelativeTransparency((float) 0.9);
		RSRobotCell.station.getSelections().removeAll();
		if (temp.getEntities().getCount() > 0)
		    {
			logger.warn("RobotStudio struck problems when calculating the span for " +
				    theRobot.getName() + ". Do not trust the solution!");
		    }
		// If temp is empty, delete it!
		// temp.delete();
	    }
	catch (Exception ex)
	    {
		logger.error("Span uniting failed! " + ex);
	    }

	super.stop();
    }

    private Transform transformCopy(ITransform transform)
	throws Exception
    {
	Transform copy = new Transform();

	copy.setX(transform.getX());
	copy.setY(transform.getY());
	copy.setZ(transform.getZ());
	copy.setRx(transform.getRx());
	copy.setRy(transform.getRy());
	copy.setRz(transform.getRz());

	return copy;
    }

    private void createSpanEntity(ITransform transform)
	throws Exception
    {

	// Calculate box transform
	RSRobotCell.station.setUCS(tool0);

	ITransform boxTransform = ruu.wCSToUCS(transform);

	boxTransform.setX(boxTransform.getX() - BOXSIZE / 2 - MARGIN);
	boxTransform.setY(boxTransform.getY() - BOXSIZE / 2 - MARGIN);
	boxTransform.setZ(boxTransform.getZ() - BOXSIZE - MARGIN);

	boxTransform = ruu.uCSToWCS(boxTransform);

	// Calculate cylinder transform
	IPart upperArm = theRobot.getRobotStudioMechanism().getLinks().item(RSRobotCell.var("Link4")).getParts().item(RSRobotCell.var(1));

	RSRobotCell.station.setUCS(upperArm);

	ITransform cylinderTransform = ruu.wCSToUCS(upperArm.getTransform());

	cylinderTransform.setZ(cylinderTransform.getZ() + 1.195);
	cylinderTransform.setX(cylinderTransform.getX() - 0.25 - MARGIN);
	cylinderTransform.setRy(cylinderTransform.getRy() + Math.PI / 2);

	cylinderTransform = ruu.uCSToWCS(cylinderTransform);

	// Create cylinder around the upper arm
	temp.createSolidCylinder(cylinderTransform, CYLINDERRADIUS + MARGIN, CYLINDERLENGTH + 2 * MARGIN);

	// Create box around the tooltip
	temp.createSolidBox(boxTransform, BOXSIZE + 2 * MARGIN, BOXSIZE + 2 * MARGIN, BOXSIZE + 2 * MARGIN);
    }
}
