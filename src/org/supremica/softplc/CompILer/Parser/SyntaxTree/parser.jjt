options {
	  MULTI=true;
}



PARSER_BEGIN(parser)

package org.supremica.softplc.CompILer.Parser.SyntaxTree;
import java.io.*;
import org.supremica.softplc.CompILer.Parser.*;
import java.util.StringTokenizer;
public class parser
{


  public static void main(String args[])
  {
    try
    {
    parser t = new parser(new BufferedReader(new FileReader(new File(args[0]))));
    try {
      SimpleNode n = t.Start();
      n.dump("");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
	catch (Throwable e) {System.out.println("Unable to parse input " + e);}
  }
}


PARSER_END(parser)


SKIP :
{
 " "
| "\t"
| "\r"
| "\n"
}


SKIP :
{
	"(*" : WithinComment
}

<WithinComment> SKIP :
{
	"*)" : DEFAULT
}

<WithinComment> MORE :
{
	<~[]>
}



SimpleNode Start() :
{}
{
	(library_element_declaration())*

		<EOF>
  { return jjtThis; }
}


/*
 *  =====================================
 *  B.0 Programming model
 *  =====================================
 */


void library_element_declaration() #void :
{}
{
	//	data_type_declaration()
	//  | function_declaration()
	      function_block_declaration()
		| program_declaration()
	   //  | configuration_declaration()
}




/*
 *  =====================================
 *  B.1.1 Letters, digits and identifiers
 *  =====================================
 */


/*
 *  ===============
 *  B.1.2 Constants
 *  ===============
 */

void constant() #void :
{}
{
    numeric_literal() |
    character_string()
        //                | <time_literal>
        //                | <bit_string_literal>
        | boolean_literal()
        }



/*
 *  ==========================
 *  B.1.2.1   Numeric literals
 *  ==========================
 */

void numeric_literal() :
{
	Token t = null;
}
{
	(t = <integer_literal>  | t= <real_literal>)
		{
			jjtThis.setName(t.image);
		}
}

TOKEN: /*integer_literal*/
{
	<integer_literal: (<integer_type_name>  "#")? (  <signed_integer>
	                                               | <binary_integer>
                                                   | <octal_integer>
                                                   | <hex_integer> ) >
}



TOKEN: /* signed_integer */
{
	<signed_integer: ("+" | "-")? <integer> >
}


TOKEN : /* integer */
{
	< integer: <digit> (("_")? <digit>)* >
}



TOKEN: /* binary_integer */
{
	< binary_integer: "2#" <bit> (("_")? <bit>)* >
      | < #bit: "1" | "0" >
}


TOKEN: /* octal_integer */
{
	< octal_integer: "8#" <octal_digit> (("_")? <octal_digit>)* >
      | < #octal_digit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" >
}


TOKEN: /* hex_integer */
{
	< hex_integer: "16#" <hex_digit> (("_")? <hex_digit>)* >
      | < #hex_digit:  <digit> | "A" | "B" | "C" | "D" | "E" | "F" >
}



TOKEN: /* real_literal */
{
	<real_literal: ( <real_type_name> "#" )? <signed_integer> "." <integer> (<exponent>)* >
| < #exponent: ("E" | "e") ("+"|"-")? <integer> >
}



TOKEN: /* bit_string_literal */
{
	<bit_string_literal: (("BYTE" | "WORD" | "DWORD" | "LWORD") "#" )?
	                      (  <integer>
                           | <binary_integer>
                           | <octal_integer>
                           | <hex_integer>) >
}


void boolean_literal() :
{
	Token t;
}
{
    t = <bool_literal>
    {
        jjtThis.setName(t.image);
    }
}

TOKEN: /* bool_literal */
{
	< bool_literal: (("BOOL#")? ("1" | "0")) | "TRUE" | "FALSE" >
}


/*
 *  ===============================
 *  B.1.2.2  Character strings
 *  ===============================
 */


void character_string() :
{
	Token t;
}
{
	t = <single_byte_character_string> | t = <double_byte_character_string>
	{
        jjtThis.setName(t.image);
    }
}

TOKEN: /* single_byte_character_string */
{
	< single_byte_character_string: "'" (<single_byte_character_representation>)* "'" >
}


TOKEN: /* double_byte_character_string */
{
	< double_byte_character_string: "\"" (<double_byte_character_representation>)* "\"" >
}


TOKEN: /* single_byte_character_representation */
{
	< #single_byte_character_representation: <common_character_representation>
                                            | "$'" | "\"" | "$"
                                            | <hex_digit> <hex_digit> >
}


TOKEN: /* double_byte_character_representation */
{
	< #double_byte_character_representation: <common_character_representation>
                                            | "$\"" | "'" | "$"
                                            | <hex_digit> <hex_digit>
                                              <hex_digit> <hex_digit> >
}



TOKEN:  /* common_character_representation */
	/* Egna tillägg:
	 * " "
     * "å", ...
	 */

{
	< #common_character_representation: "!" | "#" |"%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" |  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "[" | "\\" | "]" | "^" | "_" | "`" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "{" | "|" | "}" | "~" | "$$" | "$L" | "$N" | "$P" | "$R" | "$T" | "$l" | "$n" | "$p" | "$r" | "$t" | " " | "å" | "ä" | "ö" | "Å" | "Ä" | "Ö">
}


/*
 *  ======================
 *  B.1.2.3 Time literals
 *  ======================
 */

void time_literal() :
{}
{
	duration() | time_of_day() | date() | date_and_time()
}



/*
 *  ===================
 *  B.1.2.3.1 Duration
 *  ===================
 */

void duration() :
{}
{
	("T" | "TIME") "#" ("-")? interval()
}


void interval() :
{}
{
	  LOOKAHEAD(3) days()
	| LOOKAHEAD(3) hours()
	| LOOKAHEAD(3) minutes()
	| LOOKAHEAD(3) seconds()
	| milliseconds()
}


void days() :
{}
{
	LOOKAHEAD(3) fixed_point() ("d") | <integer> ("d") ("_")? hours()
}


void fixed_point() :
{}
{
	<integer> ("." <integer>)?
}


void hours() :
{}
{
	LOOKAHEAD(3) fixed_point() ("h") | <integer> ("h") ("_")? minutes()
}


void minutes() :
{}
{
	LOOKAHEAD(3) fixed_point() ("m")  | <integer> ("m") ("_")? seconds()
}


void seconds() :
{}
{
	LOOKAHEAD(3) fixed_point() ("s") | <integer> ("s") ("_")? milliseconds()
}


void milliseconds() :
{}
{
	fixed_point() ("ms")
}



/*
 *  ================================
 *  B.1.2.3.2  Time of day and date
 *  ================================
 */

void time_of_day() :
{}
{
	("TIME_OF_DAY" | "TOD")  "#" daytime()
}


void daytime() :
{}
{
	day_hour() ":" day_minute() ":" day_second()
}


void day_hour() :
{}
{
	<integer>
}


void day_minute() :
{}
{
	<integer>
}


void day_second() :
{}
{
	fixed_point()
}


void date() :
{}
{
	("DATE#" | "D#") date_literal()
}


void date_literal() :
{}
{
	year() "-" month() "-" day()
}

void year() :
{}
{
	<integer>
}


void month() :
{}
{
	<integer>
}


void day() :
{}
{
	<integer>
}


void date_and_time() :
{}
{
	("DATE_AND_TIME" | "DT") "#" date_literal() "-" daytime()
}



/*
 *  ===================
 *  B.1.3   Data types
 *  ===================
 */

void data_type_name() :
{}
{
	non_generic_type_name() | <generic_type_name>
}


void non_generic_type_name() :
{}
{
	elementary_type_name() | derived_type_name()
}



/*
 *  ===============================
 *  B.1.3.1  Elementary data types
 *  ===============================
 */


Token elementary_type_name() :
{
	Token t;
}
{
    (     t=numeric_type_name()
        | t = <date_type_name>
        | t = <bit_string_type_name>
        | t = "STRING"
        | t = "WSTRING"
        | t = "TIME")

  {
	  jjtThis.setName(t.image);
	  return t;
  }
}



Token numeric_type_name() #void :
{Token t;}
{
	//	integer_type_name() | <real_type_name>
    (t = <integer_type_name> | t = <real_type_name>)
        {return t;}
}

TOKEN: /*integer_type_name*/
{
	<integer_type_name: "SINT" | "INT" | "DINT" | "LINT" | "USINT" | "UINT" | "UDINT" | "ULINT" >
}


TOKEN: /* real_type_name */
{
	< real_type_name: "REAL" | "LREAL" >
}


TOKEN: /* date_type_name */
{
	< date_type_name: "DATE" | "TIME_OF_DAY" | "TOD"  | "DATE_AND_TIME" | "DT" >
}


TOKEN: /* bit_string_type_name */
{
	< bit_string_type_name: "BOOL" | "BYTE" | "WORD" | "DWORD" | "LWORD" >
}


/*
 *  ============================
 *  B.1.3.2  Generic data types
 *  ============================
 */


TOKEN: /* generic_type_name */
{
	< generic_type_name: "ANY" | "ANY_DERIVED" | "ANY_ELEMENTARY" | "ANY_MAGNITUDE" | "ANY_NUM" | "ANY_REAL" | "ANY_INT" | "ANY_BIT" | "ANY_STRING" | "ANY_DATE" >
}




/*
 *  ============================
 *  B.1.3.3  Derived data types
 *  ============================
 */

void derived_type_name() :
{}
{
	LOOKAHEAD(2) single_element_type_name()
	| LOOKAHEAD(2) array_type_name()
	| LOOKAHEAD(2)structure_type_name()
	| string_type_name()
}

void single_element_type_name() :
{}
{
	LOOKAHEAD(2) simple_type_name()
	| LOOKAHEAD(2) subrange_type_name()
	| enumerated_type_name()
}

Token simple_type_name() :
{Token t;}
{
	t = <identifier>
	{
		jjtThis.setName(t.image);
		return t;
	}
}

void subrange_type_name() :
{}
{
	<identifier>
}

void enumerated_type_name() :
{}
{
	<identifier>
}

void array_type_name() :
{}
{
	<identifier>
}

void structure_type_name() :
{}
{
	<identifier>
}

void data_type_declaration() :
{}
{
	"TYPE" type_declaration() ";" (type_declaration() ";")* "END_TYPE"
}

void type_declaration() :
{}
{
	LOOKAHEAD(3) single_element_type_declaration()
	| LOOKAHEAD(3) array_type_declaration()
 	| LOOKAHEAD(3) structure_type_declaration()
	| string_type_declaration()
}

void single_element_type_declaration() :
{}
{
	LOOKAHEAD(3) simple_type_declaration()
	| LOOKAHEAD(3) subrange_type_declaration()
	| enumerated_type_declaration()
}

void simple_type_declaration() :
{}
{
	simple_type_name() ":" simple_spec_init()
}

Token simple_spec_init() :
{
	Token t;
}
{
	t = simple_specification() (":=" constant())?

	{
		jjtThis.setTypeName(t.image);
		return t;
	}
}

Token simple_specification() :
{
	Token t;
}
{
	(t = elementary_type_name() | t = simple_type_name())
		{
			jjtThis.setTypeName(t.image);
			return t;
		}
}

void subrange_type_declaration() :
{}
{
	subrange_type_name() ":" subrange_spec_init()
}

void subrange_spec_init() :
{}
{
	subrange_specification() (":=" <signed_integer>)?
}

void subrange_specification() :
{}
{
	<integer_type_name> "(" subrange() ")" | subrange_type_name()
}

void subrange() :
{}
{
	<signed_integer> ".." <signed_integer>
}

void enumerated_type_declaration() :
{}
{
	enumerated_type_name() ":" enumerated_spec_init()
}

void enumerated_spec_init() :
{}
{
	enumerated_specification() (":=" enumerated_value() )?
}

void enumerated_specification() :
{}
{
	( "(" enumerated_value() ("," enumerated_value())* ")" )
	| enumerated_type_name()
}

void enumerated_value() :
{}
{
	(LOOKAHEAD(2) enumerated_type_name() "#")? <identifier>
}

void array_type_declaration() :
{}
{
	array_type_name() ":" array_spec_init()
}

void array_spec_init() :
{}
{
	array_specification() (":=" array_initialization())?
}

void array_specification() :
{}
{
	array_type_name()
	| "ARRAY" "[" subrange() ("," subrange())* "]" "OF" non_generic_type_name()
}

void array_initialization() :
{}
{
	"[" array_initial_elements() ("," array_initial_elements())* "]"
}

void array_initial_elements() :
{}
{
	array_initial_element() | <integer> "(" (array_initial_element())? ")"
}

void array_initial_element() :
{}
{
	constant()
	| enumerated_value()
	| structure_initialization()
	| array_initialization()
}

void structure_type_declaration() :
{}
{
	structure_type_name() ":" structure_specification()
}

void structure_specification() :
{}
{
	structure_declaration() | initialized_structure()
}

void initialized_structure() :
{}
{
	structure_type_name() (":=" structure_initialization())?
}

void structure_declaration() :
{}
{
	"STRUCT" structure_element_declaration() ";"
	(structure_element_declaration() ";")* "END_STRUCT"
}

void structure_element_declaration() :
{}
{
	structure_element_name() ":"
	(LOOKAHEAD(3) simple_spec_init()
	 | LOOKAHEAD(3) subrange_spec_init()
	 | LOOKAHEAD(3) enumerated_spec_init()
	 | LOOKAHEAD(3) array_spec_init()
	 | initialized_structure() )
}

void structure_element_name() :
{}
{
	<identifier>
}

void structure_initialization() :
{}
{
	"(" structure_element_initialization()
	(","  structure_element_initialization())* ")"
}

void structure_element_initialization() :
{}
{
	structure_element_name() ":="
	(constant()
	 | enumerated_value()
	 | array_initialization()
	 | structure_initialization() )
}

void string_type_name() :
{}
{
	<identifier>
}

void string_type_declaration() :
{}
{
	string_type_name() ":"
	("STRING"|"WSTRING") ("[" <integer> "]")? (":=" character_string())?
}


/*
 *  =================
 *  B.1.4  Variables
 *  =================
 */


void variable() : //#void :
{
	Token  d = null;
	String s = null;
	String variable_name;
	String field_selector;
}
{
	(d = <direct_variable> | s = symbolic_variable())
	{
		if (d != null){
			jjtThis.setIsDirectVariable(true);
			jjtThis.setName(d.image);
		}
		else {
			jjtThis.setIsDirectVariable(false);
			StringTokenizer st = new StringTokenizer(s, ".");
			jjtThis.setName(st.nextToken());
			if (st.hasMoreTokens()) {
				jjtThis.setFieldSelector(st.nextToken());
			}
		}
	}
}


String symbolic_variable() #void :
{
	String m = null;
	Token  v = null;
}
{
	(  LOOKAHEAD(3) m = multi_element_variable()
       | LOOKAHEAD(3) v = variable_name()
	    )

	{
		if (m != null) {
			return m;
		} else {
			return v.image;
		}
	}

/* multi_element_variable ger left recursion-fel
	variable_name() | multi_element_variable()
*/
}


Token variable_name() ://#void:
{
	Token t;
}
{
	t = <identifier>
	{ jjtThis.setName(t.image); // used in var1_list()
      return t;                 // result used in variable()
    }
}



/*
 *  ========================================
 *  B.1.4.1  Directly represented variables
 *  ========================================
 */

TOKEN:
{
	<direct_variable: "%" <location_prefix> <size_prefix> <integer> ("." <integer>)* >
      | <#location_prefix : "I" | "Q" | "M">
// <NIL> ger varning, så ta bort den för tillfället
      | <#size_prefix: "X" | "B" | "W" | "D" | "L" >
}



/*
 *  =================================
 *  B.1.4.2  Multi-element variables
 *  =================================
 */


String multi_element_variable() :
{
	String varName;
}
{
	varName = structured_variable() // | array_variable()
	{
		return varName;
	}

}


void array_variable() :
{}
{
	subscripted_variable() subscript_list()
}


void subscripted_variable() :
{}
{
	symbolic_variable()
}


void subscript_list() :
{}
{
	"[" subscript() ("," subscript())* "]"
}


void subscript() :
{}
{
	"expression" //ska bort sen
//	expression()
}


String structured_variable() :
{
	Token r;
	Token f;
}
{
	//	t = record_variable() (LOOKAHEAD(2) "." record_variable())* "." field_selector()
	r = record_variable() "." f = field_selector()
	{
		return r.image + "." + f.image;
	}

}


Token record_variable() :
{
	Token t;
}
{
	t = variable_name()
	{
		return t;
	}
	// Ger left recursion-fel
	//	symbolic_variable()
}


Token field_selector() :
{
 Token t;
}
{
	t = <identifier>
	{
		jjtThis.setName(t.image);
		return t;
	}
}



/*
 *  ========================================
 *  B.1.4.3  Declaration and initialization
 *  ========================================
 */

void input_declarations() :
{}
{
	"VAR_INPUT" ("RETAIN" | "NON_RETAIN")?
	(input_declaration() ";")+ "END_VAR"
}

void input_declaration() :
{}
{
	LOOKAHEAD(3) var_init_decl() | edge_declaration()
}

void edge_declaration() :
{}
{
	var1_list() ":" ("BOOLR_EDGE" | "BOOLF_EDGE")
}

void var_init_decl() :
{}
{
	LOOKAHEAD(3) var1_init_decl()
	| LOOKAHEAD(3) array_var_init_decl()
	| LOOKAHEAD(3) structured_var_init_decl()
	| LOOKAHEAD(3) fb_name_decl()
		//fb_name_decl is unneccesary. function_block variables will
		//be parsed as temp_var_decl anyway, since there is no way to
		//distinguish between a function block name and a declared
		//data type name.
	| string_var_declaration()
}

void var1_init_decl() :
{
    String[] names;
	Token t;
}
{
	names = var1_list()

	 ":"
		//Måste fixa så att subrange... och enumerated... returnerar token, annars får man en varning om att t might not have been initialized.

		//	(LOOKAHEAD(3) t = simple_spec_init() | LOOKAHEAD(3) subrange_spec_init() | enumerated_spec_init())
		t = simple_spec_init()

	{
		jjtThis.setNames(names);
		jjtThis.setTypeName(t.image);
	}


}


String[] var1_list() :
{
    Token t;
}
{
	(
	 (t = variable_name() {jjtThis.addName(t.image);})
	 ("," t = variable_name() {jjtThis.addName(t.image);})*
	)
		{
			return jjtThis.getNames();
		}
}


void array_var_init_decl() :
{}
{
	var1_list() ":" array_spec_init()
}

void structured_var_init_decl() :
{}
{
	var1_list() ":" initialized_structure()
}

void fb_name_decl() :
{}
{
	fb_name_list() ":" function_block_type_name()
 	( ":=" structure_initialization() )?
}

void fb_name_list() :
{}
{
	fb_name() ("," fb_name())*
}

void fb_name() :
{Token t;}
{
    t=<identifier>
    {jjtThis.setName(t.image);}
}

void output_declarations() :
{}
{
	"VAR_OUTPUT" ("RETAIN" | "NON_RETAIN")?
	(var_init_decl() ";")+
	"END_VAR"
}

void input_output_declarations() :
{}
{
	"VAR_IN_OUT" var_declaration() ";" (var_declaration() ";")* "END_VAR"
}

void var_declaration() :
{}
{
	//fb_name_decl is unneccesary. function_block variables will
	//be parsed as temp_var_decl anyway, since there is no way to
	//distinguish between a function block name and a declared
	//data type name.
	LOOKAHEAD(3) temp_var_decl() | fb_name_decl()
}

void temp_var_decl() :
{}
{
	LOOKAHEAD(3) var1_declaration()
	| LOOKAHEAD(3) array_var_declaration()
	| LOOKAHEAD(3) structured_var_declaration()
	| string_var_declaration()
}

void var1_declaration() :
{}
{
	var1_list() ":"
	(LOOKAHEAD(2) simple_specification()
	| LOOKAHEAD(2) subrange_specification()
	| enumerated_specification() )
}

void array_var_declaration() :
{}
{
	var1_list() ":" array_specification()
}

void structured_var_declaration() :
{}
{
	var1_list() ":" structure_type_name()
}

void var_declarations() :
{}
{
	"VAR" ("CONSTANT")?  (var_init_decl() ";")+ "END_VAR"
}

void retentive_var_declarations() :
{}
{
	"VAR" "RETAIN" (var_init_decl() ";" )+ "END_VAR"
}

void located_var_declarations() :
{}
{
	"VAR" ("CONSTANT" | "RETAIN" | "NON_RETAIN")?
	located_var_decl() ";" (located_var_decl() ";")* "END_VAR"
}

void located_var_decl() :
{
	Token var = null;
	Token loc;

}
{
	(var = variable_name())? loc = location() ":" located_var_spec_init()

	{
		jjtThis.setVariableName(var.image);
		jjtThis.setLocation(loc.image);
    }

}

void external_var_declarations() :
{}
{
	"VAR_EXTERNAL" ("CONSTANT")? external_declaration() ";"
	(external_declaration() ";")* "END_VAR"
}

void external_declaration() :
{}
{
	global_var_name() ":"
	(LOOKAHEAD(2) simple_specification()
	| LOOKAHEAD(2) subrange_specification()
	| LOOKAHEAD(2) enumerated_specification()
	| LOOKAHEAD(2) array_specification()
	| LOOKAHEAD(2) structure_type_name()
	| function_block_type_name() )
}

void global_var_name() :
{}
{
	<identifier>
}

void global_var_declarations() :
{}
{
	"VAR_GLOBAL" ("CONSTANT" | "RETAIN")?
	global_var_decl() ";" (global_var_decl() ";")* "END_VAR"
}

void global_var_decl() :
{}
{
	global_var_spec() ":" (LOOKAHEAD(2) located_var_spec_init() | function_block_type_name())?
}

void global_var_spec() :
{}
{
	LOOKAHEAD(2) global_var_list() | (global_var_name())? location()
}

void located_var_spec_init() :
{}
{
	LOOKAHEAD(3) simple_spec_init()
	| LOOKAHEAD(3) subrange_spec_init()
	| LOOKAHEAD(3) enumerated_spec_init()
	| LOOKAHEAD(3) array_spec_init()
	| LOOKAHEAD(3) initialized_structure()
		| <single_byte_string_spec> //nothing parses this way?
	| <double_byte_string_spec> //nothing parses this way?
}

Token location() :
{
	Token loc;
}
{
	"AT"
	loc = <direct_variable>

	{
		jjtThis.setName(loc.image);
		return loc;
    }
}


void global_var_list() :
{}
{
	global_var_name() ("," global_var_name())*
}

void string_var_declaration() :
{}
{
	LOOKAHEAD(3) single_byte_string_var_declaration() | double_byte_string_var_declaration()
}

void single_byte_string_var_declaration() :
{}
{
	var1_list() ":" <single_byte_string_spec>
}

TOKEN: /* single_byte_string_spec */
{
	<single_byte_string_spec: "STRING" ("[" <integer> "]")? (":=" <single_byte_character_string> )?>
}

void double_byte_string_var_declaration() :
{}
{
	var1_list() ":" <double_byte_string_spec>
}

TOKEN: /* double_byte_string_spec */
{
	<double_byte_string_spec: "WSTRING" ("[" <integer> "]")? (":=" <double_byte_character_string> )? >
}

void incompl_located_var_declarations() :
{}
{
	"VAR" ("RETAIN"|"NON_RETAIN")?
	incompl_located_var_decl() ";" (incompl_located_var_decl() ";")* "END_VAR"
}

void incompl_located_var_decl() :
{}
{
	variable_name() incompl_location() ":" var_spec()
}

void incompl_location() :
{}
{
	"AT" "%" ("I" | "Q" | "M") "*"
}

void var_spec() :
{}
{
	LOOKAHEAD(2) simple_specification()
	| LOOKAHEAD(2) subrange_specification()
	| LOOKAHEAD(2) enumerated_specification()
	| LOOKAHEAD(2) array_specification()
	| structure_type_name()
	| "STRING" ("[" <integer> "]")?
	| "WSTRING" ("[" <integer> "]")?
}


/*
 *  ==================================
 *  B.1.5  Program organization units
 *  ==================================
 */


/*
 *  ===================
 *  B.1.5.1  Functions
 *  ===================
 */


void function_name() :
{}
{
	derived_function_name()
}


void derived_function_name() :
{}
{
	<identifier>
}

void function_declaration() :
{}
{
	"FUNCTION" derived_function_name() ":"
	(elementary_type_name() | derived_type_name())
	( io_var_declarations() | function_var_decls() )*
	function_body() "END_FUNCTION"
}

void io_var_declarations() :
{}
{
	input_declarations() | output_declarations() | input_output_declarations()
}

void function_var_decls() :
{}
{
	"VAR" ("CONSTANT")? var2_init_decl() ";" (var2_init_decl() ";")* "END_VAR"
}

void function_body() :
{}
{
	//	ladder_diagram()
	//	| function_block_diagram()
	instruction_list()
	//	| statement_list()
}

void var2_init_decl() :
{}
{
	LOOKAHEAD(3) var1_init_decl()
	| LOOKAHEAD(3) array_var_init_decl()
	| LOOKAHEAD(3) structured_var_init_decl()
	| string_var_declaration()
}


/*
 *  ========================
 *  B.1.5.2  Function blocks
 *  ========================
 */

void function_block_type_name() :
{}
{
	derived_function_block_name() // standard_function_block_name()
}

/*
 * void standard_function_block_name() :
 *	<as defined in 2.5.2.3>
 */

void derived_function_block_name() :
{Token t;}
{
	t = <identifier>
	{jjtThis.setName(t.image);}
}

void function_block_declaration() :
{}
{
	"FUNCTION_BLOCK" derived_function_block_name()
	( io_var_declarations() | other_var_declarations() )*
	function_block_body() "END_FUNCTION_BLOCK"
}

void other_var_declarations() :
{}
{
	LOOKAHEAD(3) external_var_declarations()
	| LOOKAHEAD(3) var_declarations()
	| LOOKAHEAD(3) retentive_var_declarations()
	| LOOKAHEAD(3) non_retentive_var_decls()
	| LOOKAHEAD(3) temp_var_decls()
	| incompl_located_var_declarations()
}

void temp_var_decls() :
{}
{
	"VAR_TEMP" temp_var_decl() ";" (temp_var_decl() ";")* "END_VAR"
}

void non_retentive_var_decls() :
{}
{
	"VAR" "NON_RETAIN" var_init_decl() ";" (var_init_decl() ";")* "END_VAR"
}

void function_block_body() :
{}
{
	//	sequential_function_chart()
	//	| ladder_diagram()
	//	| function_block_diagram()
	 instruction_list()
	//	| statement_list()
}


/*
 *  ===================
 *  B.1.5.3  Functions
 *  ===================
 */

void program_type_name() :
{Token t;}
{
	t = <identifier>
        {jjtThis.setName(t.image);}
}

void program_declaration() :
{}
{
	"PROGRAM"
    program_type_name()
            (  (io_var_declarations()
				/* Här behöves en kraftig lookahead för att skilja på
                   other_var och located_var */
                | LOOKAHEAD(6) other_var_declarations()
                | located_var_declarations()
                | program_access_decls()))*
            function_block_body()
	"END_PROGRAM"
}

void program_access_decls() :
{}
{
	"VAR_ACCESS"
    program_access_decl() ";" (program_access_decl() ";" )*
    "END_VAR"
}

void program_access_decl() :
{}
{
	access_name() ":" symbolic_variable() ":"
	non_generic_type_name() (direction() )?
}


/*
 *  ====================================
 *  B.1.7  Configuration elements
 *  ====================================
 */


void configuration_name() :
{}
{
	<identifier>
}

void resource_type_name() :
{}
{
	<identifier>
}

void configuration_declaration() :
{}
{
	"CONFIGURATION"
    configuration_name()
    (global_var_declarations())?
	  (single_resource_declaration()
    | (resource_declaration() (resource_declaration())*))
    (access_declarations())?
    (instance_specific_initializations())?
    "END_CONFIGURATION"
		}

void resource_declaration() :
{}
{
	"RESOURCE"
	resource_name() "ON" resource_type_name()
    (global_var_declarations())?
	single_resource_declaration()
    "END_RESOURCE"
}

void single_resource_declaration() :
{}
{
	(task_configuration() ";")*
	(program_configuration() ";")+
}

void resource_name() :
{}
{
	<identifier>
}

void access_declarations() :
{}
{
	"VAR_ACCESS"
	(access_declaration() ";")+
	"END_VAR"
}

void access_declaration() :
{}
{
	access_name() ":" access_path() ":" non_generic_type_name() (direction())?
}

void access_path() :
{}
{
	(LOOKAHEAD(2) (LOOKAHEAD(2) resource_name() ".")?
	 <direct_variable> | (LOOKAHEAD(2) resource_name() ".")?)
    (LOOKAHEAD(2) program_name() ".")?
	(LOOKAHEAD(2) fb_name() ".")*
    symbolic_variable()
}

void global_var_reference() :
{}
{
    (LOOKAHEAD(2) resource_name() ".")? global_var_name() ("." structure_element_name())?
}

void access_name() :
{}
{
	<identifier>
}

void program_output_reference() :
{}
{
	program_name() "." symbolic_variable()
}

void program_name() :
{}
{
	<identifier>
}

void direction() :
{}
{
	"READ_WRITE" | "READ_ONLY"
}

void task_configuration() :
{}
{
	"TASK" task_name() task_initialization()
}

void task_name() :
{}
{
	<identifier>
}

void task_initialization() :
{}
{
	"("
	("SINGLE" ":=" data_source() ",")?
    ("INTERVAL" ":=" data_source() ",")?
    "PRIORITY" ":=" <integer>
    ")"
}

void data_source() :
{}
{
	  LOOKAHEAD(3) constant()
	| LOOKAHEAD(3) global_var_reference()
    | LOOKAHEAD(3) program_output_reference()
	| <direct_variable>
}

void program_configuration() :
{}
{
	"PROGRAM" ("RETAIN" | "NON_RETAIN")?
	program_name() ("WITH" task_name())? ":" program_type_name()
    ("(" prog_conf_elements() ")")?
}

void prog_conf_elements() :
{}
{
	prog_conf_element() ("," prog_conf_element())*
}

void prog_conf_element() :
{}
{
	LOOKAHEAD(2) fb_task() | prog_cnxn()
}

void fb_task() :
{}
{
	fb_name() "WITH" task_name()
}

void prog_cnxn() :
{}
{
	LOOKAHEAD(2) symbolic_variable() ":="
    prog_data_source() | symbolic_variable() "=>" data_sink()
}


void prog_data_source() :
{}
{
	  LOOKAHEAD(2) constant()
    | LOOKAHEAD(2) enumerated_value()
    | LOOKAHEAD(2) global_var_reference()
	| <direct_variable>
}

void data_sink() :
{}
{
	global_var_reference() | <direct_variable>
}

void instance_specific_initializations() :
{}
{
	"VAR_CONFIG"
	(instance_specific_init() ";")+
	"END_VAR"
}

void instance_specific_init() :
{}
{
	resource_name() "."
    program_name() "."
    (LOOKAHEAD(3) fb_name() ".")*
	(LOOKAHEAD(3) (variable_name()
     (location())? ":"
     located_var_spec_init()
    )
    | (fb_name() ":"
       function_block_type_name() ":=" structure_initialization())
    )
}

/*
 *  ====================================
 *  B.2  Language IL (Instruction List)
 *  ====================================
 */


/*
 *  =================================
 *  B.2.1  Instructions and operands
 *  =================================
 */


void instruction_list() #void :
{}
{
	(il_instruction())+
}


void il_instruction() #void :
{}
{

	/*
	 * En il_instruction kan vara något av tre saker:
     *  - endast en label()
     *  - en label() följd av en il_expression osv
     *  - en il_expression osv utan label()
     * Det går inte att skriva (label())? (il_expression())?
     * eftersom detta kan matchas av en tom sträng, vilket ger fel i javacc
     * Därför splittade vi il_instruction i två separata produktioner.
     *
	 * /Thomas
     *
     */

	 LOOKAHEAD(3) (label() ":")
   | (

	    ( LOOKAHEAD(2) label() ":")?

		(
		    il_expression()
		  | il_simple_operation()
		  | il_jump_operation()
		  | il_fb_call()
		  | il_return_operator()
        )
	  )

}


void label() :
{Token t;}
{
	t = <identifier>
	{
		jjtThis.setName(t.image);
	}

}


void il_simple_operation():
{
		Token t;
}
{
	( t = <il_simple_operator>  (LOOKAHEAD(2) il_operand())? )
		//   | ( function_name() (il_operand_list())? )

  {
    jjtThis.setName(t.image);
  }

}


void il_expression() :
{Token t;}
{
	t = <il_expr_operator>
		(LOOKAHEAD(2) il_operand())?  (LOOKAHEAD(2) simple_instr_list())?
		")"
	{jjtThis.setName(t.image);}
}


void il_jump_operation() :
{}
{
	il_jump_operator() label()
}


void il_fb_call() :
{}
{
    ( il_call_operator() | il_call_java_operator() )
        fb_name()
        ("("
         (
		  LOOKAHEAD(2) il_param_list()//?

		  | il_operand_list())//?)
         ")")?


}


//void il_formal_funct_call() :
//{}
//{
//	function_name() "(" <EOL> (<EOL>)* (il_param_list())? ")"
//}


void il_operand() #void :
{}
{
	 constant() | LOOKAHEAD(2) variable() | enumerated_value()
}


void il_operand_list() :
{}
{
	il_operand() ("," il_operand())*
}


void simple_instr_list() :
{}
{
	il_simple_instruction() (il_simple_instruction())*
}


void il_simple_instruction() :
{}
{
	(  LOOKAHEAD(2) il_simple_operation()
     | il_expression()
)//     | il_formal_funct_call())

}


void il_param_list() :
{}
{
	 ( LOOKAHEAD(4) il_param_instruction())* il_param_last_instruction()
}


void il_param_instruction() :
{}
{
	(  LOOKAHEAD(2) il_param_assignment() | il_param_out_assignment()) ","
}


void il_param_last_instruction() :
{}
{
	 (  LOOKAHEAD(2) il_param_assignment() | il_param_out_assignment())
}


void il_param_assignment() :
{}
{
	il_assign_operator()
		(  il_operand()
		   | ("("
			  simple_instr_list()
			  ")"
			  )
		   )
}

void il_param_out_assignment() :
{}
{
	il_assign_out_operator() variable()
}



/*
 *  =================
 *  B.2.2  Operators
 *  =================
 */



void il_assign_operator() :
{}
{
	variable_name() ":="
}


void il_assign_out_operator() :
{}
{
	("NOT")? variable_name() "=>"
}


void il_call_operator() :
{Token t;}
{
	t = <il_call_op>
	{jjtThis.setName(t.image);}
}

TOKEN:
{
	<il_call_op:
	  "CAL"
	| "CALC"
	| "CALCN">
}


void il_call_java_operator() :
{
	Token t;
}
{
	t = <il_call_java_op>
	{jjtThis.setName(t.image);}
}


TOKEN:
{
	<il_call_java_op: "CAL_JAVA" >
}



void il_return_operator() :
{ Token t;}
{
	t = <il_return_op>
		//	{jjtThis.setName(t.image);}
}
TOKEN:
{
	<il_return_op:
	  "RET"
	| "RETC"
	| "RETCN">
}

void il_jump_operator() :
{ Token t;}
{
	t = <il_jump_op>
	{jjtThis.setName(t.image);}
}
TOKEN:
{
	<il_jump_op:
	  "JMP"
	| "JMPC"
	| "JMPCN">
}



TOKEN:
{
	<il_expr_operator:
   	  "AND("
	| "&("
   	| "OR("
  	| "XOR("
 	| "ANDN("
    | "&N("
    | "ORN("
    | "XORN("
    | "ADD("
    | "SUB("
    | "MUL("
    | "DIV("
    | "MOD("
    | "GT("
    | "GE("
    | "EQ("
    | "LT("
    | "LE("
    | "NE(">
}


TOKEN :
{
	<il_simple_operator:
      "LD"
    | "LDN"
    | "ST"
    | "STN"
    | "NOT"
    | "S"
    | "R"
    | "S1"
    | "R1"
    | "CLK"
    | "CU"
    | "CD"
    | "PV"
    | "IN"
    | "PT"
    | "AND"
    | "&"
    | "OR"
    | "XOR"
    | "ANDN"
    | "&N"
    | "ORN"
    | "XORN"
    | "ADD"
    | "SUB"
    | "MUL"
    | "DIV"
    | "MOD"
    | "GT"
    | "GE"
    | "EQ"
    | "LT"
    | "LE"
    | "NE">
}


TOKEN: /* identifier */
{
	<identifier: (<letter> | ("_" <letter> | <digit>))  (("_")? (<letter> | <digit>))*>
     | < #digit: ["0"-"9"] >
     | < #letter: ["A"-"Z", "a"-"z"] >

}
