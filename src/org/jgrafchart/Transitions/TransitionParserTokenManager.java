/* Generated By:JJTree&JavaCC: Do not edit this line. TransitionParserTokenManager.java */
package org.jgrafchart.Transitions;

import java.io.*;

public class TransitionParserTokenManager
	implements TransitionParserConstants
{
	private static final int jjStopStringLiteralDfa_0(int pos, long active0)
	{
		switch (pos)
		{

		default :
			return -1;
		}
	}

	private static final int jjStartNfa_0(int pos, long active0)
	{
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
	}

	static private final int jjStopAtPos(int pos, int kind)
	{
		jjmatchedKind = kind;
		jjmatchedPos = pos;

		return pos + 1;
	}

	static private final int jjStartNfaWithStates_0(int pos, int kind, int state)
	{
		jjmatchedKind = kind;
		jjmatchedPos = pos;

		try
		{
			curChar = input_stream.readChar();
		}
		catch (java.io.IOException e)
		{
			return pos + 1;
		}

		return jjMoveNfa_0(state, pos + 1);
	}

	static private final int jjMoveStringLiteralDfa0_0()
	{
		switch (curChar)
		{

		case 10 :
			return jjStopAtPos(0, 3);

		case 33 :
			jjmatchedKind = 18;

			return jjMoveStringLiteralDfa1_0(0x2000L);

		case 38 :
			return jjStopAtPos(0, 10);

		case 40 :
			return jjStopAtPos(0, 19);

		case 41 :
			return jjStopAtPos(0, 20);

		case 60 :
			jjmatchedKind = 14;

			return jjMoveStringLiteralDfa1_0(0x10000L);

		case 61 :
			return jjMoveStringLiteralDfa1_0(0x1000L);

		case 62 :
			jjmatchedKind = 15;

			return jjMoveStringLiteralDfa1_0(0x20000L);

		case 124 :
			return jjStopAtPos(0, 11);

		default :
			return jjMoveNfa_0(3, 0);
		}
	}

	static private final int jjMoveStringLiteralDfa1_0(long active0)
	{
		try
		{
			curChar = input_stream.readChar();
		}
		catch (java.io.IOException e)
		{
			jjStopStringLiteralDfa_0(0, active0);

			return 1;
		}

		switch (curChar)
		{

		case 61 :
			if ((active0 & 0x1000L) != 0L)
			{
				return jjStopAtPos(1, 12);
			}
			else if ((active0 & 0x2000L) != 0L)
			{
				return jjStopAtPos(1, 13);
			}
			else if ((active0 & 0x10000L) != 0L)
			{
				return jjStopAtPos(1, 16);
			}
			else if ((active0 & 0x20000L) != 0L)
			{
				return jjStopAtPos(1, 17);
			}
			break;

		default :
			break;
		}

		return jjStartNfa_0(0, active0);
	}

	static private final void jjCheckNAdd(int state)
	{
		if (jjrounds[state] != jjround)
		{
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	static private final void jjAddStates(int start, int end)
	{
		do
		{
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		}
		while (start++ != end);
	}

	static private final void jjCheckNAddTwoStates(int state1, int state2)
	{
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	static private final void jjCheckNAddStates(int start, int end)
	{
		do
		{
			jjCheckNAdd(jjnextStates[start]);
		}
		while (start++ != end);
	}

	static private final void jjCheckNAddStates(int start)
	{
		jjCheckNAdd(jjnextStates[start]);
		jjCheckNAdd(jjnextStates[start + 1]);
	}

	static private final int jjMoveNfa_0(int startState, int curPos)
	{
		int[] nextStates;
		int startsAt = 0;

		jjnewStateCnt = 9;

		int i = 1;

		jjstateSet[0] = startState;

		int j, kind = 0x7fffffff;

		for (;;)
		{
			if (++jjround == 0x7fffffff)
			{
				ReInitRounds();
			}

			if (curChar < 64)
			{
				long l = 1L << curChar;

				MatchLoop:
				do
				{
					switch (jjstateSet[--i])
					{

					case 3 :
						if ((0x3ff000000000000L & l) != 0L)
						{
							if (kind > 7)
							{
								kind = 7;
							}

							jjCheckNAdd(2);
						}
						else if (curChar == 47)
						{
							jjCheckNAdd(4);
						}
						else if (curChar == 46)
						{
							if (kind > 4)
							{
								kind = 4;
							}

							jjCheckNAddTwoStates(0, 1);
						}
						break;

					case 0 :
						if (curChar != 46)
						{
							break;
						}

						if (kind > 4)
						{
							kind = 4;
						}

						jjCheckNAddTwoStates(0, 1);
						break;

					case 1 :
						if ((0x3ff400000000000L & l) == 0L)
						{
							break;
						}

						if (kind > 4)
						{
							kind = 4;
						}

						jjCheckNAdd(1);
						break;

					case 2 :
						if ((0x3ff000000000000L & l) == 0L)
						{
							break;
						}

						if (kind > 7)
						{
							kind = 7;
						}

						jjCheckNAdd(2);
						break;

					case 4 :
						if (curChar != 46)
						{
							break;
						}

						if (kind > 8)
						{
							kind = 8;
						}

						jjCheckNAddTwoStates(4, 5);
						break;

					case 5 :
						if ((0x3ff400000000000L & l) == 0L)
						{
							break;
						}

						if (kind > 8)
						{
							kind = 8;
						}

						jjCheckNAdd(5);
						break;

					case 7 :
						if (curChar != 46)
						{
							break;
						}

						if (kind > 9)
						{
							kind = 9;
						}

						jjCheckNAddTwoStates(7, 8);
						break;

					case 8 :
						if ((0x3ff400000000000L & l) == 0L)
						{
							break;
						}

						if (kind > 9)
						{
							kind = 9;
						}

						jjCheckNAdd(8);
						break;

					default :
						break;
					}
				}
				while (i != startsAt);
			}
			else if (curChar < 128)
			{
				long l = 1L << (curChar & 077);

				MatchLoop:
				do
				{
					switch (jjstateSet[--i])
					{

					case 3 :
						if ((0x7fffffe87fffffeL & l) != 0L)
						{
							if (kind > 4)
							{
								kind = 4;
							}

							jjCheckNAddTwoStates(0, 1);
						}
						else if (curChar == 92)
						{
							jjCheckNAdd(7);
						}
						break;

					case 0 :
						if ((0x7fffffe87fffffeL & l) == 0L)
						{
							break;
						}

						if (kind > 4)
						{
							kind = 4;
						}

						jjCheckNAddTwoStates(0, 1);
						break;

					case 1 :
						if ((0x7fffffe87fffffeL & l) == 0L)
						{
							break;
						}

						if (kind > 4)
						{
							kind = 4;
						}

						jjCheckNAdd(1);
						break;

					case 4 :
						if ((0x7fffffe87fffffeL & l) == 0L)
						{
							break;
						}

						if (kind > 8)
						{
							kind = 8;
						}

						jjCheckNAddTwoStates(4, 5);
						break;

					case 5 :
						if ((0x7fffffe87fffffeL & l) == 0L)
						{
							break;
						}

						if (kind > 8)
						{
							kind = 8;
						}

						jjCheckNAdd(5);
						break;

					case 6 :
						if (curChar == 92)
						{
							jjCheckNAdd(7);
						}
						break;

					case 7 :
						if ((0x7fffffe87fffffeL & l) == 0L)
						{
							break;
						}

						if (kind > 9)
						{
							kind = 9;
						}

						jjCheckNAddTwoStates(7, 8);
						break;

					case 8 :
						if ((0x7fffffe87fffffeL & l) == 0L)
						{
							break;
						}

						if (kind > 9)
						{
							kind = 9;
						}

						jjCheckNAdd(8);
						break;

					default :
						break;
					}
				}
				while (i != startsAt);
			}
			else
			{
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);

				MatchLoop:
				do
				{
					switch (jjstateSet[--i])
					{

					default :
						break;
					}
				}
				while (i != startsAt);
			}

			if (kind != 0x7fffffff)
			{
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}

			++curPos;

			if ((i = jjnewStateCnt) == (startsAt = 9 - (jjnewStateCnt = startsAt)))
			{
				return curPos;
			}

			try
			{
				curChar = input_stream.readChar();
			}
			catch (java.io.IOException e)
			{
				return curPos;
			}
		}
	}

	static final int[] jjnextStates = {};
	public static final String[] jjstrLiteralImages = { "", null, null, "\12",
														null, null, null,
														null, null, null,
														"\46", "\174",
														"\75\75", "\41\75",
														"\74", "\76",
														"\74\75", "\76\75",
														"\41", "\50", "\51", };
	public static final String[] lexStateNames = { "DEFAULT", };
	static final long[] jjtoToken = { 0x1fff99L, };
	static final long[] jjtoSkip = { 0x6L, };
	static private ASCII_CharStream input_stream;
	static private final int[] jjrounds = new int[9];
	static private final int[] jjstateSet = new int[18];
	static protected char curChar;

	public TransitionParserTokenManager(ASCII_CharStream stream)
	{
		if (input_stream != null)
		{
			throw new TokenMgrError("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", TokenMgrError.STATIC_LEXER_ERROR);
		}

		input_stream = stream;
	}

	public TransitionParserTokenManager(ASCII_CharStream stream, int lexState)
	{
		this(stream);

		SwitchTo(lexState);
	}

	static public void ReInit(ASCII_CharStream stream)
	{
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;

		ReInitRounds();
	}

	static private final void ReInitRounds()
	{
		int i;

		jjround = 0x80000001;

		for (i = 9; i-- > 0; )
		{
			jjrounds[i] = 0x80000000;
		}
	}

	static public void ReInit(ASCII_CharStream stream, int lexState)
	{
		ReInit(stream);
		SwitchTo(lexState);
	}

	static public void SwitchTo(int lexState)
	{
		if ((lexState >= 1) || (lexState < 0))
		{
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
		}
		else
		{
			curLexState = lexState;
		}
	}

	static private final Token jjFillToken()
	{
		Token t = Token.newToken(jjmatchedKind);

		t.kind = jjmatchedKind;

		String im = jjstrLiteralImages[jjmatchedKind];

		t.image = (im == null)
				  ? input_stream.GetImage()
				  : im;
		t.beginLine = input_stream.getBeginLine();
		t.beginColumn = input_stream.getBeginColumn();
		t.endLine = input_stream.getEndLine();
		t.endColumn = input_stream.getEndColumn();

		return t;
	}

	static int curLexState = 0;
	static int defaultLexState = 0;
	static int jjnewStateCnt;
	static int jjround;
	static int jjmatchedPos;
	static int jjmatchedKind;

	public static final Token getNextToken()
	{
		int kind;
		Token specialToken = null;
		Token matchedToken;
		int curPos = 0;

		EOFLoop:
		for (;;)
		{
			try
			{
				curChar = input_stream.BeginToken();
			}
			catch (java.io.IOException e)
			{
				jjmatchedKind = 0;
				matchedToken = jjFillToken();

				return matchedToken;
			}

			try
			{
				input_stream.backup(0);

				while ((curChar <= 32) && (0x100000200L & (1L << curChar)) != 0L)
				{
					curChar = input_stream.BeginToken();
				}
			}
			catch (java.io.IOException e1)
			{
				continue EOFLoop;
			}

			jjmatchedKind = 0x7fffffff;
			jjmatchedPos = 0;
			curPos = jjMoveStringLiteralDfa0_0();

			if (jjmatchedKind != 0x7fffffff)
			{
				if (jjmatchedPos + 1 < curPos)
				{
					input_stream.backup(curPos - jjmatchedPos - 1);
				}

				if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
				{
					matchedToken = jjFillToken();

					return matchedToken;
				}
				else
				{
					continue EOFLoop;
				}
			}

			int error_line = input_stream.getEndLine();
			int error_column = input_stream.getEndColumn();
			String error_after = null;
			boolean EOFSeen = false;

			try
			{
				input_stream.readChar();
				input_stream.backup(1);
			}
			catch (java.io.IOException e1)
			{
				EOFSeen = true;
				error_after = (curPos <= 1)
							  ? ""
							  : input_stream.GetImage();

				if ((curChar == '\n') || (curChar == '\r'))
				{
					error_line++;

					error_column = 0;
				}
				else
				{
					error_column++;
				}
			}

			if (!EOFSeen)
			{
				input_stream.backup(1);

				error_after = (curPos <= 1)
							  ? ""
							  : input_stream.GetImage();
			}

			throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
		}
	}
}
