//# -*- indent-tabs-mode: nil  c-basic-offset: 2 -*-
//###########################################################################
//# THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY A SCRIPT.
//# DO NOT EDIT.
//###########################################################################
//# Copyright (C) 2004-2020 Robi Malik
//###########################################################################
//# This file is part of Waters.
//# Waters is free software: you can redistribute it and/or modify it under
//# the terms of the GNU General Public License as published by the Free
//# Software Foundation, either version 2 of the License, or (at your option)
//# any later version.
//# Waters is distributed in the hope that it will be useful, but WITHOUT ANY
//# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
//# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
//# details.
//# You should have received a copy of the GNU General Public License along
//# with Waters. If not, see <http://www.gnu.org/licenses/>.
//#
//# Linking Waters statically or dynamically with other modules is making a
//# combined work based on Waters. Thus, the terms and conditions of the GNU
//# General Public License cover the whole combination.
//# In addition, as a special exception, the copyright holders of Waters give
//# you permission to combine Waters with code included in the standard
//# release of Supremica under the Supremica Software License Agreement (or
//# modified versions of such code, with unchanged license). You may copy and
//# distribute such a system following the terms of the GNU GPL for Waters and
//# the licenses of the other code concerned.
//# Note that people who make modified versions of Waters are not obligated to
//# grant this special exception for their modified versions; it is their
//# choice whether to do so. The GNU General Public License gives permission
//# to release a modified version without this exception; this exception also
//# makes it possible to release a modified version which carries forward this
//# exception.
//###########################################################################

package net.sourceforge.waters.model.module;

import java.awt.Color;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.sourceforge.waters.model.base.AbstractEqualityVisitor;
import net.sourceforge.waters.model.base.ComponentKind;
import net.sourceforge.waters.model.base.EventKind;
import net.sourceforge.waters.model.base.Proxy;
import net.sourceforge.waters.model.base.VisitorException;
import net.sourceforge.waters.model.expr.BinaryOperator;
import net.sourceforge.waters.model.expr.UnaryOperator;


/**
 * A visitor to compare module objects based on their contents.
 * The ModuleEqualityVisitor can be configured to respect or not to
 * respect geometry information found in some {@link Proxy}
 * objects, and to produce detailed diagnostic information when two
 * items are found to be not equal.
 *
 * @see AbstractEqualityVisitor
 * @author Robi Malik
 */

public class ModuleEqualityVisitor
  extends AbstractEqualityVisitor
  implements ModuleProxyVisitor
{

  //#########################################################################
  //# Constructor
  /**
   * Creates a new equality checker without diagnostic information.
   * @param  geo  A flag, indicating whether the equality checker
   *              should consider geometry information.
   *              If <CODE>true</CODE>, objects will be considered
   *              equal if their contents and geometry are equal,
   *              otherwise any geometry information will be ignored
   *              when checking for equality.
   */
  public ModuleEqualityVisitor(final boolean geo)
  {
    this(false, geo);
  }

  /**
   * Creates a new equality checker.
   * @param  diag A flag, indicating whether the equality checker
   *              should provide diagnostic information if items
   *              compared are found not to be equal. Diagnostic
   *              information can be retrieved using {@link
   *              AbstractEqualityVisitor#getDiagnostics()}.
   *              This is useful for testing and debugging, but it
   *              does have an impact on performance.
   * @param  geo  A flag, indicating whether the equality checker
   *              should consider geometry information.
   *              If <CODE>true</CODE>, objects will be considered
   *              equal if their contents and geometry are equal,
   *              otherwise any geometry information will be ignored
   *              when checking for equality.
   */
  public ModuleEqualityVisitor(final boolean diag, final boolean geo)
  {
    super (diag, geo);
    mHashCodeVisitor = ModuleHashCodeVisitor.getInstance(geo);
    mNonReportingEqualityVisitor =
      diag ? new ModuleEqualityVisitor(geo) : this;
  }


  //#########################################################################
  //# Overrides for net.sourceforge.waters.model.base.AbstractEqualityVisitor
  public ModuleHashCodeVisitor getHashCodeVisitor()
  {
    return mHashCodeVisitor;
  }
  public ModuleEqualityVisitor getNonReportingEqualityVisitor()
  {
    return mNonReportingEqualityVisitor;
  }


  //#########################################################################
  //# Interface net.sourceforge.waters.model.module.ModuleProxyVisitor
  public Boolean visitAliasProxy
    (final AliasProxy proxy)
    throws VisitorException
  {
    if (visitIdentifiedProxy(proxy)) {
      final AliasProxy expected = (AliasProxy) getSecondProxy();
      final ExpressionProxy expression1 = proxy.getExpression();
      final ExpressionProxy expression2 = expected.getExpression();
      if (!compareProxies(expression1, expression2)) {
        return false;
      }
      setSecondProxy(expected);
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitBinaryExpressionProxy
    (final BinaryExpressionProxy proxy)
    throws VisitorException
  {
    if (visitSimpleExpressionProxy(proxy)) {
      final BinaryExpressionProxy expected =
        (BinaryExpressionProxy) getSecondProxy();
      final BinaryOperator operator1 = proxy.getOperator();
      final BinaryOperator operator2 = expected.getOperator();
      if (!compareObjects(operator1, operator2)) {
        return reportAttributeMismatch("operator", operator1, operator2);
      }
      final SimpleExpressionProxy left1 = proxy.getLeft();
      final SimpleExpressionProxy left2 = expected.getLeft();
      if (!mNonReportingEqualityVisitor.equals(left1, left2)) {
        return reportAttributeMismatch("left subterm", left1, left2);
      }
      final SimpleExpressionProxy right1 = proxy.getRight();
      final SimpleExpressionProxy right2 = expected.getRight();
      if (!mNonReportingEqualityVisitor.equals(right1, right2)) {
        return reportAttributeMismatch("right subterm", right1, right2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitBoxGeometryProxy
    (final BoxGeometryProxy proxy)
    throws VisitorException
  {
    if (visitGeometryProxy(proxy)) {
      final BoxGeometryProxy expected = (BoxGeometryProxy) getSecondProxy();
      final Rectangle2D rectangle1 = proxy.getRectangle();
      final Rectangle2D rectangle2 = expected.getRectangle();
      if (!compareObjects(rectangle1, rectangle2)) {
        return reportAttributeMismatch("rectangle", rectangle1, rectangle2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitColorGeometryProxy
    (final ColorGeometryProxy proxy)
    throws VisitorException
  {
    if (visitGeometryProxy(proxy)) {
      final ColorGeometryProxy expected =
        (ColorGeometryProxy) getSecondProxy();
      final Set<Color> colorSet1 = proxy.getColorSet();
      final Set<Color> colorSet2 = expected.getColorSet();
      if (!compareObjects(colorSet1, colorSet2)) {
        return reportAttributeMismatch("colour set", colorSet1, colorSet2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitComponentProxy
    (final ComponentProxy proxy)
    throws VisitorException
  {
    return visitIdentifiedProxy(proxy);
  }

  public Boolean visitConditionalProxy
    (final ConditionalProxy proxy)
    throws VisitorException
  {
    if (visitNestedBlockProxy(proxy)) {
      final ConditionalProxy expected = (ConditionalProxy) getSecondProxy();
      final SimpleExpressionProxy guard1 = proxy.getGuard();
      final SimpleExpressionProxy guard2 = expected.getGuard();
      if (!mNonReportingEqualityVisitor.equals(guard1, guard2)) {
        return reportAttributeMismatch("guard", guard1, guard2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitConstantAliasProxy
    (final ConstantAliasProxy proxy)
    throws VisitorException
  {
    if (visitAliasProxy(proxy)) {
      final ConstantAliasProxy expected =
        (ConstantAliasProxy) getSecondProxy();
      final ScopeKind scope1 = proxy.getScope();
      final ScopeKind scope2 = expected.getScope();
      if (!compareObjects(scope1, scope2)) {
        return reportAttributeMismatch("scope", scope1, scope2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitEdgeProxy
    (final EdgeProxy proxy)
    throws VisitorException
  {
    if (visitProxy(proxy)) {
      final EdgeProxy expected = (EdgeProxy) getSecondProxy();
      final NodeProxy source1 = proxy.getSource();
      final NodeProxy source2 = expected.getSource();
      if (!compareReferences(source1, source2)) {
        return reportAttributeMismatch
            ("source node", source1.getName(), source2.getName());
      }
      final NodeProxy target1 = proxy.getTarget();
      final NodeProxy target2 = expected.getTarget();
      if (!compareReferences(target1, target2)) {
        return reportAttributeMismatch
            ("target node", target1.getName(), target2.getName());
      }
      final LabelBlockProxy labelBlock1 = proxy.getLabelBlock();
      final LabelBlockProxy labelBlock2 = expected.getLabelBlock();
      if (!compareProxies(labelBlock1, labelBlock2)) {
        return false;
      }
      final GuardActionBlockProxy guardActionBlock1 =
        proxy.getGuardActionBlock();
      final GuardActionBlockProxy guardActionBlock2 =
        expected.getGuardActionBlock();
      if (!compareProxies(guardActionBlock1, guardActionBlock2)) {
        return reportAttributeMismatch
            ("guard action block", guardActionBlock1, guardActionBlock2);
      }
      if (isRespectingGeometry()) {
        final SplineGeometryProxy geometry1 = proxy.getGeometry();
        final SplineGeometryProxy geometry2 = expected.getGeometry();
        if (!mNonReportingEqualityVisitor.equals(geometry1, geometry2)) {
          return reportAttributeMismatch("rendering information", geometry1, geometry2);
        }
        final PointGeometryProxy startPoint1 = proxy.getStartPoint();
        final PointGeometryProxy startPoint2 = expected.getStartPoint();
        if (!mNonReportingEqualityVisitor.equals(startPoint1, startPoint2)) {
          return reportAttributeMismatch("rendering information for the start point", startPoint1, startPoint2);
        }
        final PointGeometryProxy endPoint1 = proxy.getEndPoint();
        final PointGeometryProxy endPoint2 = expected.getEndPoint();
        if (!mNonReportingEqualityVisitor.equals(endPoint1, endPoint2)) {
          return reportAttributeMismatch("rendering information for the end point", endPoint1, endPoint2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitEnumSetExpressionProxy
    (final EnumSetExpressionProxy proxy)
    throws VisitorException
  {
    if (visitSimpleExpressionProxy(proxy)) {
      final EnumSetExpressionProxy expected =
        (EnumSetExpressionProxy) getSecondProxy();
      final List<SimpleIdentifierProxy> items1 = proxy.getItems();
      final List<SimpleIdentifierProxy> items2 = expected.getItems();
      if (!compareExpressionLists(items1, items2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitEventAliasProxy
    (final EventAliasProxy proxy)
    throws VisitorException
  {
    return visitAliasProxy(proxy);
  }

  public Boolean visitEventDeclProxy
    (final EventDeclProxy proxy)
    throws VisitorException
  {
    if (visitIdentifiedProxy(proxy)) {
      final EventDeclProxy expected = (EventDeclProxy) getSecondProxy();
      final EventKind kind1 = proxy.getKind();
      final EventKind kind2 = expected.getKind();
      if (!compareObjects(kind1, kind2)) {
        return reportAttributeMismatch("kind", kind1, kind2);
      }
      final boolean observable1 = proxy.isObservable();
      final boolean observable2 = expected.isObservable();
      if (observable1 != observable2) {
        return reportAttributeMismatch("observability status", observable1, observable2);
      }
      final ScopeKind scope1 = proxy.getScope();
      final ScopeKind scope2 = expected.getScope();
      if (!compareObjects(scope1, scope2)) {
        return reportAttributeMismatch("scope", scope1, scope2);
      }
      final List<SimpleExpressionProxy> ranges1 = proxy.getRanges();
      final List<SimpleExpressionProxy> ranges2 = expected.getRanges();
      if (!compareExpressionLists(ranges1, ranges2)) {
        return false;
      }
      final Map<String,String> attributes1 = proxy.getAttributes();
      final Map<String,String> attributes2 = expected.getAttributes();
      if (!compareAttributeMaps(attributes1, attributes2)) {
        return false;
      }
      if (isRespectingGeometry()) {
        final ColorGeometryProxy colorGeometry1 = proxy.getColorGeometry();
        final ColorGeometryProxy colorGeometry2 = expected.getColorGeometry();
        if (!mNonReportingEqualityVisitor.equals(colorGeometry1, colorGeometry2)) {
          return reportAttributeMismatch("colour information", colorGeometry1, colorGeometry2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitEventListExpressionProxy
    (final EventListExpressionProxy proxy)
    throws VisitorException
  {
    if (visitExpressionProxy(proxy)) {
      final EventListExpressionProxy expected =
        (EventListExpressionProxy) getSecondProxy();
      final List<Proxy> eventIdentifierList1 = proxy.getEventIdentifierList();
      final List<Proxy> eventIdentifierList2 =
        expected.getEventIdentifierList();
      if (!compareLists(eventIdentifierList1, eventIdentifierList2)) {
        return false;
      }
      setSecondProxy(expected);
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitExpressionProxy
    (final ExpressionProxy proxy)
    throws VisitorException
  {
    return visitProxy(proxy);
  }

  public Boolean visitForeachProxy
    (final ForeachProxy proxy)
    throws VisitorException
  {
    if (visitNestedBlockProxy(proxy)) {
      final ForeachProxy expected = (ForeachProxy) getSecondProxy();
      final String name1 = proxy.getName();
      final String name2 = expected.getName();
      if (!compareObjects(name1, name2)) {
        return reportAttributeMismatch("name of the dummy variable", name1, name2);
      }
      final SimpleExpressionProxy range1 = proxy.getRange();
      final SimpleExpressionProxy range2 = expected.getRange();
      if (!mNonReportingEqualityVisitor.equals(range1, range2)) {
        return reportAttributeMismatch("range", range1, range2);
      }
      final SimpleExpressionProxy guard1 = proxy.getGuard();
      final SimpleExpressionProxy guard2 = expected.getGuard();
      if (!mNonReportingEqualityVisitor.equals(guard1, guard2)) {
        return reportAttributeMismatch("guard", guard1, guard2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitFunctionCallExpressionProxy
    (final FunctionCallExpressionProxy proxy)
    throws VisitorException
  {
    if (visitSimpleExpressionProxy(proxy)) {
      final FunctionCallExpressionProxy expected =
        (FunctionCallExpressionProxy) getSecondProxy();
      final String functionName1 = proxy.getFunctionName();
      final String functionName2 = expected.getFunctionName();
      if (!compareObjects(functionName1, functionName2)) {
        return reportAttributeMismatch("function name", functionName1, functionName2);
      }
      final List<SimpleExpressionProxy> arguments1 = proxy.getArguments();
      final List<SimpleExpressionProxy> arguments2 = expected.getArguments();
      if (!compareExpressionLists(arguments1, arguments2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitGraphProxy
    (final GraphProxy proxy)
    throws VisitorException
  {
    if (visitProxy(proxy)) {
      final GraphProxy expected = (GraphProxy) getSecondProxy();
      final boolean deterministic1 = proxy.isDeterministic();
      final boolean deterministic2 = expected.isDeterministic();
      if (deterministic1 != deterministic2) {
        return reportAttributeMismatch("determinism status", deterministic1, deterministic2);
      }
      final LabelBlockProxy blockedEvents1 = proxy.getBlockedEvents();
      final LabelBlockProxy blockedEvents2 = expected.getBlockedEvents();
      if (!compareProxies(blockedEvents1, blockedEvents2)) {
        return reportAttributeMismatch
            ("list of blocked events", blockedEvents1, blockedEvents2);
      }
      final Set<NodeProxy> nodes1 = proxy.getNodes();
      final Set<NodeProxy> nodes2 = expected.getNodes();
      if (!compareCollections(nodes1, nodes2)) {
        return false;
      }
      final Collection<EdgeProxy> edges1 = proxy.getEdges();
      final Collection<EdgeProxy> edges2 = expected.getEdges();
      if (!compareCollections(edges1, edges2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitGroupNodeProxy
    (final GroupNodeProxy proxy)
    throws VisitorException
  {
    if (visitNodeProxy(proxy)) {
      final GroupNodeProxy expected = (GroupNodeProxy) getSecondProxy();
      final Set<NodeProxy> immediateChildNodes1 =
        proxy.getImmediateChildNodes();
      final Set<NodeProxy> immediateChildNodes2 =
        expected.getImmediateChildNodes();
      if (!compareRefCollections(immediateChildNodes1, immediateChildNodes2)) {
        return false;
      }
      if (isRespectingGeometry()) {
        final BoxGeometryProxy geometry1 = proxy.getGeometry();
        final BoxGeometryProxy geometry2 = expected.getGeometry();
        if (!mNonReportingEqualityVisitor.equals(geometry1, geometry2)) {
          return reportAttributeMismatch("geometric information", geometry1, geometry2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitGuardActionBlockProxy
    (final GuardActionBlockProxy proxy)
    throws VisitorException
  {
    if (visitProxy(proxy)) {
      final GuardActionBlockProxy expected =
        (GuardActionBlockProxy) getSecondProxy();
      final List<SimpleExpressionProxy> guards1 = proxy.getGuards();
      final List<SimpleExpressionProxy> guards2 = expected.getGuards();
      if (!compareExpressionLists(guards1, guards2)) {
        return false;
      }
      final List<BinaryExpressionProxy> actions1 = proxy.getActions();
      final List<BinaryExpressionProxy> actions2 = expected.getActions();
      if (!compareExpressionLists(actions1, actions2)) {
        return false;
      }
      if (isRespectingGeometry()) {
        final LabelGeometryProxy geometry1 = proxy.getGeometry();
        final LabelGeometryProxy geometry2 = expected.getGeometry();
        if (!mNonReportingEqualityVisitor.equals(geometry1, geometry2)) {
          return reportAttributeMismatch("geometry", geometry1, geometry2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitIdentifiedProxy
    (final IdentifiedProxy proxy)
    throws VisitorException
  {
    if (visitProxy(proxy)) {
      final IdentifiedProxy expected = (IdentifiedProxy) getSecondProxy();
      final IdentifierProxy identifier1 = proxy.getIdentifier();
      final IdentifierProxy identifier2 = expected.getIdentifier();
      if (!mNonReportingEqualityVisitor.equals(identifier1, identifier2)) {
        return reportAttributeMismatch("identifier defining the name", identifier1, identifier2);
      }
      setSecondProxy(expected);
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitIdentifierProxy
    (final IdentifierProxy proxy)
    throws VisitorException
  {
    return visitSimpleExpressionProxy(proxy);
  }

  public Boolean visitIndexedIdentifierProxy
    (final IndexedIdentifierProxy proxy)
    throws VisitorException
  {
    if (visitIdentifierProxy(proxy)) {
      final IndexedIdentifierProxy expected =
        (IndexedIdentifierProxy) getSecondProxy();
      final String name1 = proxy.getName();
      final String name2 = expected.getName();
      if (!compareObjects(name1, name2)) {
        return reportAttributeMismatch("name", name1, name2);
      }
      final List<SimpleExpressionProxy> indexes1 = proxy.getIndexes();
      final List<SimpleExpressionProxy> indexes2 = expected.getIndexes();
      if (!compareExpressionLists(indexes1, indexes2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitInstanceProxy
    (final InstanceProxy proxy)
    throws VisitorException
  {
    if (visitComponentProxy(proxy)) {
      final InstanceProxy expected = (InstanceProxy) getSecondProxy();
      final String moduleName1 = proxy.getModuleName();
      final String moduleName2 = expected.getModuleName();
      if (!compareObjects(moduleName1, moduleName2)) {
        return reportAttributeMismatch("module name", moduleName1, moduleName2);
      }
      final List<ParameterBindingProxy> bindingList1 = proxy.getBindingList();
      final List<ParameterBindingProxy> bindingList2 =
        expected.getBindingList();
      if (!compareLists(bindingList1, bindingList2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitIntConstantProxy
    (final IntConstantProxy proxy)
    throws VisitorException
  {
    if (visitSimpleExpressionProxy(proxy)) {
      final IntConstantProxy expected = (IntConstantProxy) getSecondProxy();
      final int value1 = proxy.getValue();
      final int value2 = expected.getValue();
      if (value1 != value2) {
        return reportAttributeMismatch("integer value", value1, value2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitLabelBlockProxy
    (final LabelBlockProxy proxy)
    throws VisitorException
  {
    if (visitEventListExpressionProxy(proxy)) {
      final LabelBlockProxy expected = (LabelBlockProxy) getSecondProxy();
      if (isRespectingGeometry()) {
        final LabelGeometryProxy geometry1 = proxy.getGeometry();
        final LabelGeometryProxy geometry2 = expected.getGeometry();
        if (!mNonReportingEqualityVisitor.equals(geometry1, geometry2)) {
          return reportAttributeMismatch("geometry", geometry1, geometry2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitLabelGeometryProxy
    (final LabelGeometryProxy proxy)
    throws VisitorException
  {
    if (visitGeometryProxy(proxy)) {
      final LabelGeometryProxy expected =
        (LabelGeometryProxy) getSecondProxy();
      final Point2D offset1 = proxy.getOffset();
      final Point2D offset2 = expected.getOffset();
      if (!compareObjects(offset1, offset2)) {
        return reportAttributeMismatch("offset", offset1, offset2);
      }
      final AnchorPosition anchor1 = proxy.getAnchor();
      final AnchorPosition anchor2 = expected.getAnchor();
      if (!compareObjects(anchor1, anchor2)) {
        return reportAttributeMismatch("anchor position", anchor1, anchor2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitModuleProxy
    (final ModuleProxy proxy)
    throws VisitorException
  {
    if (visitDocumentProxy(proxy)) {
      final ModuleProxy expected = (ModuleProxy) getSecondProxy();
      final List<ConstantAliasProxy> constantAliasList1 =
        proxy.getConstantAliasList();
      final List<ConstantAliasProxy> constantAliasList2 =
        expected.getConstantAliasList();
      if (!compareLists(constantAliasList1, constantAliasList2)) {
        return false;
      }
      final List<EventDeclProxy> eventDeclList1 = proxy.getEventDeclList();
      final List<EventDeclProxy> eventDeclList2 = expected.getEventDeclList();
      if (!compareNamedSets(eventDeclList1, eventDeclList2)) {
        return false;
      }
      final List<Proxy> eventAliasList1 = proxy.getEventAliasList();
      final List<Proxy> eventAliasList2 = expected.getEventAliasList();
      if (!compareLists(eventAliasList1, eventAliasList2)) {
        return false;
      }
      final List<Proxy> componentList1 = proxy.getComponentList();
      final List<Proxy> componentList2 = expected.getComponentList();
      if (!compareLists(componentList1, componentList2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitModuleSequenceProxy
    (final ModuleSequenceProxy proxy)
    throws VisitorException
  {
    if (visitDocumentProxy(proxy)) {
      final ModuleSequenceProxy expected =
        (ModuleSequenceProxy) getSecondProxy();
      final List<ModuleProxy> modules1 = proxy.getModules();
      final List<ModuleProxy> modules2 = expected.getModules();
      if (!compareLists(modules1, modules2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitNestedBlockProxy
    (final NestedBlockProxy proxy)
    throws VisitorException
  {
    if (visitProxy(proxy)) {
      final NestedBlockProxy expected = (NestedBlockProxy) getSecondProxy();
      final List<Proxy> body1 = proxy.getBody();
      final List<Proxy> body2 = expected.getBody();
      if (!compareLists(body1, body2)) {
        return false;
      }
      setSecondProxy(expected);
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitNodeProxy
    (final NodeProxy proxy)
    throws VisitorException
  {
    if (visitNamedProxy(proxy)) {
      final NodeProxy expected = (NodeProxy) getSecondProxy();
      final PlainEventListProxy propositions1 = proxy.getPropositions();
      final PlainEventListProxy propositions2 = expected.getPropositions();
      if (!compareProxies(propositions1, propositions2)) {
        return false;
      }
      final Map<String,String> attributes1 = proxy.getAttributes();
      final Map<String,String> attributes2 = expected.getAttributes();
      if (!compareAttributeMaps(attributes1, attributes2)) {
        return false;
      }
      setSecondProxy(expected);
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitParameterBindingProxy
    (final ParameterBindingProxy proxy)
    throws VisitorException
  {
    if (visitNamedProxy(proxy)) {
      final ParameterBindingProxy expected =
        (ParameterBindingProxy) getSecondProxy();
      final ExpressionProxy expression1 = proxy.getExpression();
      final ExpressionProxy expression2 = expected.getExpression();
      if (!compareProxies(expression1, expression2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitPlainEventListProxy
    (final PlainEventListProxy proxy)
    throws VisitorException
  {
    return visitEventListExpressionProxy(proxy);
  }

  public Boolean visitPointGeometryProxy
    (final PointGeometryProxy proxy)
    throws VisitorException
  {
    if (visitGeometryProxy(proxy)) {
      final PointGeometryProxy expected =
        (PointGeometryProxy) getSecondProxy();
      final Point2D point1 = proxy.getPoint();
      final Point2D point2 = expected.getPoint();
      if (!compareObjects(point1, point2)) {
        return reportAttributeMismatch("point", point1, point2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitQualifiedIdentifierProxy
    (final QualifiedIdentifierProxy proxy)
    throws VisitorException
  {
    if (visitIdentifierProxy(proxy)) {
      final QualifiedIdentifierProxy expected =
        (QualifiedIdentifierProxy) getSecondProxy();
      final IdentifierProxy baseIdentifier1 = proxy.getBaseIdentifier();
      final IdentifierProxy baseIdentifier2 = expected.getBaseIdentifier();
      if (!mNonReportingEqualityVisitor.equals(baseIdentifier1, baseIdentifier2)) {
        return reportAttributeMismatch("base identifier", baseIdentifier1, baseIdentifier2);
      }
      final IdentifierProxy componentIdentifier1 =
        proxy.getComponentIdentifier();
      final IdentifierProxy componentIdentifier2 =
        expected.getComponentIdentifier();
      if (!mNonReportingEqualityVisitor.equals(componentIdentifier1, componentIdentifier2)) {
        return reportAttributeMismatch("component identifier", componentIdentifier1, componentIdentifier2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitSimpleComponentProxy
    (final SimpleComponentProxy proxy)
    throws VisitorException
  {
    if (visitComponentProxy(proxy)) {
      final SimpleComponentProxy expected =
        (SimpleComponentProxy) getSecondProxy();
      final ComponentKind kind1 = proxy.getKind();
      final ComponentKind kind2 = expected.getKind();
      if (!compareObjects(kind1, kind2)) {
        return reportAttributeMismatch("kind", kind1, kind2);
      }
      final GraphProxy graph1 = proxy.getGraph();
      final GraphProxy graph2 = expected.getGraph();
      if (!compareProxies(graph1, graph2)) {
        return false;
      }
      final Map<String,String> attributes1 = proxy.getAttributes();
      final Map<String,String> attributes2 = expected.getAttributes();
      if (!compareAttributeMaps(attributes1, attributes2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitSimpleExpressionProxy
    (final SimpleExpressionProxy proxy)
    throws VisitorException
  {
    if (visitExpressionProxy(proxy)) {
      final SimpleExpressionProxy expected =
        (SimpleExpressionProxy) getSecondProxy();
      if (isRespectingGeometry()) {
        final String plainText1 = proxy.getPlainText();
        final String plainText2 = expected.getPlainText();
        if (!compareObjects(plainText1, plainText2)) {
          return reportAttributeMismatch("original text", plainText1, plainText2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitSimpleIdentifierProxy
    (final SimpleIdentifierProxy proxy)
    throws VisitorException
  {
    if (visitIdentifierProxy(proxy)) {
      final SimpleIdentifierProxy expected =
        (SimpleIdentifierProxy) getSecondProxy();
      final String name1 = proxy.getName();
      final String name2 = expected.getName();
      if (!compareObjects(name1, name2)) {
        return reportAttributeMismatch("name", name1, name2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitSimpleNodeProxy
    (final SimpleNodeProxy proxy)
    throws VisitorException
  {
    if (visitNodeProxy(proxy)) {
      final SimpleNodeProxy expected = (SimpleNodeProxy) getSecondProxy();
      final boolean initial1 = proxy.isInitial();
      final boolean initial2 = expected.isInitial();
      if (initial1 != initial2) {
        return reportAttributeMismatch("initial status", initial1, initial2);
      }
      if (isRespectingGeometry()) {
        final PointGeometryProxy pointGeometry1 = proxy.getPointGeometry();
        final PointGeometryProxy pointGeometry2 = expected.getPointGeometry();
        if (!mNonReportingEqualityVisitor.equals(pointGeometry1, pointGeometry2)) {
          return reportAttributeMismatch("geometric position", pointGeometry1, pointGeometry2);
        }
        final PointGeometryProxy initialArrowGeometry1 =
          proxy.getInitialArrowGeometry();
        final PointGeometryProxy initialArrowGeometry2 =
          expected.getInitialArrowGeometry();
        if (!mNonReportingEqualityVisitor.equals(initialArrowGeometry1, initialArrowGeometry2)) {
          return reportAttributeMismatch("position of the initial state arrow", initialArrowGeometry1, initialArrowGeometry2);
        }
        final LabelGeometryProxy labelGeometry1 = proxy.getLabelGeometry();
        final LabelGeometryProxy labelGeometry2 = expected.getLabelGeometry();
        if (!mNonReportingEqualityVisitor.equals(labelGeometry1, labelGeometry2)) {
          return reportAttributeMismatch("geometric position of the label", labelGeometry1, labelGeometry2);
        }
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitSplineGeometryProxy
    (final SplineGeometryProxy proxy)
    throws VisitorException
  {
    if (visitGeometryProxy(proxy)) {
      final SplineGeometryProxy expected =
        (SplineGeometryProxy) getSecondProxy();
      final List<Point2D> points1 = proxy.getPoints();
      final List<Point2D> points2 = expected.getPoints();
      if (!compareObjects(points1, points2)) {
        return reportAttributeMismatch("list of control points", points1, points2);
      }
      final SplineKind kind1 = proxy.getKind();
      final SplineKind kind2 = expected.getKind();
      if (!compareObjects(kind1, kind2)) {
        return reportAttributeMismatch("kind", kind1, kind2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitUnaryExpressionProxy
    (final UnaryExpressionProxy proxy)
    throws VisitorException
  {
    if (visitSimpleExpressionProxy(proxy)) {
      final UnaryExpressionProxy expected =
        (UnaryExpressionProxy) getSecondProxy();
      final UnaryOperator operator1 = proxy.getOperator();
      final UnaryOperator operator2 = expected.getOperator();
      if (!compareObjects(operator1, operator2)) {
        return reportAttributeMismatch("operator", operator1, operator2);
      }
      final SimpleExpressionProxy subTerm1 = proxy.getSubTerm();
      final SimpleExpressionProxy subTerm2 = expected.getSubTerm();
      if (!mNonReportingEqualityVisitor.equals(subTerm1, subTerm2)) {
        return reportAttributeMismatch("subterm", subTerm1, subTerm2);
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitVariableComponentProxy
    (final VariableComponentProxy proxy)
    throws VisitorException
  {
    if (visitComponentProxy(proxy)) {
      final VariableComponentProxy expected =
        (VariableComponentProxy) getSecondProxy();
      final SimpleExpressionProxy type1 = proxy.getType();
      final SimpleExpressionProxy type2 = expected.getType();
      if (!mNonReportingEqualityVisitor.equals(type1, type2)) {
        return reportAttributeMismatch("range", type1, type2);
      }
      final SimpleExpressionProxy initialStatePredicate1 =
        proxy.getInitialStatePredicate();
      final SimpleExpressionProxy initialStatePredicate2 =
        expected.getInitialStatePredicate();
      if (!mNonReportingEqualityVisitor.equals(initialStatePredicate1, initialStatePredicate2)) {
        return reportAttributeMismatch("initial state predicate", initialStatePredicate1, initialStatePredicate2);
      }
      final List<VariableMarkingProxy> variableMarkings1 =
        proxy.getVariableMarkings();
      final List<VariableMarkingProxy> variableMarkings2 =
        expected.getVariableMarkings();
      if (!compareLists(variableMarkings1, variableMarkings2)) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  public Boolean visitVariableMarkingProxy
    (final VariableMarkingProxy proxy)
    throws VisitorException
  {
    if (visitProxy(proxy)) {
      final VariableMarkingProxy expected =
        (VariableMarkingProxy) getSecondProxy();
      final IdentifierProxy proposition1 = proxy.getProposition();
      final IdentifierProxy proposition2 = expected.getProposition();
      if (!mNonReportingEqualityVisitor.equals(proposition1, proposition2)) {
        return reportAttributeMismatch("proposition event", proposition1, proposition2);
      }
      final SimpleExpressionProxy predicate1 = proxy.getPredicate();
      final SimpleExpressionProxy predicate2 = expected.getPredicate();
      if (!mNonReportingEqualityVisitor.equals(predicate1, predicate2)) {
        return reportAttributeMismatch("marking predicate", predicate1, predicate2);
      }
      return true;
    } else {
      return false;
    }
  }


  //#########################################################################
  //# Auxiliary Methods
  private boolean compareExpressionLists
    (final List<? extends Proxy> list,
     final List<? extends Proxy> expected)
  {
    final Iterator<? extends Proxy> iter1 = list.iterator();
    final Iterator<? extends Proxy> iter2 = expected.iterator();
    while (iter1.hasNext() && iter2.hasNext()) {
      final Proxy expr1 = iter1.next();
      final Proxy expr2 = iter2.next();
      if (!mNonReportingEqualityVisitor.equals(expr1, expr2)) {
        return reportItemMismatch(expr1, expr2);
      }
    }
    if (iter1.hasNext()) {
      return reportSuperfluousItem(iter1.next());
    } else if (iter2.hasNext()) {
      return reportMissingItem(iter2.next());
    } else {
      return true;
    }
  }


  //#########################################################################
  //# Data Members
  private final ModuleHashCodeVisitor mHashCodeVisitor;
  private final ModuleEqualityVisitor mNonReportingEqualityVisitor;

}
