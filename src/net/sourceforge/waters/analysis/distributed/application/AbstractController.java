package net.sourceforge.waters.analysis.distributed.application;

import java.util.Collection;

/**
 * An abstract implementation of the controller 
 * interface. Handles controller state and catching
 * exceptions generated by running the controller.
 * @author Sam Douglas
 */
public abstract class AbstractController implements Controller
{
  public final ControllerState getState()
  {
    return mControllerState;
  }


  public final Exception getException() throws IllegalStateException
  {
    if (getState() != ControllerState.EXCEPTION)
      {
	throw new IllegalStateException
	  ("Cannot call getException in a non-exception state");
      }
    else
      {
	assert (mException != null);
	return mException;
      }
  }


  /**
   * Store an exception and set the current state to EXCEPTION.
   * The exception must not be null.
   * @param e the exception to store.
   */
  protected final void setException(Exception e) 
    throws NullPointerException
  {
    if (e == null)
      throw new NullPointerException("Cannot store null exception");
    mException = e;
    setState(ControllerState.EXCEPTION);
  }


  private void setState(ControllerState state)
  {
    mControllerState = state;
  }

  
  public final void setJob(Job job) throws IllegalStateException
  {
    if (getState() != ControllerState.NOT_RUN)
      throw new IllegalStateException("Setting input job is only" +
				      " valid before controller is run");
    else
      mJob = job;
  }


  public final Job getJob()
  {
    return mJob;
  }

  public final JobResult getResult() throws IllegalStateException
  {
    if (getState() != ControllerState.COMPLETED)
      {
	throw new IllegalStateException("Getting result before job "+
					"has completed successfully is " +
					"invalid");
      }
    else
      {
	return mResult;
      }
  }

  /**
   * Sets the job result for this controller. The result is allowed to
   * be null.
   * @param result the job result
   */
  protected void setResult(JobResult result)
  {
    mResult = result;
  }

  public final void setNodes(Collection<Node> nodes)
    throws IllegalStateException
  {
    if (getState() != ControllerState.NOT_RUN)
      throw new IllegalStateException("Cannot set nodes in state " + getState());
    else
      mNodes = nodes;
  }


  public final Collection<Node> getNodes()
  {
    return mNodes;
  }

  
  public final void setControllerID(ControllerID id)
  {
    mControllerID = id;
  }

  public final ControllerID getControllerID()
  {
    return mControllerID;
  }

  public final void run()
  {
    //If the controller is running, then running it again has
    //no effect. Just return silently
    if (getState() == ControllerState.RUNNING)
      return;

    if (getState() != ControllerState.NOT_RUN)
      {
	setException(new IllegalStateException
		     (("Controller cannot be run from " 
		       + getState())));
      }

    try
      {
	setState(ControllerState.RUNNING);
	executeController();
	setState(ControllerState.COMPLETED);
      }
    catch (Exception e)
      {
	setException(e);
      }
  }

  /**
   * Perform the actual task for the controller. This method will be
   * called from the run() method. Exceptions that are thrown by this
   * method will be handled by run and the controller will go into the
   * exception state. If any clean-up needs to be done, then this
   * method should handle the exception, perform the cleanup, then
   * throw the exception again.  
   * <p> 
   * 
   * When this method returns normally, the controller state will be
   * set to COMPLETED, and any results should be available.
   * @throws Exception an exception to be handled.
   */
  protected abstract void executeController() throws Exception;

  private ControllerState mControllerState = 
    ControllerState.NOT_RUN;

  private Exception mException = null;
  private Job mJob = null;
  private JobResult mResult = null;
  private Collection<Node> mNodes = null;
  private ControllerID mControllerID;
}