//# -*- indent-tabs-mode: nil  c-basic-offset: 2 -*-
//###########################################################################
//# Copyright (C) 2004-2015 Robi Malik
//###########################################################################
//# This file is part of Waters.
//# Waters is free software: you can redistribute it and/or modify it under
//# the terms of the GNU General Public License as published by the Free
//# Software Foundation, either version 2 of the License, or (at your option)
//# any later version.
//# Waters is distributed in the hope that it will be useful, but WITHOUT ANY
//# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
//# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
//# details.
//# You should have received a copy of the GNU General Public License along
//# with Waters. If not, see <http://www.gnu.org/licenses/>.
//#
//# Linking Waters statically or dynamically with other modules is making a
//# combined work based on Waters. Thus, the terms and conditions of the GNU
//# General Public License cover the whole combination.
//# In addition, as a special exception, the copyright holders of Waters give
//# you permission to combine Waters with code included in the standard
//# release of Supremica under the Supremica Software License Agreement (or
//# modified versions of such code, with unchanged license). You may copy and
//# distribute such a system following the terms of the GNU GPL for Waters and
//# the licenses of the other code concerned.
//# Note that people who make modified versions of Waters are not obligated to
//# grant this special exception for their modified versions; it is their
//# choice whether to do so. The GNU General Public License gives permission
//# to release a modified version without this exception; this exception also
//# makes it possible to release a modified version which carries forward this
//# exception.
//###########################################################################

package net.sourceforge.waters.analysis.distributed.application;

import java.util.Collection;

/**
 * An abstract implementation of the controller 
 * interface. Handles controller state and catching
 * exceptions generated by running the controller.
 * @author Sam Douglas
 */
public abstract class AbstractController implements Controller
{
  public final ControllerState getState()
  {
    return mControllerState;
  }


  public final Exception getException() throws IllegalStateException
  {
    if (getState() != ControllerState.EXCEPTION)
      {
	throw new IllegalStateException
	  ("Cannot call getException in a non-exception state");
      }
    else
      {
	assert (mException != null);
	return mException;
      }
  }


  /**
   * Store an exception and set the current state to EXCEPTION.
   * The exception must not be null.
   * @param e the exception to store.
   */
  protected final void setException(Exception e) 
    throws NullPointerException
  {
    if (e == null)
      throw new NullPointerException("Cannot store null exception");
    mException = e;
    setState(ControllerState.EXCEPTION);
  }


  private void setState(ControllerState state)
  {
    mControllerState = state;
  }


  public final void setJob(Job job) throws IllegalStateException
  {
    if (getState() != ControllerState.NOT_RUN)
      throw new IllegalStateException("Setting input job is only" +
				      " valid before controller is run");
    else
      mJob = job;
  }


  public final Job getJob()
  {
    return mJob;
  }

  public final JobResult getResult() throws IllegalStateException
  {
    if (getState() == ControllerState.NOT_RUN)
      {
	throw new IllegalStateException("Getting result before job "+
					"has completed successfully is " +
					"invalid");
      }
    else
      {
	return mResult;
      }
  }

  /**
   * Sets the job result for this controller. The result is allowed to
   * be null.
   * @param result the job result
   */
  protected void setResult(JobResult result)
  {
    mResult = result;
  }

  public final void setNodes(Collection<Node> nodes)
    throws IllegalStateException
  {
    if (getState() != ControllerState.NOT_RUN)
      throw new IllegalStateException("Cannot set nodes in state " + getState());
    else
      mNodes = nodes;
  }


  public final Collection<Node> getNodes()
  {
    return mNodes;
  }


  public final void setControllerID(ControllerID id)
  {
    mControllerID = id;
  }

  public final ControllerID getControllerID()
  {
    return mControllerID;
  }

  public final void run()
  {
    //If the controller is running, then running it again has
    //no effect. Just return silently
    if (getState() == ControllerState.RUNNING)
      return;

    if (getState() != ControllerState.NOT_RUN)
      {
	setException(new IllegalStateException
		     (("Controller cannot be run from " 
		       + getState())));
      }

    try
      {
	setState(ControllerState.RUNNING);
	executeController();
	setState(ControllerState.COMPLETED);
      }
    catch (Exception e)
      {
	setException(e);
      }
  }

  /**
   * Perform the actual task for the controller. This method will be
   * called from the run() method. Exceptions that are thrown by this
   * method will be handled by run and the controller will go into the
   * exception state. If any clean-up needs to be done, then this
   * method should handle the exception, perform the cleanup, then
   * throw the exception again.  
   * <p> 
   * 
   * When this method returns normally, the controller state will be
   * set to COMPLETED, and any results should be available.
   * @throws Exception an exception to be handled.
   */
  protected abstract void executeController() throws Exception;

  private ControllerState mControllerState = 
    ControllerState.NOT_RUN;

  private Exception mException = null;
  private Job mJob = null;
  private JobResult mResult = null;
  private Collection<Node> mNodes = null;
  private ControllerID mControllerID;
}
