package net.sourceforge.waters.analysis;

import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import gnu.trove.TIntObjectHashMap;
import gnu.trove.TObjectIntHashMap;
import java.util.HashSet;
import java.util.Iterator;
import gnu.trove.TObjectIdentityHashingStrategy;
import java.util.Collections;
import java.util.Collection;
import net.sourceforge.waters.model.des.EventProxy;
import java.util.Set;
import java.util.ArrayList;
import gnu.trove.TObjectProcedure;
import java.util.PriorityQueue;
import gnu.trove.THashSet;

public class Annotations
{
  private static final Map<Merge, Annotation> INTERSECTIONS = 
                       new HashMap<Merge, Annotation>();
  private static final Map<MergeMed, Set<Annotation>> INTERSECTIONSMED = 
                       new HashMap<MergeMed, Set<Annotation>>();
  private static final Map<MergeLarge, Set<Annotation>> INTERSECTIONSLARGE = 
                       new HashMap<MergeLarge, Set<Annotation>>();
  private static final THashSet<Merge> ISNOTASUBSET = new THashSet<Merge>();
  private static final Map<Array, Annotation> ANNOTATIONS =
                       new HashMap<Array, Annotation>();
  private static final Map<Set<Annotation>, Set<Annotation>> ANNOTATIONSETS =
                       new HashMap<Set<Annotation>, Set<Annotation>>();
  private static final TObjectIntHashMap<Set<Annotation>> SETCOUNT =
                       new TObjectIntHashMap<Set<Annotation>>(
                       new TObjectIdentityHashingStrategy<Set<Annotation>>());

  private static Annotation ALLEVENTS = null;
  
  public static void setNumberOfEvents(Annotation allevents)
  {
    assert(ALLEVENTS == null);
    ALLEVENTS = allevents;
  }
  
  //TODO possibly store annotations as try
                       
  private Annotations()
  {
  }
  
  static private Annotation getCopyAn(Annotation annotation)
  {   
    Annotation res = ANNOTATIONS.get(annotation);
    if (res == null) {
      res = array;
      ANNOTATIONS.put(Annotation, res);
    }
    return res;
  }
  
  static private Set<Annotation> getCopySet(Set<Annotation> set)
  {
    Set<Annotation> res = ANNOTATIONSETS.get(set);
    if (res == null) {
      res = Collections.unmodifiableSet(set);
      ANNOTATIONSETS.put(res, res);
    }
    return res;
  }
  
  static private Set<Annotation> getSingleton(Annotation annotation)
  {
    annotation = getCopyAr(annotation);
    return getCopySet(Collections.singleton(annotation));
  }
  
  static public void clearCache()
  {
    INTERSECTIONS.clear();
    INTERSECTIONSMED.clear();
    INTERSECTIONSLARGE.clear();
    final Collection<Set<Annotation>> keys = 
      new ArrayList<Set<Annotation>>(SETCOUNT.size());
    SETCOUNT.forEachKey(new TObjectProcedure<Set<Annotation>>() {
      public boolean execute(Set<Annotation> set)
      {
        keys.add(set);
        return true;
      }
    });
    ANNOTATIONSETS.keySet().retainAll(keys);
    Set<Annotation> ans = new HashSet<Annotation>();
    for (Set<Annotation> ev : keys) {
      ans.addAll(ev);
    }
    ANNOTATIONS.keySet().retainAll(ans);
  }
  
  static private void register(Set<Annotation> set)
  {
    int count = SETCOUNT.get(set);
    count++;
    SETCOUNT.put(set, count);
  }
  
  static public void free(Set<Annotation> set)
  {
    int count = SETCOUNT.get(set);
    count--;
    assert(count >= 0);
    if (count != 0) {
      SETCOUNT.put(set, count);
    } else {
      SETCOUNT.remove(set);
    }
  }
  
  /**
   *  returns the intersection of an1 and an2
   */
  static public Annotation intersectEvents(Annotation annotation1,
                                           Annotation annotation2)
  {
    if (annotation1 == annotation2) {
      return annotation1;
    }
    EventProxy[] an1 = annotation1.mEvents;
    EventProxy[] an2 = annotation2.mEvents;
    Merge merge = new Merge(annotation1, annotation2);
    // if either is a subset of the other then the result of the merge will be
    // the smaller set
    Annotation an = INTERSECTIONS.get(merge);
    if (an != null) {
      return an;
    }
    int i1 = 0;
    int i2 = 0;
    int i3 = 0;
    EventProxy ar = new EventProxy[an1.length < an2.length ? an1.length : an2.length];
    while (i1 < an1.length && i2 < an2.length) {
      // if they equal then an1[i1] is contained in both so add an1[i1] to ar
      if (an1[i1] == an2[i2]) {
        ar[i3] = an1[i1];
        i1++;
        i2++;
        i3++;
        continue;
      }
      // anotations are kept sorted so increment the smaller of the two for
      // comparison
      if (an1[i1].compareTo(an2[i2]) > 0) {
        i2++;
      } else {
        i1++;
      }
    }
    Annotation result;
    // ar.length == i3 means that all of the smallest array went into ar in the
    // merge thus there is a subset
    if (ar.length == i3) {
      result = an1.length == i3 ? annotation1 : annotation2;
    } else {
      ISNOTASUBSET.add(merge);
      EventProxy[] t = new EventProxy[i3];
      for (int i = 0; i < i3; i++) {
        t[i] = ar[i];
      }
      ar = t;
      // we only want to have one copy of any annotation
      result = getCopyAn(new Annotation(ar, true));
    }
    INTERSECTIONS.put(merge, result);
    return result;
  }
  
  static public Annotation unionEvents(Annotation annotation1, 
                                       Annotation annotation2)
  {
    if (annotation1 == annotation2) {
      return annotation1;
    }
    EventProxy[] an1 = annotation1.mEvents;
    EventProxy[] an2 = annotation2.mEvents;
    Merge merge = new Merge(annotation1, annotation2);
    // if either is a subset of the other then the result of the merge will be
    // the smaller set
    Annotation an = INTERSECTIONS.get(merge);
    if (an != null) {
      return an;
    }
    int i1 = 0;
    int i2 = 0;
    int i3 = 0;
    EventProxy ar = new EventProxy[an1.length + an2.length];
    while (i1 < an1.length && i2 < an2.length) {
      // if they equal then an1[i1] is contained in both so add an1[i1] to ar
      if (an1[i1] == an2[i2]) {
        ar[i3] = an1[i1];
        i1++;
        i2++;
        i3++;
        continue;
      }
      // anotations are kept sorted so increment the smaller of the two for
      // comparison
      if (an1[i1].compareTo(an2[i2]) > 0) {
        ar[i3] = an2[i2];
        i3++;
        i2++;
      } else {
        ar[i3] = an1[i1];
        i3++;
        i1++;
      }
    }
    EventProxy[] left;
    int index;
    if (i1 < an1.length) {
      left = an1;
      index = i1;
    } else {
      left = an2;
      index = i2;
    }
    for (;index < left.length; index++) {
      ar[i3] = left[index];
      i3++;
    }
    Annotation result;
    if (i3 == an1.length) {
      // annotation1 is a subset of annotation2
      result = annotation1;
    } else if (i3 == an2.length) {
      // annotation2 is a subset of annotation2
      result = annotation2;
    } else {
      ISNOTASUBSET.add(merge);
    
      EventProxy[] t = new EventProxy[i3];
      for (int i = 0; i < t.length; i++) {
        t[i] = ar[i];
      }
      ar = t;
      // we only want to have one copy of any annotation
      result = getCopyAn(new Annotation(ar, false));
      if (ar.length * 2 >= ALLEVENTS.mEvents.length) {
        result = removeAll(ALLEVENTS, result);
      }
    }
    INTERSECTIONS.put(merge, result);
    return result;
  }
  
  static public Annotation removeAll(Annotation annotation1, 
                                     Annotation annotation2)
  {
    EventProxy[] an1 = annotation1.mEvents;
    EventProxy[] an2 = annotation2.mEvents;
    Merge merge = new Merge(annotation1, annotation2);
    // if either is a subset of the other then the result of the merge will be
    // the smaller set
    Annotation an = INTERSECTIONS.get(merge);
    if (an != null) {
      return an;
    }
    int i1 = 0;
    int i2 = 0;
    int i3 = 0;
    EventProxy ar = new EventProxy[an1.length];
    while (i1 < an1.length && i2 < an2.length) {
      // if they equal don't add in an1[i1]
      if (an1[i1] == an2[i2]) {
        i1++;
        i2++;
        continue;
      } else if (an1[i1].compareTo(an2[i2]) > 0) {
        // don't have to remove an2[i2]
        i2++;
      } else {
        //an1[i1] is not in an2
        ar[i3] = an1[i1];
        i3++;
        i1++;
      }
    }
    // put in the last of an1
    for (;i1 < an1.length; i1++) {
      ar[i3] = an1[i1];
      i3++;
    }
    Annotation result;
    if (i3 == an1.length) {
      // annotation1 is a subset of annotation2
      result = annotation1;
    } else {
      ISNOTASUBSET.add(merge);
      EventProxy[] t = new EventProxy[i3];
      for (int i = 0; i < t.length; i++) {
        t[i] = ar[i];
      }
      ar = t;
      // we only want to have one copy of any annotation
      result = getCopyAn(new Annotation(ar, true));
    }
    INTERSECTIONS.put(merge, result);
    return result;
  }
  
  public static boolean isSubsetIntersectEvents(Annotation annotation1,
                                                Annotation annotation2)
  {
    if (annotation1 == annotation2) {
      return true;
    }
    EventProxy[] an1 = annotation1.mEvents;
    EventProxy[] an2 = annotation2.mEvents;
    Merge merge = new Merge(annotation1, annotation2);
    if (ISNOTASUBSET.contains(merge)) {
      return false;
    } else if (INTERSECTIONS.get(Merge) == annotation1) {
      return true;
    }
    // for an1 to be a subset of an2 an1 must be smaller or exactly equal to an2
    // already determined not equal
    if (an1.length >= an2.length) {
      return false;
    }
    int i1 = 0;
    int i2 = 0;
    while (i1 < an1.length && i2 < an2.length) {
      if (an1.length - i1 > an2.length - i2) {
        ISNOTASUBSET.add(merge);
        return false;
      }
      if (an1[i1] == an2[i2]) {
        i1++;
        i2++;
        continue;
      }
      if (an1[i1].compareTo(an2[i2]) < 0) {
        ISNOTASUBSET.add(merge);
        return false;
      }
      i2++;
    }
    INTERSECTIONS.put(merge, annotation1);
    return true;
  }
  
  public static boolean isSubsetUnionEvents(Annotation annotation1,
                                            Annotation annotation2)
  {
    isSubsetIntersectEvents(annotation2, annotation1);
  }
  
  public static boolean isSubsetRemoveAll(Annotation annotation1,
                                          Annotation annotation2)
  {
    EventProxy[] an1 = annotation1.mEvents;
    EventProxy[] an2 = annotation2.mEvents;
    Merge merge = new Merge(annotation1, annotation2);
    if (ISNOTASUBSET.contains(merge)) {
      return false;
    } else if (INTERSECTIONS.get(Merge) == annotation1) {
      return true;
    }
    // for an1 to be a subset of an2 an1 must be smaller or exactly equal to an2
    // already determined not equal
    int i1 = 0;
    int i2 = 0;
    while (i1 < an1.length && i2 < an2.length) {
      if (an1[i1] == an2[i2]) {
        ISNOTASUBSET.add(merge);
        return false;
      }
      if (an1[i1].compareTo(an2[i2]) < 0) {
        i1++
      } else {
        i2++;
      }
    }
    INTERSECTIONS.put(merge, annotation1);
    return true;
  }
  
  private static Set<Annotation> mergeMed(Set<Annotation> anset, Annotation an2)
  {
    MergeMed merge = new MergeMed(anset, an);
    Set<Annotation> result = INTERSECTIONSMED.get(merge);
    if (result != null) {
      return result;
    }
    result = new HashSet<Annotation>();
    for (Annotation an1 : anset) {
      Annotation intersect = an1.intersect(an2);
      // TODO maybe this would be faster if done later and making certain that 
      // largest set done first
      if (removeSuperSets(result, intersect)) {
        result.add(intersect);
      }
    }
    //TODO don't think I need the getcopy here
    INTERSECTIONSMED.put(merge, result);
    return result;
  }
  
  private static Set<Annotation> mergeLarge(Set<Annotation> anset1,
                                            Set<Annotation> anset2)
  {
    MergeLarge merge = new MergeLarge(anset1, anset2);
    Set<EventProxy[]> result = INTERSECTIONSLARGE.get(merge);
    if (result != null) {
      register(result);
      return result;
    }
    //The Set with the higher setcount is more likely to be merge with things
    //thus more likely to be cached in intersectionsmed
    //TODO maybe better to go with set with most annotations
    if (SETCOUNT.get(anset1) > SETCOUNT.get(anset2)) {
      Set<EventProxy[]> temp = anset1;
      anset1 = anset2;
      anset2 = temp;
    }
    if (anset2.size() == 1) {
      Set<EventProxy[]> temp = anset1;
      anset1 = anset2;
      anset2 = temp;
    }
    Set<Annotation> toadd = new HashSet<EventProxy[]>();
    for (Annotation an : anset1) {
      Set<Annotation> intersectmed = mergeMed(anset2, an);
      if (result == null) {
        result = new HashSet<Annotation>(intersectmed);
      }
      //TODO instead of making a new set use an Iterator and it's remove method
      toadd.clear();
      for (Annotation intersect : intersectmed) {
        if (removeSuperSets(result, intersect)) {
          toadd.add(intersect);
        }
      }
      result.addAll(toadd);
    }
    result = getCopySet(result);
    INTERSECTIONSLARGE.put(merge, result);
    return result;
  }
  
  public static Set<Annotation> intersect(Collection<Set<Annotation>> sets)
  {
    // merge those with lots of instances first should hopefully use cache
    PriorityQueue<SetWrapper> queue = new PriorityQueue<SetWrapper>(sets.size());
    for (Set<Annotation> ev : sets) {
      queue.offer(new SetWrapper(ev));
    }
    while (queue.size() >= 2) {
      Set<Annotation> first = queue.poll().mSet;
      Set<Annotation> second = queue.poll().mSet;
      queue.offer(mergeLarge(first, second));
    }
    Set<Annotation> result = queue.poll().mSet;
    register(result);
    return result;
  }
  
  public static Set<Annotation> union(Collection<Set<Annotation>> set,
                                      Collection<Annotation> singleans)
  {
    //TODO maybe add cache
    Set<Annotation> result = new HashSet<Annotation>();
    Set<Annotation> toadd = new HashSet<Annotation>();
    for (Set<Annotation> anset : set) {
      if (result.size() == 0) {
        result.addAll(anset);
        continue;
      }
      //TODO Iterator.remove
      for (Annotation an : anset) {
        if (removeSuperSets(result, an)) {
          toadd.add(an);
        }
      }
      result.addAll(toadd);
      toadd.clear();
    }
    for (Annotation an : singleans) {
      an = getCopyAr(an);
      if (removeSuperSets(result, an)) {
        result.add(an);
      }
    }
    result = getCopySet(result);
    register(result);
    return result;
  }
  
  private static class MergeLarge
  {
    private Set<Annotation> mArg1;
    private Set<Annotation> mArg2;
    private int mHashCode;
    
    public MergeLarge(Set<Annotation> arg1, Set<Annotation> arg2)
    {
      mArg1 = arg1;
      mArg2 = arg2;
      mHashCode = mArg1.hashCode() * mArg2.hashCode();
    }
    
    public boolean equals(Object o)
    {
      if (!(o instanceof MergeLarge)) {
        return false;
      }
      MergeLarge m2 = (MergeLarge)o;
      if (mHashCode != m2.mHashCode) {
        return false;
      }
      return (mArg1 == m2.mArg1 && mArg2 == m2.mArg2);
    }
    
    public int hashCode()
    {
      return mHashCode;
    }
  }
  
  private static class MergeMed
  {
    private Set<Annotation> mArg1;
    private Annotation mArg2;
    private int mHashCode;
    
    public MergeMed(Set<Annotation> arg1, Annotation arg2)
    {
      mArg1 = arg1;
      mArg2 = arg2;
      mHashCode = mArg1.hashCode() * mArg2.hashCode();
    }
    
    public boolean equals(Object o)
    {
      if (!(o instanceof MergeMed)) {
        return false;
      }
      MergeMed m2 = (MergeMed)o;
      if (mHashCode != m2.mHashCode) {
        return false;
      }
      return (mArg1 == m2.mArg1 && mArg2 == m2.mArg2);
    }
    
    public int hashCode()
    {
      return mHashCode;
    }
  }
  
  private static class Merge
  {
    private Annotation mArg1;
    private Annotation mArg2;
    
    public Merge(Annotation arg1, Annotation arg2)
    {
      mArg1 = arg1;
      mArg2 = arg2;
    }
    
    public boolean equals(Object o)
    {
      if (!(o instanceof Merge)) {
        return false;
      }
      Merge m2 = (Merge)o;
      return (mArg1 == m2.mArg1 && mArg2 == m2.mArg2) ||
             (mArg1 == m2.mArg2 && mArg2 == m2.mArg1);
    }
    
    public int hashCode()
    {
      return mArg1.hashCode() * mArg2.hashCode();
    }
  }
  
  private static class SetWrapper
    implements Comparable<SetWrapper>
  {
    Set<Annotation> mSet;
    
    SetWrapper(Set<Annotation> set)
    {
      mSet = set;
    }
    
    int compareTo(SetWrapper set)
    {
      return SETCOUNT.get(set.mSet) - SETCOUNT.get(mSet);
    }
  }
  
  private static class Array
  {
    private final EventProxy[] mArray;
    private final int mHash;
    
    public Array(EventProxy[] array)
    {
      mArray = array;
      mHash = Arrays.hashCode(array);
    }
    
    public boolean equals(Object o) {
      if (!(o instanceof Array)) {
        return false;
      }
      Array a2 = (Array) o;
      return Arrays.equals(mArray, a2.mArray);
    }
    
    public int hashCode()
    {
      return mHash;
    }
  }
}
