import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import gnu.trove.TIntObjectHashMap;
import gnu.trove.TObjectIntHashMap;
import java.util.HashSet;
import java.util.Iterator;
import gnu.trove.TObjectIdentityHashingStrategy;
import java.util.Collections;
import java.util.Collection;
import net.sourceforge.waters.model.des.EventProxy;
import java.util.Set;
import java.util.ArrayList;
import gnu.trove.TObjectProcedure;

public class Annotations
{
  private static final Map<Merge, EventProxy[]> INTERSECTIONS = 
                       new HashMap<Merge, EventProxy[]>();
  private static final Map<MergeMed, Set<EventProxy[]>> INTERSECTIONSMED = 
                       new HashMap<MergeMed, Set<EventProxy[]>>();
  private static final Map<MergeLarge, Set<EventProxy[]>> INTERSECTIONSLARGE = 
                       new HashMap<MergeLarge, Set<EventProxy[]>>();
  private static final Map<Merge, Boolean> ISSUBSET = new HashMap<Merge, Boolean>();
  private static final Map<Array, EventProxy[]> ANNOTATIONS =
                       new HashMap<Array, EventProxy[]>();
  private static final Map<Set<EventProxy[]>, Set<EventProxy[]>> ANNOTATIONSETS =
                       new HashMap<Set<EventProxy[]>, Set<EventProxy[]>>();
  private static final TObjectIntHashMap<Set<EventProxy[]>> SETCOUNT =
                       new TObjectIntHashMap<Set<EventProxy[]>>(
                       new TObjectIdentityHashingStrategy<Set<EventProxy[]>>());
  
  //TODO possibly store annotations as try
                       
  private Annotations()
  {
  }
  
  static private EventProxy[] getCopyAr(EventProxy[] array)
  {
    Array ar = new Array(array);
    EventProxy[] res = ANNOTATIONS.get(ar);
    if (res == null) {
      res = array;
      ANNOTATIONS.put(ar, res);
    }
    return res;
  }
  
  static private Set<EventProxy[]> getCopySet(Set<EventProxy[]> set)
  {
    Set<EventProxy[]> res = ANNOTATIONSETS.get(set);
    if (res == null) {
      res = Collections.unmodifiableSet(set);
      ANNOTATIONSETS.put(res, res);
    }
    return res;
  }
  
  static private void clearCache()
  {
    INTERSECTIONS.clear();
    INTERSECTIONSMED.clear();
    INTERSECTIONSLARGE.clear();
    final Collection<Set<EventProxy[]>> keys = 
      new ArrayList<Set<EventProxy[]>>(SETCOUNT.size());
    SETCOUNT.forEachKey(new TObjectProcedure<Set<EventProxy[]>>() {
      public boolean execute(Set<EventProxy[]> set)
      {
        keys.add(set);
        return true;
      }
    });
    ANNOTATIONSETS.keySet().retainAll(keys);
    Set<EventProxy[]> ans = new HashSet<EventProxy[]>();
    for (Set<EventProxy[]> ev : keys) {
      ans.addAll(ev);
    }
    ANNOTATIONS.keySet().retainAll(ans);
  }
  
  static private void register(Set<EventProxy[]> set)
  {
    int count = SETCOUNT.get(set);
    count++;
    SETCOUNT.put(set, count);
  }
  
  static public void free(Set<EventProxy[]> set)
  {
    int count = SETCOUNT.get(set);
    count--;
    assert(count >= 0);
    if (count != 0) {
      SETCOUNT.put(set, count);
    } else {
      SETCOUNT.remove(set);
    }
  }
  
  /**
   *  Determines whether an1 is a subset of an2
   *
   *  @return true if an1 is a subset of an2, false otherwise.
   */
  static public boolean isSubset(EventProxy[] an1, EventProxy[] an2)
  {
    if (an1 == an2) {
      return true;
    }
    Merge merge = new Merge(an1, an2);
    Boolean answer = ISSUBSET.get(merge);
    if (answer != null) {
      return answer;
    }
    if (an1.length > an2.length) {
      EventProxy[] temp = an1;
      an1 = an2;
      an2 = temp;
    }
    int i1 = 0;
    int i2 = 0;
    while (i1 < an1.length && i2 < an2.length) {
      if (an1.length - i1 > an2.length - i2) {
        ISSUBSET.put(merge, false);
        return false;
      }
      if (an1[i1] == an2[i2]) {
        i1++;
        i2++;
        continue;
      }
      if (an1[i1].compareTo(an2[i2]) > 0) {
        ISSUBSET.put(merge, false);
        return false;
      }
      i2++;
    }
    ISSUBSET.put(merge, true);
    return true;
  }
  
  /**
   *  returns the intersection of an1 and an2
   */
  static public EventProxy[] merge(EventProxy[] an1, EventProxy[] an2)
  {
    Merge merge = new Merge(an1, an2);
    // if either is a subset of the other then the result of the merge will be
    // the smaller set
    if (ISSUBSET.get(merge)) {
      return an1.length < an2.length ? an1 : an2;
    }
    EventProxy[] ar = INTERSECTIONS.get(merge);
    if (ar != null) {
      return ar;
    }
    int i1 = 0;
    int i2 = 0;
    int i3 = 0;
    ar = new EventProxy[an1.length < an2.length ? an1.length : an2.length];
    while (i1 < an1.length && i2 < an2.length) {
      if (an1[i1] == an2[i2]) {
        ar[i3] = an1[i1];
        i1++;
        i2++;
        i3++;
        continue;
      }
      // anotations are kept sorted so increment the smaller of the two for
      // comparison
      if (an1[i1].compareTo(an2[i2]) > 0) {
        i2++;
      } else {
        i1++;
      }
    }
    // ar.length == i3 means that all of the smallest array went into ar in the
    // merge thus there is a subset
    if (ar.length == i3) {
      ISSUBSET.put(merge, true);
    } else {
      ISSUBSET.put(merge, false);
      EventProxy[] t = new EventProxy[i3];
      for (int i = 0; i < i3; i++) {
        t[i] = ar[i];
      }
      ar = t;
    }
    // we only want to have one copy of any annotation
    ar = getCopyAr(ar);
    INTERSECTIONS.put(merge, ar);
    return ar;
  }
  
  private static boolean removeSuperSets(Set<EventProxy[]> set, EventProxy[] other)
  {
    Iterator<EventProxy[]> it = set.iterator();
    boolean res = false;
    while (it.hasNext()) {
      EventProxy[] already = it.next();
      if (res && other.length >= already.length) {
        continue;
      }
      if (isSubset(already, other)) {
        if (other.length < already.length) {
          it.remove();
          res = true;
        } else {
          return false;
        }
      }
    }
    return true;
  }
  
  private static Set<EventProxy[]> mergeMed(Set<EventProxy[]> anset, EventProxy[] an2)
  {
    MergeMed merge = new MergeMed(anset, an2);
    Set<EventProxy[]> result = INTERSECTIONSMED.get(merge);
    if (result != null) {
      return result;
    }
    result = new HashSet<EventProxy[]>();
    for (EventProxy[] an1 : anset) {
      EventProxy[] intersect = merge(an1, an2);
      // TODO maybe this would be faster if done later and making certain that 
      // largest set done first
      if (removeSuperSets(result, intersect)) {
        result.add(intersect);
      }
    }
    //TODO don't think I need the getcopy here
    INTERSECTIONSMED.put(merge, result);
    return result;
  }
  
  public static Set<EventProxy[]> mergeLarge(Set<EventProxy[]> anset1,
                                              Set<EventProxy[]> anset2)
  {
    MergeLarge merge = new MergeLarge(anset1, anset2);
    Set<EventProxy[]> result = INTERSECTIONSLARGE.get(merge);
    if (result != null) {
      register(result);
      return result;
    }
    //The Set with the higher setcount is more likely to be merge with things
    //thus more likely to be cached in intersectionsmed
    //TODO maybe better to go with set with most annotations
    if (SETCOUNT.get(anset1) > SETCOUNT.get(anset2)) {
      Set<EventProxy[]> temp = anset1;
      anset1 = anset2;
      anset2 = temp;
    }
    if (anset2.size() == 1) {
      Set<EventProxy[]> temp = anset1;
      anset1 = anset2;
      anset2 = temp;
    }
    Set<EventProxy[]> toadd = new HashSet<EventProxy[]>();
    for (EventProxy[] an : anset1) {
      Set<EventProxy[]> intersectmed = mergeMed(anset2, an);
      if (result == null) {
        result = new HashSet<EventProxy[]>(intersectmed);
      }
      toadd.clear();
      for (EventProxy[] intersect : intersectmed) {
        if (removeSuperSets(result, intersect)) {
          toadd.add(intersect);
        }
      }
      result.addAll(toadd);
    }
    result = getCopySet(result);
    INTERSECTIONSLARGE.put(merge, result);
    register(result);
    return result;
  }
  
  public static Set<EventProxy[]> union(Collection<Set<EventProxy[]>> set,
                                        Collection<EventProxy[]> singleans)
  {
    //TODO maybe add cache
    Set<EventProxy[]> result = new HashSet<EventProxy[]>();
    Set<EventProxy[]> toadd = new HashSet<EventProxy[]>();
    for (Set<EventProxy[]> anset : set) {
      if (result.size() == 0) {
        result.addAll(anset);
        continue;
      }
      for (EventProxy[] an : anset) {
        if (removeSuperSets(result, an)) {
          toadd.add(an);
        }
      }
      result.addAll(toadd);
      toadd.clear();
    }
    for (EventProxy[] an : singleans) {
      an = getCopyAr(an);
      if (removeSuperSets(result, an)) {
        result.add(an);
      }
    }
    result = getCopySet(result);
    register(result);
    return result;
  }
  
  private static class MergeLarge
  {
    private Set<EventProxy[]> mArg1;
    private Set<EventProxy[]> mArg2;
    private int mHashCode;
    
    public MergeLarge(Set<EventProxy[]> arg1, Set<EventProxy[]> arg2)
    {
      mArg1 = arg1;
      mArg2 = arg2;
      mHashCode = mArg1.hashCode() * mArg2.hashCode();
    }
    
    public boolean equals(Object o)
    {
      if (!(o instanceof MergeLarge)) {
        return false;
      }
      MergeLarge m2 = (MergeLarge)o;
      if (mHashCode != m2.mHashCode) {
        return false;
      }
      return (mArg1 == m2.mArg1 && mArg2 == m2.mArg2);
    }
    
    public int hashCode()
    {
      return mHashCode;
    }
  }
  
  private static class MergeMed
  {
    private Set<EventProxy[]> mArg1;
    private EventProxy[] mArg2;
    private int mHashCode;
    
    public MergeMed(Set<EventProxy[]> arg1, EventProxy[] arg2)
    {
      mArg1 = arg1;
      mArg2 = arg2;
      mHashCode = mArg1.hashCode() * mArg2.hashCode();
    }
    
    public boolean equals(Object o)
    {
      if (!(o instanceof MergeMed)) {
        return false;
      }
      MergeMed m2 = (MergeMed)o;
      if (mHashCode != m2.mHashCode) {
        return false;
      }
      return (mArg1 == m2.mArg1 && mArg2 == m2.mArg2);
    }
    
    public int hashCode()
    {
      return mHashCode;
    }
  }
  
  private static class Merge
  {
    private EventProxy[] mArg1;
    private EventProxy[] mArg2;
    
    public Merge(EventProxy[] arg1,EventProxy[] arg2)
    {
      mArg1 = arg1;
      mArg2 = arg2;
    }
    
    public boolean equals(Object o)
    {
      if (!(o instanceof Merge)) {
        return false;
      }
      Merge m2 = (Merge)o;
      return (mArg1 == m2.mArg1 && mArg2 == m2.mArg2) ||
             (mArg1 == m2.mArg2 && mArg2 == m2.mArg1);
    }
    
    public int hashCode()
    {
      return mArg1.hashCode() * mArg2.hashCode();
    }
  }
  
  private static class Array
  {
    private final EventProxy[] mArray;
    private final int mHash;
    
    public Array(EventProxy[] array)
    {
      mArray = array;
      mHash = Arrays.hashCode(array);
    }
    
    public boolean equals(Object o) {
      if (!(o instanceof Array)) {
        return false;
      }
      Array a2 = (Array) o;
      return Arrays.equals(mArray, a2.mArray);
    }
    
    public int hashCode()
    {
      return mHash;
    }
  }
}
