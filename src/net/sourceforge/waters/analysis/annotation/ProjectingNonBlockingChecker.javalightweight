//# -*- indent-tabs-mode: nil  c-basic-offset: 2 -*-
//###########################################################################
//# PROJECT: Waters
//# PACKAGE: net.sourceforge.waters.analysis.modular
//# CLASS:   ProjectingControllabilityChecker
//###########################################################################
//# $Id: ProjectingControllabilityChecker.java 4468 2008-11-01 21:54:58Z robi $
//###########################################################################

package net.sourceforge.waters.analysis;

import gnu.trove.TIntHashSet;

import java.lang.Comparable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;

import net.sourceforge.waters.model.analysis.AbstractModelVerifier;
import net.sourceforge.waters.model.analysis.AnalysisException;
import net.sourceforge.waters.model.analysis.ControllabilityChecker;
import net.sourceforge.waters.model.analysis.ControllabilityKindTranslator;
import net.sourceforge.waters.model.analysis.KindTranslator;
import net.sourceforge.waters.model.analysis.OverflowException;
import net.sourceforge.waters.model.analysis.VerificationResult;
import net.sourceforge.waters.model.des.AutomatonProxy;
import net.sourceforge.waters.model.des.EventProxy;
import net.sourceforge.waters.model.des.ProductDESProxy;
import net.sourceforge.waters.model.des.ProductDESProxyFactory;
import net.sourceforge.waters.model.des.SafetyTraceProxy;
import net.sourceforge.waters.model.des.StateProxy;
import net.sourceforge.waters.model.des.TraceProxy;
import net.sourceforge.waters.model.des.TransitionProxy;
import net.sourceforge.waters.model.unchecked.Casting;
import net.sourceforge.waters.xsd.base.ComponentKind;
import net.sourceforge.waters.xsd.base.EventKind;
import net.sourceforge.waters.model.analysis.AbstractConflictChecker;
import net.sourceforge.waters.model.analysis.ConflictChecker;
import net.sourceforge.waters.analysis.modular.ObserverProjection;
import net.sourceforge.waters.analysis.modular.NonDeterministicComposer;
import net.sourceforge.waters.analysis.modular.BiSimulator;
import net.sourceforge.waters.model.des.ConflictTraceProxy;
import net.sourceforge.waters.analysis.monolithic.MonolithicConflictChecker;

import org.supremica.log.Logger;
import org.supremica.log.LoggerFactory;
import net.sourceforge.waters.analysis.LightWeightGraph;
import net.sourceforge.waters.cpp.analysis.NativeConflictChecker;


/**
 * The projectiong controllability check algorithm.
 *
 * @author Simon Ware
 */

public class ProjectingNonBlockingChecker
  extends AbstractConflictChecker
  implements ConflictChecker
{

  //#########################################################################
  //# Constructors
  public ProjectingNonBlockingChecker(final ProductDESProxy model,
                                      final ProductDESProxyFactory factory)
  {
    super(model, factory);
    mStates = 0;
    setNodeLimit(10000000);
    setMarkingProposition(getUsedMarkingProposition());
  }


  //#########################################################################
  //# Invocation
  public boolean run()
    throws AnalysisException
  {
    for (AutomatonProxy a : getModel().getAutomata()) {
      System.out.println(a.getName() + " " + a.getStates().size());
    }
    ProjectionList list = project(getModel());
    mMinAutMap.clear();
    System.out.println(list);
    ConflictChecker checker = 
      new NativeConflictChecker(createLightModel(getModel()), getMarkingProposition(),
                                getFactory());
    return checker.run();
    /*if (checker.run()) {
      mStates += checker.getAnalysisResult().getTotalNumberOfStates();
      setSatisfiedResult();
      return true;
    } else {
      mStates += checker.getAnalysisResult().getTotalNumberOfStates();
      TraceProxy counter = checker.getCounterExample();
      counter = list.getTrace(counter, model);
      List<EventProxy> e = counter.getEvents();
      counter = getFactory().createSafetyTraceProxy(getModel().getName(),
                                                    getModel(),
                                                    e.subList(0, e.size() - 1));
      setFailedResult(counter);
      return false;
    }*/
  }
  
  
  public ConflictTraceProxy getCounterExample()
  {
    return null;
  }


  //#########################################################################
  //# Overrides for Abstract Base Class
  //# net.sourceforge.waters.model.analysis.AbstractModelVerifier
  public void setNodeLimit(final int limit)
  {
    super.setNodeLimit(limit);
    if (limit > 500000) {
      mMaxProjStates = 500000;
    } else {
      mMaxProjStates = limit;
    }
  }

  protected void addStatistics(final VerificationResult result)
  {
    result.setNumberOfStates(mStates);
  }
  
  private ProductDESProxy createLightModel(ProductDESProxy model)
  {
    Set<LightWeightGraph> automata = new HashSet<LightWeightGraph>();
    Iterator<AutomatonProxy> autit = model.getAutomata().iterator();
    while (autit.hasNext()) {
      AutomatonProxy aut = autit.next();
      System.out.println(aut.getName() + " " + aut.getKind());
      if (ComponentKind.PROPERTY != aut.getKind()) {
        automata.add(new LightWeightGraph(aut, getFactory(),
                                          getMarkingProposition()));
      }
    }
    return getFactory().createProductDESProxy("model", model.getEvents(), automata);
  }

  private ProjectionList project(ProductDESProxy model)
    throws AnalysisException
  {
    mChecked.clear();
    Set<LightWeightGraph> automata = new HashSet<LightWeightGraph>();
    Iterator<AutomatonProxy> autit = model.getAutomata().iterator();
    while (autit.hasNext()) {
      AutomatonProxy aut = autit.next();
      System.out.println(aut.getName() + " " + aut.getKind());
      if (ComponentKind.PROPERTY != aut.getKind()) {
        automata.add(new LightWeightGraph(aut, getFactory(),
                                          getMarkingProposition()));
      }
    }
    ProjectionList p = null;
    while (true) {
      System.out.println("numautomata:" + automata.size());
      Map<Set<LightWeightGraph>, Integer> numoccuring =
        new HashMap<Set<LightWeightGraph>,Integer>();
      for (EventProxy e : model.getEvents()) {
        if (e == getMarkingProposition()) {
          continue;
        }
        Set<LightWeightGraph> possess = new HashSet<LightWeightGraph>();
        for (LightWeightGraph a : automata) {
          if (a.getEvents().contains(e)) {
            possess.add(a);
          }
        }
        if (!possess.isEmpty()) {
          if (numoccuring.get(possess) == null) {
            numoccuring.put(possess, 0);
          }
          numoccuring.put(possess, numoccuring.get(possess) + 1);
        }
      }
      Set<Tuple> possible = new TreeSet<Tuple>();
      boolean stop = true;
      System.out.println("keyset:" + numoccuring.keySet().size());
      for (Set<LightWeightGraph> s : numoccuring.keySet()) {
        if (s.size() > 4 && s.size() != automata.size()) {
          continue;
        }
        double size = 0;
        Set<EventProxy> common = new HashSet<EventProxy>(model.getEvents());
        Iterator<EventProxy> i = common.iterator();
        Set<EventProxy> total = new HashSet<EventProxy>();
        boolean contproj = false;
        for (LightWeightGraph a : s) {
          size += Math.log(a.getStateNum());
          total.addAll(a.getEvents());
          common.retainAll(a.getEvents());
        }
        Iterator<LightWeightGraph> it = s.iterator();
        double tot = total.size();
        double uncom = tot - common.size();
        size *= uncom;
        possible.add(new Tuple(s, size));
      }
      int overflows = 0;
      ProjectionList minlist = null;
      minSize = Integer.MAX_VALUE / 4;
      int setSize = -1;
      System.out.println("possible: " + possible.size());
      tuples:
      for (Tuple tup : possible) {
        try {
          long maxsize = 1;
          if (tup.mSet.size() > 1) {
            continue;
          }
          for (LightWeightGraph a : tup.mSet) {
            if (mDontOnOwn.contains(a) && tup.mSet.size() == 1) {
              continue tuples;
            }
            maxsize *= a.getStateNum();
          }
          System.out.println(maxsize);
          ProjectionList t =
            new ProjectionList(p, automata, tup.mSet);
          //if (minSize >= t.getNew().getStates().size()) {
            minlist = t;
            //minSize = t.getNew().getStates().size();
            break;
          //}
        } catch (final Exception exception) {
          exception.printStackTrace();
          System.out.println("over");
          overflows++;
        }
      }
      if (minlist != null) {
        p = minlist;
        automata = new HashSet<LightWeightGraph>(p.getAutomata());
        stop = false;
        System.out.println("numcomposed" + p.getComposed().size());
      }
      if (stop) {
        break;
      }
    }
    Iterator<AutomataHidden> it = mMinAutMap.keySet().iterator();
    while (it.hasNext()) {
      AutomataHidden ah = it.next();
      if (!mChecked.contains(ah)) {
        it.remove();
      }
    }
    return p;
  }

  private boolean setFailedResult(final TraceProxy counterexample,
                                  final Map<EventProxy,EventProxy> uncont)
  {
    final ProductDESProxyFactory factory = getFactory();
    final ProductDESProxy des = getModel();
    final String desname = des.getName();
    final String tracename = desname + ":uncontrollable";
    final List<EventProxy> events = counterexample.getEvents();
    final int len = events.size();
    final List<EventProxy> modevents = new ArrayList<EventProxy>(len);
    final Iterator<EventProxy> iter = events.iterator();
    EventProxy event = iter.next();
    while (iter.hasNext()) {
      modevents.add(event);
      event = iter.next();
    }
    for (final Map.Entry<EventProxy,EventProxy> entry : uncont.entrySet()) {
      if (entry.getValue() == event) {
        final EventProxy key = entry.getKey();
        modevents.add(key);
        break;
      }
    }
    final SafetyTraceProxy wrapper =
      factory.createSafetyTraceProxy(tracename, des, modevents);
    return super.setFailedResult(wrapper);
  }


  //#########################################################################
  //# Inner Class AutomatonComparator
  private final static class AutomatonComparator
    implements Comparator<AutomatonProxy>
  {
    public int compare(AutomatonProxy a1, AutomatonProxy a2)
    {
      return a1.getName().compareTo(a2.getName());
    }
  }


  //#########################################################################
  //# Inner Class ProjectionList
  private class ProjectionList
  {
    final Set<LightWeightGraph> mAutomata;
    final ProjectionList mParent;
    final Set<LightWeightGraph> mCompautomata;
    final Set<EventProxy> mOriginalAlphabet;
    final Set<EventProxy> mHidden;
    final AutomatonProxy mNew;
    final Set<EventProxy> mTarget;

    public ProjectionList(ProjectionList parent,
                          Set<LightWeightGraph> automata,
                          Set<LightWeightGraph> compAutomata)
      throws AnalysisException
    {
      mParent = parent;
      mCompautomata = compAutomata;
      mAutomata = new HashSet<LightWeightGraph>(automata);
      mAutomata.removeAll(compAutomata);
      Set<EventProxy> events = new HashSet<EventProxy>();
      for (AutomatonProxy a : compAutomata) {
        events.addAll(a.getEvents());
      }
      mOriginalAlphabet = events;
      mHidden = new HashSet<EventProxy>(events);
      for (AutomatonProxy a : mAutomata) {
        if (a != mSpec) {
          mHidden.removeAll(a.getEvents());
        }
      }
      AutomataHidden ah =
        new AutomataHidden(compAutomata, new HashSet<EventProxy>(mHidden));
      mChecked.add(ah);
      LightWeightGraph minAutomaton;
      if (mMinAutMap.containsKey(ah)) {
        minAutomaton = mMinAutMap.get(ah);
        if (minAutomaton == null) {
          throw new OverflowException();
        }
      } else {
        Set<EventProxy> forb = Collections.emptySet();
        System.out.println("marking: " + getMarkingProposition());
        try {
          NonDeterministicComposer composer =
            new NonDeterministicComposer(
              new ArrayList<LightWeightGraph>(compAutomata), getFactory(),
              getMarkingProposition());
          int size = 10000;
          composer.setNodeLimit(size);
          minAutomaton = composer.run();
          /*minAutomaton = TauRemoval.tauRemoval(minAutomaton, getIntSet(mHidden, minAutomaton.getLightEvents()),
                                               getFactory());
          /*BiSimulator sim = new BiSimulator(minAutomaton, getFactory());
          minAutomaton = sim.run();*/
          mStates += minAutomaton.getStateNum();
          mMinAutMap.put(ah, minAutomaton);
        } catch (final OverflowException exception) {
          mStates += mMaxProjStates;
          mMinAutMap.put(ah, null);
          throw exception;
        }
      }
      mAutomata.add(minAutomaton);
      mDontOnOwn.add(minAutomaton);
      mNew = minAutomaton;
      mTarget = new HashSet<EventProxy>();
      for (AutomatonProxy a : mAutomata) {
        mTarget.addAll(a.getEvents());
      }
    }
    
    private TIntHashSet getIntSet(Set<EventProxy> set, EventProxy[] array)
    {
      TIntHashSet res = new TIntHashSet(set.size());
      for (int i = 0; i < array.length; i++) {
        if (set.contains(array[i])) {
          res.add(i);
        }
      }
      return res;
    }

    public ProductDESProxy getModel()
    {
      return getFactory().createProductDESProxy("model", mTarget, mAutomata);
    }

    public Set<EventProxy> getHidden()
    {
      return mHidden;
    }

    public Set<LightWeightGraph> getComposed()
    {
      return mCompautomata;
    }

    public AutomatonProxy getNew()
    {
      return mNew;
    }
    
    public Set<LightWeightGraph> getAutomata()
    {
      return mAutomata;
    }

    public TraceProxy getTrace(TraceProxy trace, ProductDESProxy model)
    {
      List<Map<StateProxy, Set<EventProxy>>> events =
        new ArrayList<Map<StateProxy, Set<EventProxy>>>(mCompautomata.size());
      List<Map<Key, StateProxy>> automata =
        new ArrayList<Map<Key, StateProxy>>(mCompautomata.size());
      List<StateProxy> currstate = new ArrayList<StateProxy>(mCompautomata.size());
      AutomatonProxy[] aut = new AutomatonProxy[mCompautomata.size()];
      int i = 0;
      for (AutomatonProxy proxy : mCompautomata) {
        events.add(new HashMap<StateProxy, Set<EventProxy>>(proxy.getStates().size()));
        automata.add(new HashMap<Key, StateProxy>(proxy.getTransitions().size()));
        Set<EventProxy> autevents = new HashSet<EventProxy>(mOriginalAlphabet);
        //System.out.println(autevents);
        autevents.removeAll(proxy.getEvents());
        //System.out.println(autevents);
        int init = 0;
        Set<StateProxy> states = proxy.getStates();
        for (StateProxy s : states) {
          if (s.isInitial()) {
            init++;
            currstate.add(s);
          }
          events.get(i).put(s, new HashSet<EventProxy>(autevents));
        }
        assert(init == 1);
        Collection<TransitionProxy> trans = proxy.getTransitions();
        for (TransitionProxy t : trans) {
          events.get(i).get(t.getSource()).add(t.getEvent());
          automata.get(i).put(new Key(t.getSource(), t.getEvent()), t.getTarget());
        }
        aut[i] = proxy;
        i++;
      }
      Queue<Place> stateList = new PriorityQueue<Place>();
      Place place = new Place(currstate, null, 0, null);
      stateList.offer(place);
      List<EventProxy> oldevents = trace.getEvents();
      //System.out.println(oldevents);

      Set<Place> visited = new HashSet<Place>();
      visited.add(place);
      while (true) {
        place = stateList.poll();
        //System.out.println(place.getTrace());
        if (place.mIndex >= oldevents.size()) {
          break;
        }
        currstate = place.mCurrState;
        Set<EventProxy> possevents = new HashSet<EventProxy>(mHidden);
        //System.out.println(mHidden);
        hidden:
        for (EventProxy pe : possevents) {
          //System.out.println(pe);
          List<StateProxy> newstate = new ArrayList<StateProxy>(currstate.size());
          for (i = 0; i < currstate.size(); i++) {
            if (aut[i].getEvents().contains(pe)) {
              StateProxy t = automata.get(i).get(new Key(currstate.get(i), pe));
              //System.out.println(t);
              if (t == null) {
                continue hidden;
              }
              newstate.add(t);
            } else {
              newstate.add(currstate.get(i));
            }
          }
          //System.out.println(newstate);
          Place newPlace = new Place(newstate, pe, place.mIndex, place);
          if (visited.add(newPlace)) {
            stateList.offer(newPlace);
          }
        }
        EventProxy currevent = oldevents.get(place.mIndex);
        List<StateProxy> newstate = new ArrayList<StateProxy>(currstate.size());
        boolean contains = true;
        for (i = 0; i < currstate.size(); i++) {
          if (aut[i].getEvents().contains(currevent)) {
            StateProxy t = automata.get(i).get(new Key(currstate.get(i), currevent));
            if (t == null) {
              contains = false;
            }
            newstate.add(t);
          } else {
            newstate.add(currstate.get(i));
          }
        }
        Place newPlace = new Place(newstate, currevent, place.mIndex + 1, place);
        if (contains && visited.add(newPlace)) {
          stateList.offer(newPlace);
        }
        assert(!stateList.isEmpty());
      }
      stateList = null;
      ProductDESProxy mod = mParent == null ? model : mParent.getModel();
      trace = getFactory().createSafetyTraceProxy(mod, place.getTrace());
      return mParent == null ? trace : mParent.getTrace(trace, model);
    }

    private class Place
      implements Comparable<Place>
    {
      public final List<StateProxy> mCurrState;
      public final EventProxy mEvent;
      public final int mIndex;
      public final Place mParent;

      public Place(List<StateProxy> currState, EventProxy event,
                   int index, Place parent)
      {
        mCurrState = currState;
        mEvent = event;
        mIndex = index;
        mParent = parent;
      }

      public List<EventProxy> getTrace()
      {
        if (mParent == null) {
          return new LinkedList<EventProxy>();
        }
        List<EventProxy> events = mParent.getTrace();
        events.add(mEvent);
        return events;
      }

      public int compareTo(Place other)
      {
        return other.mIndex - mIndex;
      }

      public int hashCode()
      {
        int hash = 7;
        hash = hash + mIndex * 31;
        hash = hash + mCurrState.hashCode();
        return hash;
      }

      public boolean equals(Object o)
      {
        Place p = (Place) o;
        return p.mIndex == mIndex && p.mCurrState.equals(mCurrState);
      }
    }

    private class Key
    {
      private final StateProxy mState;
      private final EventProxy mEvent;
      private final int mHash;

      public Key(StateProxy state, EventProxy event)
      {
        int hash = 7;
        hash += state.hashCode() * 31;
        hash += event.hashCode() * 31;
        mState = state;
        mEvent = event;
        mHash = hash;
      }

      public int hashCode()
      {
        return mHash;
      }

      public boolean equals(final Object other)
      {
        if (other != null && other.getClass() == getClass()) {
          final Key key = (Key) other;
          return mState.equals(key.mState) && mEvent.equals(key.mEvent);
        } else {
          return false;
        }
      }
    }
  }

  private static class AutomataHidden
  {
    public final Set<LightWeightGraph> mAutomata;
    public final Set<EventProxy> mHidden;

    public AutomataHidden(Set<LightWeightGraph> automata, Set<EventProxy> hidden)
    {
      mAutomata = automata;
      mHidden = hidden;
    }

    public int hashCode()
    {
      int code = 31 + mAutomata.hashCode();
      code = code * 31 + mHidden.hashCode();
      return code;
    }

    public boolean equals(Object o)
    {
      if (o instanceof AutomataHidden) {
        AutomataHidden a = (AutomataHidden) o;
        return mAutomata.equals(a.mAutomata) && mHidden.equals(a.mHidden);
      }
      return false;
    }
  }

  private static class Tuple
    implements Comparable<Tuple>
  {
    public final Set<LightWeightGraph> mSet;
    public final double mSize;

    public Tuple(Set<LightWeightGraph> set, double size)
    {
      mSet = set;
      mSize = size;
    }

    public int compareTo(Tuple t)
    {
      if (mSize < t.mSize) {
        return -1;
      } else if (mSize == t.mSize) {
        return 0;
      } else {
        return 1;
      }
    }
  }


  //#########################################################################
  //# Data Members
  private int minSize = 1000;
  private AutomatonProxy mSpec = null;
  private int mStates;
  private int mMaxProjStates;
  private Map<AutomataHidden, LightWeightGraph> mMinAutMap =
    new HashMap<AutomataHidden, LightWeightGraph>();
  private Set<AutomataHidden> mChecked = new HashSet<AutomataHidden>();
  private Set<AutomatonProxy> mDontOnOwn = new HashSet<AutomatonProxy>();


  //#########################################################################
  //# Class Constants
  private static final Logger LOGGER =
    LoggerFactory.createLogger(ProjectingNonBlockingChecker.class);

}
